<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《认知觉醒：开启自我改变的原动力》-读书笔记-1</title>
    <link href="/2024/04/29/4-29blog/"/>
    <url>/2024/04/29/4-29blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一次失败，只是证明我们成功的决心还够坚强。——博维</p></blockquote><span id="more"></span><h1 id="自序"><strong>自序</strong></h1><ul><li>所谓心智，通俗地说，就是我们看待人和事的态度，以及由此做出的判断与选择。</li><li>他们天然追求简单、轻松、舒适、确定，这种天性支配着他们，成为他们喜怒哀乐的生理起点</li><li>然而现实并不总像我们想象的那样。在这份十足的信心陪伴多年之后，大多数人发现自己并没有变得特别，而是在不断地服从社会规则和应对生活烦恼，开始随波逐流：该玩手机玩手机、该打游戏打游戏；没有多少压力，也没有多少动力；觉得反正日子还过得去，希望也还在心里，偶尔挣扎呐喊一声，而后继续做着短视的选择，沉溺于眼前的安逸。</li><li>他们跳出了成长的陷阱，开始刻意提升自己，为未来美好的生活做准备</li><li>然而很快遇到了瓶颈：想勤奋，却总是敌不过惰性；想努力，却总是陷入低效的状态；想精进，面前却总是弯路不断；读了很多书，都忘了；付出很多努力，都白费了</li><li>有空就找朋友们聚会，时常喝到烂醉；经常熬夜，从不主动看书、运动；打发时间的方式就是看搞笑视频、读八卦新闻、玩手机游戏；实在没事可做，就裹起被子睡大觉……下意识中，我觉得这种无忧的生活会继续下去。</li><li>这些问题让我倒吸了一口凉气，因为我突然发现自己几乎什么都不会</li><li>我发现每天有事情做不代表觉醒，每天都努力也不代表觉醒，真正的觉醒是一种发自内心的渴望，立足长远，保持耐心，运用认知的力量与时间做朋友；我发现人与人之间的根本差异是认知能力上的差异，因为认知影响选择，而选择改变命运，所以成长的本质就是让大脑的认知变得更加清晰</li><li>实践和改变</li><li>人生没有什么定数，不折腾，时间同样会过去，所以，去做总比不做好，开始总比放弃强。</li></ul><h1id="第一章大脑一切问题的起源"><strong>第一章大脑——一切问题的起源</strong></h1><p><img src="https://pic.imgdb.cn/item/662f97b10ea9cb1403376893.jpg"alt="DM_20240214181853_001" /><imgsrc="https://pic.imgdb.cn/item/662f97b10ea9cb140337685f.jpg"alt="DM_20240214102647_001" /></p><figure><img src="https://pic.imgdb.cn/item/662f97b10ea9cb14033768f7.jpg"alt="DM_20240214181853_002" /><figcaption aria-hidden="true">DM_20240214181853_002</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f97b10ea9cb140337692e.jpg"alt="DM_20240216095809_001" /><figcaption aria-hidden="true">DM_20240216095809_001</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f983d0ea9cb140338cd76.jpg"alt="DM_20240216095809_002" /><figcaption aria-hidden="true">DM_20240216095809_002</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f983d0ea9cb140338cdf2.jpg"alt="DM_20240216221039_001" /><figcaption aria-hidden="true">DM_20240216221039_001</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f983e0ea9cb140338ce3d.jpg"alt="DM_20240216221158_001" /><figcaption aria-hidden="true">DM_20240216221158_001</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f983e0ea9cb140338ce73.jpg"alt="DM_20240216221434_001" /><figcaption aria-hidden="true">DM_20240216221434_001</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f983e0ea9cb140338ceca.jpg"alt="DM_20240216221501_001" /><figcaption aria-hidden="true">DM_20240216221501_001</figcaption></figure><p>认知闭合，效能降低</p><p>一件事若迟迟没有完成，心里总是记挂，期盼着早点结束；此时一旦完成，做这件事的动机就会立即趋向于零。</p><figure><img src="https://pic.imgdb.cn/item/662f98860ea9cb1403397aa1.jpg"alt="DM_20240217093151_001" /><figcaption aria-hidden="true">DM_20240217093151_001</figcaption></figure><p>设下限不设上限</p><p>改变自己的学习心态，通过人自身的向好之心来牵引自己学习，产生成就感，产生沉浸，不用带着顾虑去学习。</p><p>是否有及时、持续的正向反馈，正是产生学习效果差异的关键。</p><figure><img src="https://pic.imgdb.cn/item/662f98860ea9cb1403397adb.jpg"alt="DM_20240217094037_001" /><figcaption aria-hidden="true">DM_20240217094037_001</figcaption></figure><p>定义明确的目标、极度的专注、有效的反馈、在拉伸区练习</p><figure><img src="https://pic.imgdb.cn/item/662f98860ea9cb1403397b0a.jpg"alt="DM_20240217095145_001" /><figcaption aria-hidden="true">DM_20240217095145_001</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f98860ea9cb1403397b35.jpg"alt="DM_20240217095145_002" /><figcaption aria-hidden="true">DM_20240217095145_002</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f98860ea9cb1403397b6f.jpg"alt="DM_20240217095526_001" /><figcaption aria-hidden="true">DM_20240217095526_001</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f98ad0ea9cb140339d0c9.jpg"alt="DM_20240217095526_002" /><figcaption aria-hidden="true">DM_20240217095526_002</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f98ae0ea9cb140339d19f.jpg"alt="DM_20240218105728_003" /><figcaption aria-hidden="true">DM_20240218105728_003</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f98ae0ea9cb140339d168.jpg"alt="DM_20240218105728_002" /><figcaption aria-hidden="true">DM_20240218105728_002</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f98ae0ea9cb140339d1b7.jpg"alt="DM_20240218105728_004" /><figcaption aria-hidden="true">DM_20240218105728_004</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f98ae0ea9cb140339d148.jpg"alt="DM_20240218105728_001" /><figcaption aria-hidden="true">DM_20240218105728_001</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/662f99210ea9cb14033aa4c1.jpg"alt="DM_20240218110522_001" /><figcaption aria-hidden="true">DM_20240218110522_001</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
      <category>《认知觉醒：开启自我改变的原动力》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《这就是ChatGPT》-读书笔记-1</title>
    <link href="/2024/04/28/4-28blog/"/>
    <url>/2024/04/28/4-28blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>生活的情况越艰难，我越感到自己更坚强，甚而也更聪明。——高尔基</p></blockquote><span id="more"></span><h1 id="第一章-chat-gpt在做什么它为和能做到这些">第一章 ChatGPT在做什么？它为和能做到这些？</h1><h2 id="他只是一次添加一个词">他只是一次添加一个词</h2><p>通俗解释，你可以想象你是一个ChatGPT，你在阅读了数十亿个网页的内容后，在听了别人说的一句话后，可能会猜测下一句话说什么。它（泛指各类大模型）做的事情就是这样，只不过不是查看字面上的文本，而是寻找某种意义上“意义匹配”的事物。</p><p>也即是“概率”，通过选取概率，每次选取一个概率最大的词，添加后再重新选取下一个词，从而不断重复增加进去。</p><h2 id="概率从何而来">概率从何而来</h2><blockquote><p>ChatGPT总是根据概率选择下一个词，但是这些概率是从何而来的呢？让我们从一个更简单的问题开始：考虑逐字母（而非逐词）地生成英文文本。怎样才能计算出每个字母应当出现的概率呢？</p></blockquote><p>最佳思路是<u>建立一个模型</u>，让我们能够估计序列出现的<strong>概率</strong>—即使我们从未在已有的文本语料库中明确看到过这些序列。ChatGPT的核心正是所谓的“大语言模型”，后者已经被构建得能够很好地估计这些概率了。</p><ul><li><p>建立模型</p></li><li><p>估计概率</p></li><li><p>输出单词</p></li></ul><h2 id="什么是模型">什么是模型</h2><p><a href="https://wiki.mbalib.com/wiki/模型">模型 - MBA智库百科(mbalib.com)</a></p><p>简单讲：</p><ul><li>模型系<strong>以简单的图形、实体或符号来代表一个 需要的真实系统</strong>，以化繁为简，易于控制 ，方便进行预测。</li></ul><p>你使用的任何模型都有某种特定的<strong>基本结构</strong>，以及用于拟合数据的一定数量的“旋钮”（也就是可以<strong>设置的参数</strong>）。</p><p>ChatGPT使用了许多这样的“旋钮”—实际上有1750亿个。</p><h2 id="类人任务的模型">类人任务的模型</h2><p>上文提到的例子涉及为数值数据建立模型，这些数据基本上来自简单的物理学—几个世纪以来，我们已经知道可以用一些“简单的数学工具”为其建模。但是对于ChatGPT，我们需要为人脑产生的人类语言文本建立模型。而对于这样的东西，我们（至少目前）还没有“简单的数学”可用。</p><p>如果我们的目标是为人类在识别图像方面的能力生成一个模型，真正需要问的问题是：面对一个模糊的图像，并且不知道其来源，人类会用什么方式来识别它？</p><h2 id="神经网络">神经网络</h2><p><ahref="https://playground.tensorflow.org/#activation=tanh&amp;batchSize=10&amp;dataset=circle&amp;regDataset=reg-plane&amp;learningRate=0.03&amp;regularizationRate=0&amp;noise=0&amp;networkShape=4,2&amp;seed=0.53810&amp;showTestData=false&amp;discretize=false&amp;percTrainData=50&amp;x=true&amp;y=true&amp;xTimesY=false&amp;xSquared=false&amp;ySquared=false&amp;cosX=false&amp;sinX=false&amp;cosY=false&amp;sinY=false&amp;collectStats=false&amp;problem=classification&amp;initZero=false&amp;hideText=false">ANeural Network Playground (tensorflow.org)</a></p><p>我们拿上面的网站进行测试：</p><p><imgsrc="https://pic.imgdb.cn/item/662f9fed0ea9cb14034ba237.png" /></p><p>通过实验可以看出来，当神经元的个数够多，它的分类效果越好，速度越快。</p><p>你们也可以去试试，它是完全免费的。</p><p>更大的神经网络通常能更好地逼近我们所求的函数。</p>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
      <category>《这就是ChatGPT》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pay Attention to MLPs</title>
    <link href="/2024/04/27/4-27blog/"/>
    <url>/2024/04/27/4-27blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>生活的情况越艰难，我越感到自己更坚强，甚而也更聪明。——高尔基</p></blockquote><span id="more"></span><h1 id="pay-attention-to-mlps">Pay Attention to MLPs</h1><h2 id="摘要">摘要</h2><p>Transformers[1]已经成为深度学习领域最重要的架构创新之一，并在过去几年中取得了许多突破性进展。在这里，我们提出了一种简单的网络架构gMLP，它基于带有门控的MLP，并表明它在关键的语言和视觉应用中可以与Transformer实现相同的性能。我们的比较表明，自注意力对于Vision Transformers 来说并不重要，因为 gMLP可以达到相同的精度。对于BERT，我们的模型在预训练复杂度方面与Transformers相当，在一些下游NLP任务中表现更好。在gMLP表现较差的微调任务中，大幅扩大gMLP模型可以缩小与Transformers的差距。总体而言，我们的实验表明，在数据和计算量增加的情况下，gMLP的扩展能力不亚于Transformers。（gMLP可以像Transformer一样在增加的数据和计算上进行扩展。）</p><h2 id="一引言">一、引言</h2><p>Transformer已经在自然语言处理（例如[2, 3, 4, 5,6]）方面取得了许多突破，并且在计算机视觉（例如[7, 8, 9,10]）方面表现出色。得益于这一成功，Transformer在很大程度上取代了LSTM-RNN[11]，成为NLP领域的默认架构，并在计算机视觉领域成为ConvNets[12,13, 14, 15, 16, 17]的替代方案。</p><p>Transformer架构结合了两个重要概念：(1)无递归架构，并行计算每个单个标记的表征；(2)多头自注意块，聚合各标记的空间信息。一方面，注意机制[18]引入了归纳偏差，即空间交互应该根据输入表征动态参数化。另一方面，众所周知，静态参数化的MLP可以表示任意函数[19]。因此，自我注意中的归纳偏差是否是Transformers取得显著效果的关键，仍然是一个悬而未决的问题。</p><p>在此，我们研究了自注意模块在Transformers的关键语言和视觉应用中的必要性。具体而言，我们提出了一种基于MLP的无自我注意的Transformers替代方案，该方案由通道投影和静态参数化的空间投影组成。我们对该架构的几种设计选择进行了实验，发现当空间投影是线性的并与乘法门控配对时，效果很好（图1）。我们将该模型命名为gMLP，因为它是由带有门控的基本MLP层构建而成的。</p><p>我们将gMLP应用于图像分类，并在ImageNet上取得了很好的结果。在类似的训练设置下，gMLP的性能与DeiT[8]，即改进了正则化的VisionTransformer（ViT）[7]相当。在参数减少66%的情况下，gMLP模型的准确度比MLP-Mixer[20]高3%。与Tolstikhin等人[20]、Melas-Kyriazi[21]、Touvron等人[22]和Ding等人[23]的研究结果一样，我们的研究结果也质疑了视觉转换器中自注意力模块的必要性。</p><p>我们将gMLP应用于BERT[2]中的掩码语言建模（MLM），这是Transformer最成熟的应用之一，并发现在预训练过程中，它与Transformer一样能够最小化困惑度。我们的实验证明，困惑度只与模型容量相关，对自注意力的存在不敏感。随着容量的增加，我们观察到gMLP和Transformer在预训练和微调指标上的改善速度相同。这是非常显著的，因为它表明尽管没有自注意力，gMLP与Transformer一样能够进行有效的扩展，而且通过增加数据和计算训练更大的模型，可以弥补任何性能差距。在与原始BERT相同的256批次大小×1M步骤的训练设置下，大型gMLP模型在MNLI上达到87.7%的准确率，在SQuADv2.0上达到82.1%的F1分数。请注意，这些结果优于Devlin等人[2]在使用Transformer时报告的<spanclass="math inline">\(BERT_{large}\)</span>结果。</p><p><img src="https://pic.imgdb.cn/item/662caae20ea9cb140365479f.png" alt="tu-1"  /></p><p>图1：带有空间门控单元（SGU）的gMLP架构概述。该模型由L个具有相同结构和大小的块堆叠而成。所有投影操作都是线性的，"<spanclass="math inline">\(\odot\)</span>"表示逐元素相乘（线性门控）。输入和输出协议遵循NLP中的BERT和视觉中的ViT。与Transformer不同，gMLP不需要位置编码，并且在NLP微调期间也不需要屏蔽填充。</p><p>左边是：gmlp架构概述 ；右边是：gMLP模块伪代码</p><p>对于BERT的微调，在需要跨句子对齐的任务上，Transformer在实践中可能比gMLP更具优势（例如，在300M参数范围内在MNLI-m上提高0.8%），即使预训练困惑度相似。这个问题可以通过使gMLP模型大幅增大，——是Transformers的3倍来解决。一个更实用的解决方案是仅混合少量的自注意力——单头自注意力的大小最多为128，足以使gMLP在我们评估的所有NLP任务上表现优于Transformer，且参数利用效率更高。在某些情况下，这种改进非常显著（例如，在SQuADv2.0上超过BERTlarge的+4.4%）。</p><p>总体而言，gMLPs在视觉和NLP领域令人惊讶的有效性表明，自我关注并不是扩展机器学习模型的必要因素，尽管根据任务的不同，它可能是一个有用的补充。通过增加数据和计算，具有更简单的空间交互机制（如gMLP）的模型可以与Transformer一样强大，并且分配给自注意力的容量可以被删除或大幅减少。</p><h2 id="二模型">二、模型</h2><p>我们的模型gMLP由L个具有相同大小和结构的块堆叠而成。让<spanclass="math inline">\(X∈\R^{n×d}\)</span>是序列长度为n、维度为d的标记表示：<span class="math display">\[Z=\sigma(XU), \\\widetilde{Z}=s(Z),\\Y=\widetilde{Z}V\]</span> 其中，σ是一个激活函数，例如GeLU[24]。U和V定义了沿着通道维度的线性投影，与Transformer中的前馈神经网络（FFN）中的投影相同（例如，对于<spanclass="math inline">\(BERT_{base}\)</span>，它们的形状为<spanclass="math inline">\(768×3072\)</span>和<spanclass="math inline">\(3072×768\)</span>）。为简洁起见，省略了快捷方式、归一化和偏置。上述公式中的一个关键因素是<spanclass="math inline">\(s(·)\)</span>，它是一个捕捉空间交互的层（见下文）。当<spanclass="math inline">\(s\)</span>是一个恒等映射时，上述转换退化为一个常规的FFN，其中单个标记被独立处理，没有任何跨标记通信。因此，我们的主要关注点之一是设计一个能够捕捉跨标记之间复杂空间交互的良好的<spanclass="math inline">\(s\)</span>。整体的块布局受到反向瓶颈（invertedbottlenecks）[25]的启发，其中s(·)被定义为一个空间深度卷积。请注意，与Transformer不同，我们的模型不需要位置嵌入，因为<spanclass="math inline">\(s(·)\)</span>中会捕捉到这些信息。</p><p>我们的模型与BERT（用于NLP）和ViT（用于视觉）完全相同的输入和输出协议。例如，在语言任务的微调中，我们将多个文本段连接在一起，然后进行填充，预测是通过保留的<strong>&lt;cls&gt;</strong>符号的最后一层表示推断出来的。尽管许多这些协议是为了Transformer而引入的，因此对于gMLP来说可能不是最优的，但严格遵循它们有助于避免我们实验中的混淆因素，并使我们的层与现有的Transformer实现更兼容。</p><h3 id="空间门控单元">2.1 空间门控单元</h3><p>为了实现跨标记交互，层s(·)必须包含空间维度的收缩运算。最简单的方法是线性投影：<span class="math display">\[f_{W,b}(Z) = W Z + b\]</span> 其中<span class="math inline">\(W ∈ \R^{n×n}\)</span>是一个矩阵，其大小与序列长度<spanclass="math inline">\(n\)</span>相同，<spanclass="math inline">\(b\)</span>是特定标记的偏置。</p><p>例如，如果填充的输入序列有128个标记，则<spanclass="math inline">\(W\)</span>的形状将是<spanclass="math inline">\(128×128\)</span>。与自注意力不同，自注意力的<spanclass="math inline">\(W(Z)\)</span>是从<spanclass="math inline">\(Z\)</span>动态生成的，而在公式（2）中的空间投影矩阵<spanclass="math inline">\(W\)</span>与输入表示无关。</p><p>在本文中，我们将层<spanclass="math inline">\(s(·)\)</span>表述为线性门控的输出： <spanclass="math display">\[s(Z)=Z\odot f_{W,b}(Z)\]</span> 其中<spanclass="math inline">\(\odot\)</span>表示逐元素乘法。为了训练的稳定性，我们发现将W初始化为接近零的值，将b初始化为1是至关重要的，这意味着<spanclass="math inline">\(f_{W,b}(Z) ≈ 1\)</span>，因此在训练开始时<spanclass="math inline">\(s(Z) ≈Z\)</span>。这种初始化确保了每个gMLP块在训练的早期阶段行为类似于常规的FFN，即每个标记都是独立处理的，并且在学习过程中逐渐注入跨标记的空间信息。</p><p>我们进一步发现，在门控函数和乘法旁路中，将Z沿着通道维度分为两个独立的部分<spanclass="math inline">\(（Z_1，Z_2）\)</span>是有效的： <spanclass="math display">\[s(Z)=Z_1\odot f_{W,b}(Z_2)\]</span> 我们还将输入归一化为<spanclass="math inline">\(f_{W,b}\)</span>，这从经验上提高了大型NLP模型的稳定性。这就得到了图1所示的单元，我们在本文中将其称为空间门控单元（SGU）。在表3中，我们提供了消融研究，将SGU与<spanclass="math inline">\(s(·)\)</span>的其他几种变体进行了比较，结果表明SGU工作得更好，缩小了与自我关注的性能差距。</p><h4 id="sgu与现有层的联系">SGU与现有层的联系</h4><p>SGU的整体结构类似于门控线性单元（GLUs）[26, 27,28]以及早期的工作，以及包括HighwayNetworks[29]和LSTM-RNNs[11]在内的早期工作。关键区别在于，我们的门控是基于对空间（跨标记）维度的投影进行计算，而不是基于通道（隐藏）维度。SGU也与挤压-激发（Squeeze-and-Excite，SE）块[30]在元素乘法方面相关。然而，与SE块不同，SGU根本不包含跨通道的投影，并且也不强制要求置换不变性(以内容为基础的激励模块的关键特征），因为它对空间变换采用了静态参数化。理论上，SGU中的空间投影可以学习表达表面的深度卷积--与典型的具有特定通道滤波器的深度卷积不同，SGU只学习跨通道共享的单一变换。最后，我们注意到SGU提供了除了自注意力以外的捕获高阶关系的替代机制。具体而言，方程（3）的输出包含高达二阶的相互作用（例如<spanclass="math inline">\(z_iz_j\)</span>），而自注意力（假设没有非线性）的输出最多包含三阶相互作用（例如<spanclass="math inline">\(q_ik_jv_k\)</span>）。在计算成本方面，SGU具有<spanclass="math inline">\(n²e/2\)</span>个乘加操作，与点积自注意力的<spanclass="math inline">\(n²d\)</span>相当。两者在输入通道大小上都是线性的，在序列长度<spanclass="math inline">\(n\)</span>上都是二次的。</p><h2 id="三图像分类">三、图像分类</h2><p>在这里，我们通过将gMLP应用于ImageNet的图像分类任务中来研究其在视觉领域的表现，而无需使用额外的数据。我们将我们的类似MLP的模型与基于传统Transformer的最新注意力模型进行比较，包括VisionTransformer (ViT) [7]、DeiT[8]（改进了正则化的ViT）以及其他几种代表性的卷积网络模型。</p><p>表格1总结了我们的gMLP图像分类模型的配置。输入和输出协议遵循ViT/B16的方式，即将原始图像转换为16×16的图块。深度和宽度的选择使得这些模型在容量上与ViT/DeiT相当。与Transformer类似，我们发现gMLP模型很容易对训练数据过拟合。因此，我们采用了与DeiT中相似的正则化方法。为了避免过多的调整，我们只在表格1中从较小模型转移到较大模型时调整了随机深度的强度。所有其他超参数在我们的三个模型中保持不变。详细信息请参见附录A.1。</p><p>表1：用于视觉的gMLP模型的架构规格。从较小模型到较大模型，随机深度的存活概率是唯一的超参数变化。</p><table><thead><tr class="header"><th></th><th>#L</th><th><span class="math inline">\(d_{model}\)</span></th><th><span class="math inline">\(d_{ffn}\)</span></th><th>参数量 (百万)</th><th>FLOPs (十亿)</th><th>存活概率</th></tr></thead><tbody><tr class="odd"><td>gMLP-Ti</td><td>30</td><td>128</td><td>768</td><td>5.9</td><td>2.7</td><td>1.00</td></tr><tr class="even"><td>gMLP-S</td><td>30</td><td>256</td><td>1536</td><td>19.5</td><td>8.9</td><td>0.95</td></tr><tr class="odd"><td>gMLP-B</td><td>30</td><td>512</td><td>3072</td><td>73.4</td><td>31.6</td><td>0.80</td></tr></tbody></table><p>我们的ImageNet结果总结在表格1和图2中。有趣的是，gMLP模型与DeiT[8]（即使用改进的正则化训练的ViT[7]）具有可比性。这些结果表明，没有自注意力的模型在图像分类任务上可以与Transformers一样高效。事实上，当模型得到适当的正则化时，它们的准确性似乎更与容量相关，而不是与自注意力的存在相关。此外，gMLP模型的准确性-参数/FLOPs的权衡超过了所有同时提出的类似MLP架构[20,21,22]，我们将其归因于我们的空间门控单元（请参见下一节的表3进行消融实验）。我们还注意到，虽然gMLP模型在与原始Transformers的比较中表现竞争力，但其性能仍落后于最好的现有卷积网络模型（例如[33,34]）或混合模型（例如[35, 36, 37, 38, 10]）。</p><p><img src="https://pic.imgdb.cn/item/662caae20ea9cb14036547c8.png" alt="tu-2"  /></p><p><strong>图2：ImageNet准确率与模型容量的关系。</strong></p><p>表 2：没有额外数据的 ImageNet-1K 结果</p><p><img src="https://pic.imgdb.cn/item/662caa340ea9cb140363c075.png" alt="biao-2" style="zoom:50%;" /></p><p>图3展示了gMLP-B中的空间投影矩阵。值得注意的是，学习后的空间权重展现了局部性和空间不变性。换句话说，每个空间投影矩阵有效地学会了使用数据驱动的、不规则（非方形）的卷积核进行卷积操作。</p><figure><img src="https://pic.imgdb.cn/item/662caae20ea9cb1403654814.png"alt="tu-3" /><figcaption aria-hidden="true">tu-3</figcaption></figure><p><strong>图3：gMLP-B中的空间投影权重。每一行显示了同一层中一组选定标记的滤波器（经过重塑成2D形状）。</strong></p><h2 id="四使用bert进行掩码语言建模">四、使用BERT进行掩码语言建模</h2><p>在这里，我们对掩码语言建模（MLM）任务进行了实证研究。预训练和微调的输入/输出协议遵循BERT[2]。与基于Transformer的模型不同，我们不使用位置编码。在gMLP块的微调过程中，我们发现无需屏蔽&lt;pad&gt;标记，因为模型可以快速学会忽略它们。对于剖析和案例研究，所有模型都使用批量大小2048，在RealNews-like的C4子集上进行了125K步的训练。对于主要结果，模型使用批量大小256，在完整的英文C4数据集上进行了100万步的训练。详细信息请参见附录A.2。</p><p>我们的初步MLM实验显示，gMLP始终学习到类似Toeplitz矩阵的空间权重（附录C）。这意味着gMLP能够从数据中学习到平移不变性的概念，这个属性在MLM任务中是自然隐含的，因为输入序列的任何偏移都不会影响插槽填充的结果。在这种情况下，学得的fW,b(·)的作用类似于一维卷积，其核大小等于整个序列长度（与具有通道特定滤波器的深度卷积不同，在这里相同的W在通道间是共享的）。在接下来的MLM实验中，我们将W限制为Toeplitz矩阵，以避免冗余的模型参数化（因为在学习后，W无论如何都会变成类似Toeplitz的形式）。请注意，这个约束在实践中对模型质量没有影响。</p><h3 id="消融实验-gmlp中门控对bert预培训的重要性">4.1 消融实验：gMLP中门控对BERT预培训的重要性</h3><p>在下面的表3中，我们建立了我们消融实验的基线。包括：</p><ol type="1"><li>使用Transformer架构和可学习的绝对位置编码的BERT。</li><li>使用Transformer架构和T5风格的可学习相对位置偏置的BERT[5]。我们发现这种偏置既与层次有关，又与头部有关，可以得到最佳结果。</li><li>与上述相同，但我们移除了softmax内部所有依赖于内容的项，只保留了相对位置偏置。这个基线是Transformer的一个直接变体，没有自注意力，也可以看作是一个随机合成器[40]。</li><li>MLP-Mixer[20]，它用两层空间MLP替代了Transformer中的多头自注意力模块。该模型是为图像分类而开发的，这里我们使用与BERT和gMLP相同的训练设置来研究它在MLM任务中的表现。</li></ol><p>我们在表3中将这些基线与几个类似规模的gMLP版本进行了比较。请注意，乘法、分割（最后一行）是我们在方法部分中描述的空间门控单元（SpatialGatingUnit），并在本文的其余部分中使用。首先，SGU在困惑度方面优于其他变体。令人惊讶的是，带有SGU的gMLP也实现了与Transformer相当的困惑度。请注意，最强基线（困惑度=4.26）与我们的结果（困惑度=4.35）之间的差异相对于模型规模变化时的困惑度变化来说是微不足道的（请参见下一部分的表4）。gMLP学习到的空间投影权重在图4中进行了可视化。</p><p>表 3：Transformer 基线模型和四个版本 gMLPs 的 MLM 验证困惑度。<spanclass="math inline">\(f\)</span>指式（2）中输入归一化后的空间线性投影。MLP-Mixer基线模型有<spanclass="math inline">\(L=24\)</span>层，<spanclass="math inline">\(d_{model}=768\)</span>，<spanclass="math inline">\(d_{spatial}=384\)</span>，<spanclass="math inline">\(d_{ffn}=3072\)</span>。每个gMLP模型有L=36层，<spanclass="math inline">\(d_{model}=512\)</span>，<spanclass="math inline">\(d_{ffn}=3072\)</span>。Mixer和gMLP不使用位置编码。</p><p><img src="https://pic.imgdb.cn/item/662caa340ea9cb140363c0ad.png" alt="biao-3" style="zoom: 67%;" /></p><p>图4：在MLM任务中学习的gMLP空间过滤器的可视化。对于模型中的每一层，我们绘制了W中与序列中间标记相关的行。每个子图的X轴长度为128，等于序列中的标记数。学习到的滤波器看起来很平滑，并且有几种类型：前向滤波器（例如，第2行中的第1个）、后向滤波器（例如，第2行中的第5个）和双向滤波器（例如，最后一行中的倒数第2个）。</p><figure><img src="https://pic.imgdb.cn/item/662caae20ea9cb140365485a.png"alt="tu-4" /><figcaption aria-hidden="true">tu-4</figcaption></figure><h3 id="案例研究gmlp在模型规模增大时的行为">4.2案例研究：gMLP在模型规模增大时的行为</h3><p>在表4中，我们研究了BERT中Transformer和gMLP的规模性能，随着模型容量的增长。具体来说，我们通过{0.5，1，2，4}×的因子来扩展这些模型的深度，并报告它们在验证集上的预训练MLM困惑度以及在GLUE[41]的两个任务的微调结果。注意，每个独立的Transformer层实际上是两个连续的块：一个用于自注意力，一个用于FFN。在下表中，我们使用12+ 12的表示方法来表示Transformer基线中的12个自注意力块和12个FFN块。</p><p>表 4：模型容量增加时的预训练和开发集微调结果。我们使用表 3中表现最好的 Transformers 中使用了相对位置编码方案。</p><figure><img src="https://pic.imgdb.cn/item/662caa340ea9cb140363c0e8.png"alt="biao-4" /><figcaption aria-hidden="true">biao-4</figcaption></figure><p>上述结果表明，足够深的gMLP能够与相同容量的Transformer相媲美甚至超越其困惑度。此外，两种体系结构的困惑度和参数之间的关系大致遵循幂律（图5左侧）。这意味着最初观察到的基于Transformer的语言模型的经验缩放规律可能在不同的模型家族中广泛适用。</p><figure><img src="https://pic.imgdb.cn/item/662caae20ea9cb140365488c.png"alt="tu-5" /><figcaption aria-hidden="true">tu-5</figcaption></figure><p>图5：展示了在困惑度和微调准确率方面的缩放特性。图表显示，在预训练中，gMLP和Transformer在优化困惑度方面同样出色。在微调中，尽管存在任务特定的差异，但两种模型家族表现出相当的可扩展性。</p><p>根据表4，还可以观察到一个有趣的现象，不同模型家族在微调方面的预训练困惑度并不相等。虽然gMLP在SST-2任务上表现优于Transformer，但在MNLI任务上表现较差。这些结果表明，NLP任务的微调性能不仅取决于困惑度，还取决于架构中的归纳偏差。图5显示，尽管预训练和微调之间存在架构特定的差异，gMLP和Transformer在微调任务上的可扩展性（斜率）是可比较的。这意味着可以通过增加模型容量来弥补差距。换句话说，这些结果表明，相对于下游指标，模型的可扩展性与是否存在自注意力是独立的。</p><h3id="消融研究bert微调中微小注意力的作用">4.3消融研究：BERT微调中微小注意力的作用</h3><p>到目前为止，我们发现自注意力不是实现强大的MLM困惑度或可扩展性所必需的组成部分。同时，我们还发现在NLP微调任务中，gMLP的迁移效果不如Transformer（见表4）。我们特别注意到我们的MLP-like模型在SST-2任务上具有优势，但在MNLI任务上表现较差——前者是单句子任务，而后者涉及句子对（前提和假设）[43]。我们怀疑在微调过程中，自注意力的作用与跨句子对齐有关。为了分离出自注意力的影响，我们在gMLP的门控函数上添加了一个微小的自注意力块的混合模型（图6）。由于gMLP本身已经能够捕捉空间关系，我们假设这个额外的自注意力模块不必太重，而它的存在与其容量相比更重要。在我们的实验中，典型的微小注意力模块只有一个头，大小为64，远小于Transformer中典型的多头自注意力模块，后者有12个头和总大小为768。以下，我们将这种混合模型，即带有微小自注意力的gMLP，称为aMLP（“a”代表attention）。</p><figure><img src="https://pic.imgdb.cn/item/662cab4c0ea9cb1403662314.png"alt="tu-6" /><figcaption aria-hidden="true">tu-6</figcaption></figure><p>图 6：带有微小自我注意模块的混合空间门控单元。我们使用 gMLP模块的归一化输入（输入归一化后、通道扩展前的端点）作为微小自注意力的输入。对于SGU，由于通道分割，我们使用$ d_{out} = d_{ffn}/2$。</p><p>在图 7 中，我们通过 MLM模型的预训练困惑度和微调指标之间的校准图，研究了这些模型的可移植性。评估的模型包括BERTbase、gMLP 及其混合版本 aMLP（64-d 单头自注意）（图6）。数据点是通过改变模型深度{0.5, 1, 2}×或数据{1, 2, 4,8}×收集的。可以看出，无论是否存在 自注意力，gMLPs 在 SST-2上的传输效果都优于 Transformers。在附录 D 中，我们将 aMLP中的微小自我注意模块与 MNLI示例进行了可视化对比，显示它们主要负责句对之间的对齐。</p><figure><img src="https://pic.imgdb.cn/item/662cab4c0ea9cb1403662351.png"alt="tu-7" /><figcaption aria-hidden="true">tu-7</figcaption></figure><p>图 7：从 MLM 预训练perpexity 到 GLUE 上微调精度的可转移性。aMLP 是指gMLP，如图 6 所示，增强了 64 个单头自我注意。相比之下，BERT基线中的每个自我注意模块包含 12 个头，总大小为 768。</p><p>在图 8 中，我们将这三种模型的缩放特性汇总在一起，显示 aMLP（gMLP +微小注意力）在两项微调任务中的表现始终优于 Transformer。</p><figure><img src="https://pic.imgdb.cn/item/662cab4c0ea9cb1403662394.png"alt="tu-8" /><figcaption aria-hidden="true">tu-8</figcaption></figure><p>图 8：比较Transformer、gMLPs 和 aMLPs的缩放特性（64-d，单头关注）。结果使用第 4.2 节中的相同设置得出。</p><h3 id="bert设置下的mlm的主要结果">4.4 BERT设置下的MLM的主要结果</h3><p>下面我们展示了在完整的BERT设置下的预训练和微调结果。与消融和案例研究不同，这里我们使用完整的英文C4数据集，并采用常见的MLM设置，批大小为256，最大长度为512，训练步数为1M。为了公平比较，我们调整了gMLPs的深度和宽度，以确保与Transformer基线具有可比的模型容量。模型的规格见表5，超参数详见附录A.2。对于微调，我们报告了GLUE[41]中SST-2和MNLI的开发集性能，每个结果条目是通过对五次独立运行结果取中值得到的。此外，我们还报告了在SQuAD[44, 45]上的微调结果，以测试模型在推理较长上下文方面的能力。</p><p>结果如表6所示。与我们在4.1节和4.2节中的发现一致，gMLPs在困惑度方面与Transformers具有竞争力，尤其是在较大规模的设置中。关于微调结果，有几点观察结果：</p><p><strong>首先</strong>，在 gMLP 性能低于 Transformers的微调任务上，随着模型容量的增加，性能差距趋于缩小。例如，虽然 gMLP 在SQuAD-v2.0 基准规模上的表现差了 <spanclass="math inline">\(8.5\%\)</span>，但在更大的规模上，相对于基准的性能差距降至<span class="math inline">\(2.7\%\)</span>。值得注意的是，我们的gMLPlarge 在 SQuAD-v1.1 上实现了 <spanclass="math inline">\(89.5\%\)</span> 的F1，而没有任何自我关注或动态空间参数化[28]，远高于 Devlin 等人[2]报告的<span class="math inline">\(BERT_{base}\)</span> 的 <spanclass="math inline">\(88.5\%\)</span>，与 BERTlarge 的原始结果仅相差<span class="math inline">\(1.4\%\)</span>。我们还通过进一步扩展 gMLP增加了一个数据点。由此产生的模型 gMLPxlarge 在 SQuAD-v2.0（一个涉及问题-答案对的困难任务）上的表现优于 <spanclass="math inline">\(BERT_{large}\)</span>，而没有使用任何自我关注。虽然由于模型大小不同，这种比较并不公平，但它证明了在具有挑战性的NLP 任务中，类 MLP 模型可以与 Transformers 竞争。</p><p><strong>此外</strong>，我们展示了通过融合大小为64或128的微小单头自注意力，gMLPs能够优于具有类似容量的Transformers，有时优势显著。例如，我们的混合模型aMLPlarge在SQuAD-v2.0上的F1分数比Transformers高出4.4%。这些结果表明，Transformers中的多头自注意力的容量很大程度上是多余的，而gMLPs中的空间门控单元可以捕捉到大多数其功能。这些结果还表明，gMLPs的空间门控单元和微小的自注意力的归纳偏差是互补的。尽管随着计算量的增加，体系结构的归纳偏差的好处可能会消失，但微小的自注意力确实提高了gMLPs在我们研究中的实际价值。</p><p>表 5：完整 BERT 设置中的模型规格</p><figure><img src="https://pic.imgdb.cn/item/662caa340ea9cb140363c119.png"alt="biao-5" /><figcaption aria-hidden="true">biao-5</figcaption></figure><p>表 6：预训练困惑度和微调的开发集结果。“ours”表示使用我们的设置训练的模型。我们报告 SST-2 和 MNLI的准确度，以及 SQuAD v1.1/2.0 的 F1 分数。</p><figure><img src="https://pic.imgdb.cn/item/662caa350ea9cb140363c15c.png"alt="biao-6" /><figcaption aria-hidden="true">biao-6</figcaption></figure><h2 id="五-结论">五、 结论</h2><p>自从Vaswani等人的开创性工作[1]以来，Transformers已经广泛应用于NLP和计算机视觉领域。这种应用使得在NLP领域取得了许多令人印象深刻的结果。然而，到目前为止，仍不清楚是什么赋予了Transformers如此成功的力量：是Transformers的前馈特性，还是Transformers中的多头自注意力层？</p><p>我们的工作提出了一种更简单的替代方案来取代Transformers中的多头自注意力层。我们展示了gMLPs，一种带有门控机制的简单MLP变体，可以在BERT的预训练困惑度和ViT的准确性方面与Transformers竞争。在数据和计算量增加的情况下，gMLPs的可扩展性也与Transformers相当。在BERT的微调任务中，我们发现gMLPs在一些具有挑战性的任务（如SQuAD）中可以在没有自注意力的情况下取得令人满意的结果，并且在某些情况下明显优于Transformers。我们还发现，在需要跨句子对齐的下游任务中，Transformer中的多头自注意力的归纳偏差非常有用。然而，在这些情况下，通过使gMLP变得更大可以缩小与Transformers之间的差距。从更实际的角度来看，将一个小的单头自注意力融合到gMLP中可以实现更好的架构，而无需增加模型的大小。</p>]]></content>
    
    
    <categories>
      
      <category>论文翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>论文阅读</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《刻意练习：如何从新手到大师》-读书笔记-1</title>
    <link href="/2024/04/26/4-26blog/"/>
    <url>/2024/04/26/4-26blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>善于利用零星时间的人，才会做出更大的成绩来。——华罗庚</p></blockquote><span id="more"></span><h1 id="推荐序">推荐序</h1><p>在我们的认知里，好像有这么一句话：</p><blockquote><p>只要练习1万小时，就有了成为领域内领先者的希望，无论天赋、无论出身。</p></blockquote><p>然而真相是：</p><blockquote><p>从来不存在1万小时定律，它仅仅是畅销书作家对心理科学研究的一次不太严谨的演绎而已。</p></blockquote><p>1万小时定律究竟有哪些问题呢？</p><blockquote><p><strong>首先</strong>，不同专业领域的技能习得时间与练习时间并不存在一个1万小时的最低阈值。</p><p><strong>其次</strong>，成功与练习时间并不完全成正比，天赋虽然在其中不起决定性作用，却也会是一大影响因子。</p><p><strong>再次</strong>，练习的成果并不与时间呈正相关，这一点，也取决于练习方法。</p></blockquote><p>艾利克森就在书中举到很多例子，我们身边也不乏一些看似努力、其实没有成就的人。</p><h2 id="刻意练习的本质">刻意练习的本质</h2><blockquote><p><strong>长时记忆正是区分卓越者与一般人的一个重要能力，它才是刻意练习的指向与本质。</strong></p></blockquote><p>怎么才能锻炼自己的长时记忆？</p><blockquote><p><strong>刻意练习的任务难度要适中，能收到反馈，有足够的次数重复练习，学习者能够纠正自己的错误。</strong></p></blockquote><p>长时记忆的培养要点主要有以下几个。</p><blockquote><p>赋予意义，精细编码;</p><p>提取结构或模式;</p><p>加快速度、增加连接;</p></blockquote><h2 id="隐性知识">隐性知识</h2><blockquote><p>目前对刻意练习最大的批评是，艾利克森关于刻意练习的证据多是来自“认知复杂性”较低的活动，如象棋、钢琴、篮球、出租车驾驶、拼写，但是，对于“认知复杂性”较高的活动，如销售、管理等作用有限。</p></blockquote><p>怎样通过刻意练习成为一名卓越销售或卓越CEO，从哪里练起？<strong>怎么练？</strong></p><blockquote><p><strong>认知复杂性高与认知复杂性低的学习活动的差异在很大程度上表现为隐性知识的多少与比重。</strong><u>隐性知识需要在情境中去寻。</u></p></blockquote><p><strong>认知复杂度(cognitivecomplexity)是指你建构“客观”世界的能力。更善于同时使用互补与互不相容的概念来理解客观世界</strong></p><blockquote><p>西蒙，他认为人的“有限理性”体现在学习中就是“情境理性”——在哪里用，就在哪里学。</p></blockquote><p><strong>人的学习受到情境的制约或促进。你要学习的东西将实际应用在什么情境中，那么你就应该在什么样的情境中学习这些东西。</strong></p><p><strong>学习科学大量研究表明，成人的最佳学习方式并非独自练习，而是在情境中学习。</strong></p><blockquote><p>学习者最开始时围绕重要成员转，做一些外围的工作，随着技能增长，进入学习共同体圈子的核心，逐步做更重要的工作，最终成为专家</p></blockquote><p>这就是学习科学日益主流的观念：从“情境学习”出发，当一名“认知学徒”，它的要点有以下几个。</p><blockquote><p>找到学习共同体：因为大量知识存在于学习共同体的实践中，不是在书本中，所以有效的学习不是关门苦练，而是找到属于自己的学习小团体。如程序员在类似于GitHub这样的网站练习编程。</p><p>隐性知识显性化：隐性知识是使人们有能力利用概念、事实以及程序来解决现实问题的知识。一般也被称为策略知识。</p><p>模仿榜样：榜样可以是现实生活中的导师，也可以是网上的导师。</p><p>培养多样性：在多种情境中实践，以此强调学习广阔的应用范围。例如，裁缝出师并不是已经练习了1万小时，而是能够缝制出足够好的衣服。</p></blockquote><h1 id="第一章-有目的的练习">第一章 有目的的练习</h1><p><strong>他们练习，大量地练习</strong></p><blockquote><p>在20世纪下半叶，我们看到的是，不同行业或领域的人们投入训练的时长在稳定地增长，同时，训练方法也日益高级。</p></blockquote><p><strong>最有效的练习形式</strong></p><blockquote><p>在任何行业或领域之中，最有效的和最强大的那类练习，都通过充分利用人类的身体与大脑的适应能力，来逐步地塑造和提升他们的技能，以做到一些过去不可能的事情</p></blockquote><p><strong>学习新技能的一般方法</strong></p><blockquote><p>为了列举一个特定的例子，让我们假设你在学习打网球。你一定在电视上看过网球比赛，看起来很有趣，或者说，你的一些朋友喜欢打网球，你也想加入他们的行列。因此，你买回了一些网球装备，包括球鞋、防汗带、球拍以及球，等等。现在，你决心开始学习，但你不知道打网球的第一件事到底是什么，你甚至还不知道怎么握拍，因此，你得花钱去上一些课，听网球教练进行讲解，或者请某位朋友告诉你一些基本知识。你可能还会花一些时间去练习发球，一遍一遍地练习朝墙上击球，直到你非常确定你可以对着墙来“打比赛”了。在那以后，你再回头找你的教练或朋友，请他们再教你一次，然后你再花更多时间训练，之后再上课、再训练，过了一段时间，你觉得自己可以和别人一起打了。你依然不是很优秀，但你的朋友有耐心，每个人都在帮你提高和进步。你不断地一个人练习，并且经常吸取一些成功的经验，随着时间的推移，你犯那些真正让你尴尬的错误的可能性越来越小了，比如击不中球，或者在双打时直接把球打到队友的后背上，等等。</p><p>你对每一次击球都越来越熟练，甚至还可以背后接球了，有时候，当你面对对手凶狠的接球时，能像职业球员那样漂亮地把球回过去（或者，你对自己说，你感觉就像是职业球员）。你已经达到了一种舒服的境界，可以外出和别人打上几盘，并且即使是比赛，也感到很有趣。你非常清楚自己在做什么，每一次击球，都变成了自然而然的动作。打球的时候，你不必想太多了。所以，随着每个周末都和朋友打球，你开始喜欢比赛和训练了。你变成了一位网球运动员。那也就是说，你已经在传统意义上“学会了”打网球，你的目标就是练到这样的水平：在球场上，你的所有动作都是自动做出的，你的表现也被人们所接受，不需要太多的思考，如此一来，你可以真正在球场上放松，享受比赛。</p><p>到这个时候，即使你对自己打球的水平并不是彻底满意，但你的进步是实实在在的。你已经掌握了容易的技能。</p><p>但你很快便会发现，你依然有一些弱点，不论你多么经常地和朋友打球，这些弱点总是暴露出来。比如，也许每次用反手来接那种直奔你胸前、稍稍带点旋转的球时，你总是接不到。你知道这个弱点，而对手也注意到了这一点，每次都有意打出这种球，逼你失误。对此，你感到挫败不已。不管怎样，由于这并不会经常发生，而且你永远不知道对手什么时候打出这种球来，因此，你没有机会继续去改进，每次面对这种球，你总是以几乎一模一样的方式漏接这种球。</p></blockquote><p>我们学习的一般顺序：</p><ul><li><p>了解我们想要做什么，从各种途径学习指导，然后开始练习，直到沃恩可以达到可接受的水平，接下来我们这种技能变成自动、自然。</p></li><li><p><strong>一旦你已经达到了这种令你满意的技能水平，而且能做到自然而然地表现出你的水平，无论是开车、打网球还是烘焙饼干，你就已经不再进步了</strong>。</p></li><li><p><u>人们通常错误地理解这种现象，因为他们自以为，继续开车、打网球或烘焙饼干，就是一种形式的练习，如果不停地做下去，自己一定能够更擅长，也许进步较为缓慢，但最终还是会更出色。</u></p></li><li><blockquote><p>一旦某个人的表现达到了“可接受”的水平，并且可以做到自动化，那么，再多“练习”几年，也不会有什么进步。</p></blockquote></li><li><p><u>如果没有刻意地去提高，这些自动化的能力会缓慢地退化。</u></p></li></ul><p><strong>有目的的练习VS天真的练习</strong></p><p>我们的最终目标便是刻意练习。<strong>所谓“天真的练习”，基本上只是反复地做某件事情，并指望只靠那种反复，就能提高表现和水平</strong></p><h2 id="阅读心得">阅读心得</h2><p>上面的内容其实大部分都不是我写的，属于是我摘抄，并没有做内容的重组输出。于是我额外写了一个阅读心得，进行我的知识输出。</p><p>在阅读前，我打开了番茄时钟，他会有每次专注的一句鼓励的话，我把它摘抄：</p><blockquote><p>阅读就是抛弃自己的一切意图与偏见，随时准备接受突如其来且不知来自何方的声音。</p></blockquote><p>这些天自己一直在看书，看各种书，其实除了考研的书，其他的书倒是没少看。阅读的意义，可能是为了让我更好的见识世界吧。</p><p>回到这本书，我才看了一章，于是只能浅浅的讲一下我的见识。书里讲了很多例子，比如他招募了一个志愿者，通过对它的不同方式的训练，一是死记硬背，通过他自身的背诵，但情况是，他迟迟没有进步，而且对他——这个志愿者，产生了很大的打击影响，一度怀疑自己。另一个方法，是通过阶段的方法：一开始先背正常的数量，每次加一，但是如果错误了，就减二。比如一开始能记住7个，下次8个，在下次9个、、、如果错了，就减2，从七个开始。通过这样的方法，虽然很磨人，但是其实还是有所进步，通过每个星期的练习，这名志愿者从一开始的只能短时背住7个数字，到后面能背81个！这是很恐怖的进步了，当作者总结规律，发现，有目的的、适度的练习，是我们前进的最好的节奏。</p><p>这是我通过缓慢阅读的心得，阅读很快乐，考研实在是压力很大，这两个字和读书一样，压力十足。我喜欢学习七七八八的东西，但是不喜欢枯燥的读书，但是今天通过看了阅读，收获了一点心得：找到学习体，成年人学习——不得不承认我也是大人了——要从情境中去学习。我在目前的这个环境下，没能找到属于自己的学习体，但是如果不存在，那能不能自己创建一个呢？每天通过自己问自己奇奇怪怪的问题，让自己不至于变成老爸老妈的老头脑了。</p>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
      <category>《刻意练习：如何从新手到大师》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机视觉-图像视觉实验-实验3</title>
    <link href="/2024/04/25/4-25blog/"/>
    <url>/2024/04/25/4-25blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如果是玫瑰，它总会开花的。——歌德</p></blockquote><p><span id="more"></span></p><h1 id="实验3肺部图像分割">实验3：肺部图像分割</h1><h2 id="一实验目的">一、实验目的</h2><p>用OpenCV编写一个基于分水岭算法的图像分割程序能对肺部医学图像进行分割，辅助医生进行病情诊断，强化和巩固学生对图像分割知识的掌握和灵活应用。</p><h2 id="二实验要求">二、实验要求</h2><p>1、用OpenCV编写一个基于分水岭算法的图像分割程序，能对获取的肺部医学图像进行分割；</p><p>2、撰写实验报告，内容包括实验原理、实验过程、关键代码注释、实验结果解释以及实验分析。实验分析部分需要指出<strong>实验结果的优劣原因，并提出进一步提高实验性能的方法或手段。</strong></p><p>3、使用Python版的OpenCV编写代码。</p><p><strong>注意：</strong>每位同学需要<strong>自备实验素材</strong>，撰写报告时保证版面整洁，可适当调整实验报告格式和<strong>实验结果图</strong>。</p><h2 id="三-实验原理">三、 实验原理</h2><p>本实验使用了OpenCV库提供的图像处理和分割方法，包括灰度转换、阈值处理、形态学操作、距离转换、连通组件标记和分水岭算法等，以实现图像分割的目的。下面对每个模块分别进行实验原理说明：</p><p>1、阈值处理：</p><p>原理：阈值处理是图像分割的基本方法之一，将图像的像素值分为前景和背景两部分。通过选择一个合适的阈值，所有高于这个阈值的像素点被赋予一个值（例如255，白色），而低于这个阈值的像素点被赋予另一个值（例如0，黑色）。Otsu的方法可以自动地选择一个阈值，它通过最大化前景和背景像素值的类间方差来确定最佳阈值。</p><p>2、形态学操作：</p><p>原理：形态学操作包括<strong>膨胀</strong>和<strong>腐蚀</strong>，主要用于图像的预处理，比如<strong>消除噪声</strong>、<strong>分离</strong>接触在一起的对象等。膨胀操作会增加图像中对象的边界区域，而腐蚀会减小对象边界。开运算是先腐蚀后膨胀的过程，用于去除小对象或分离对象。形态学操作通常使用一个结构元素（也称为核）对图像进行卷积。</p><p>3、距离转换：</p><p>原理：距离转换计算图像中每个非零像素到最近零像素的距离。在二值图像中，这可用于确定对象之间的边界。常见的距离度量包括欧氏距离、曼哈顿距离和棋盘距离。结果是一个图像，其中每个像素的值表示到最近背景像素的距离。</p><p>4、连通组件标记：</p><p>原理：连通组件标记算法用于识别并标记二值图像中的各个连通区域，即将图像中相互连接的前景像素点归为相同的组件。图像中每一个连通区域被赋予一个唯一的标签。连通组件标记是很多图像分析任务的基础，如计数对象、对象跟踪等。</p><p>5、分水岭算法：</p><p>原理：分水岭算法是一种数学形态学的图像分割技术，被用来将图像分割为不同区域，这些区域则代表单独的对象。其基本概念来源于地理学的分水岭——山脉分水岭可以将水分流到不同的方向。在图像分割中，该算法通常是在图像的梯度图上应用，梯度图显示了像素亮度变化的强烈程度。分水岭算法找到梯度图中的局部最小值，并将图像中的像素点划分到这些最小值的区域中，类似于山谷收集流下来的水。</p><p><strong>参考代码</strong>：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">&#x27;1.jpg&#x27;</span>)<br>gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)               <span class="hljs-comment">#转换为灰度图</span><br>ret,imgthresh = cv2.threshold(gray,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<br>            cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)  <span class="hljs-comment">#Otsu阈值处理,转化为二值图</span><br>kernel = np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),np.uint8)                                <span class="hljs-comment">#定义形态变换卷积核</span><br>imgopen = cv2.morphologyEx(imgthresh,cv2.MORPH_OPEN, kernel,iterations=<span class="hljs-number">2</span>)<br>                        <span class="hljs-comment">#形态变换：开运算                 </span><br>imgbg = cv2.dilate(imgopen,kernel,iterations=<span class="hljs-number">3</span>)           <span class="hljs-comment">#膨胀操作，确定背景</span><br>imgdist = cv2.distanceTransform(imgopen,cv2.DIST_L2,<span class="hljs-number">0</span>)  <span class="hljs-comment">#距离转换，用去确定前景</span><br>ret,imgfg = cv2.threshold(imgdist, <span class="hljs-number">0.7</span>*imgdist.<span class="hljs-built_in">max</span>(),<span class="hljs-number">255</span>,<span class="hljs-number">2</span>)  <span class="hljs-comment">#对距离转换结果进行阈值处理</span><br>imgfg = np.uint8(imgfg)                               <span class="hljs-comment">#转换为整数，获得前景</span><br>ret,markers = cv2.connectedComponents(imgfg)            <span class="hljs-comment">#标记阈值处理结果</span><br>unknown = cv2.subtract(imgbg,imgfg)                    <span class="hljs-comment">#确定位置未知区域</span><br>markers = markers + <span class="hljs-number">1</span>                                 <span class="hljs-comment">#加1使背景不为0</span><br>markers[unknown == <span class="hljs-number">255</span>] = <span class="hljs-number">0</span>                            <span class="hljs-comment">#将未知区域设置为0</span><br>imgwater = cv2.watershed(img,markers)                  <span class="hljs-comment">#执行分水岭算法分割图像</span><br>plt.imshow(imgwater)                                 <span class="hljs-comment">#以灰度图像格式显示匹配结果</span><br>plt.title(<span class="hljs-string">&#x27;watershed&#x27;</span>)<br>plt.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>plt.show()<br>img[imgwater == -<span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>]                         <span class="hljs-comment">#将原图中被标记点设置为绿色</span><br><br>cv2.imshow(<span class="hljs-string">&#x27;watershed&#x27;</span>,img)                            <span class="hljs-comment">#显示分割结果</span><br>cv2.waitKey(<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure></p><h2 id="四实验结果">四、实验结果</h2><p><strong>参考代码实验结果</strong>：经过处理的图像会在原有图像的基础上，以绿色线条清晰地突出显示出图像中不同对象的边界。</p><p><strong>原图</strong>：</p><figure><img src="https://pic.imgdb.cn/item/6629f28b0ea9cb1403f0bdcf.jpg"alt="原图" /><figcaption aria-hidden="true">原图</figcaption></figure><p><strong>效果图</strong>：</p><figure><img src="https://pic.imgdb.cn/item/6629f28c0ea9cb1403f0be4e.png"alt="效果图" /><figcaption aria-hidden="true">效果图</figcaption></figure><p><strong>实验优缺点：</strong></p><p><strong>优点：</strong></p><ol type="1"><li><strong>使用了Otsu阈值处理</strong>：自动根据图像的灰度分布选择最佳阈值，适用于图像的二值化，有效地去除了背景噪声。</li><li><strong>形态学操作</strong>：通过开运算和膨胀操作改善了图像的结构，有助于更清晰地分离前景和背景。</li><li><strong>利用距离变换和分水岭算法实现图像分割</strong>：先通过距离变换确定对象的前景区域，再通过分水岭算法准确地分割出对象，适用于对象和背景紧密相连的情况。</li></ol><p><strong>缺点</strong>：</p><ol type="1"><li><strong>错误处理不足</strong>：没有检查<code>cv2.imread</code>是否成功读取图像，如果图像路径不正确，后续的所有操作都会失败。</li><li><strong>资源释放</strong>：在使用<code>cv2.imshow</code>后，应调用<code>cv2.destroyAllWindows()</code>来确保窗口正确关闭，释放资源。</li></ol><p><strong>改进建议</strong>：</p><ol type="1"><li><strong>增加错误处理</strong>：在操作图像前，检查图像是否成功加载，例如通过<code>if img is None: print('Image not found');exit()</code>。</li><li><strong>资源释放</strong>：在cv2.waitKey(0)后添加cv2.destroyAllWindows()以确保所有OpenCV窗口都被正确关闭。</li><li><strong>代码清晰性</strong>：将代码段按功能分块，每个块前用注释简要说明该部分代码的目的，提高代码的可读性。</li></ol><p><strong>改进代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">image_segmentation</span>(<span class="hljs-params">image_path, threshold=<span class="hljs-number">0.7</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    对图像进行分割</span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        image_path (str): 输入图像的路径</span><br><span class="hljs-string">        threshold (float): 阈值百分比，默认为0.7</span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        np.ndarray: 分割后的图像</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 读取图像</span><br>        img = cv2.imread(image_path)<br>        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>        <span class="hljs-comment"># 阈值处理</span><br>        ret, imgthresh = cv2.threshold(gray, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)<br>        <span class="hljs-comment"># 形态变换</span><br>        kernel = np.ones((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), np.uint8)<br>        imgopen = cv2.morphologyEx(imgthresh, cv2.MORPH_OPEN, kernel, iterations=<span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 背景和前景处理</span><br>        imgbg = cv2.dilate(imgopen, kernel, iterations=<span class="hljs-number">3</span>)<br>        imgdist = cv2.distanceTransform(imgopen, cv2.DIST_L2, <span class="hljs-number">0</span>)<br>        ret, imgfg = cv2.threshold(imgdist, threshold * imgdist.<span class="hljs-built_in">max</span>(), <span class="hljs-number">255</span>, <span class="hljs-number">2</span>)<br>        imgfg = np.uint8(imgfg)<br>        <span class="hljs-comment"># 标记处理</span><br>        ret, markers = cv2.connectedComponents(imgfg)<br>        unknown = cv2.subtract(imgbg, imgfg)<br>        markers = markers + <span class="hljs-number">1</span><br>        markers[unknown == <span class="hljs-number">255</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 分水岭算法分割图像</span><br>        imgwater = cv2.watershed(img, markers)<br>        <span class="hljs-comment"># 标记点设置为绿色</span><br>        img[imgwater == -<span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> img<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Error: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><span class="hljs-comment"># 图像分割示例</span><br>image_path = <span class="hljs-string">&#x27;1.jpg&#x27;</span><br>segmented_image = image_segmentation(image_path)<br><span class="hljs-keyword">if</span> segmented_image <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    cv2.imshow(<span class="hljs-string">&#x27;Segmented Image&#x27;</span>, segmented_image)<br>    cv2.waitKey(<span class="hljs-number">0</span>)<br>    cv2.destroyAllWindows()<br><br></code></pre></td></tr></table></figure><p><strong>改进代码实验效果：</strong></p><figure><img src="https://pic.imgdb.cn/item/6629f28c0ea9cb1403f0bf70.png"alt="改进后" /><figcaption aria-hidden="true">改进后</figcaption></figure><p><strong>其他方法：</strong></p><p><strong>基于边缘检测的方法</strong>是图像处理中的一种基本技术，广泛用于图像分割、特征提取等领域。以下是代码实现。</p><p><strong>基于边缘检测的代码实现</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sobel_edge_detection</span>(<span class="hljs-params">image_path</span>):<br>    <span class="hljs-comment"># 读取图像</span><br>    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)<br>    <br>    <span class="hljs-comment"># 使用Sobel算子进行边缘检测</span><br>    sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, ksize=<span class="hljs-number">5</span>) <span class="hljs-comment"># 对x方向进行操作</span><br>    sobely = cv2.Sobel(img, cv2.CV_64F, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ksize=<span class="hljs-number">5</span>) <span class="hljs-comment"># 对y方向进行操作</span><br>    <br>    <span class="hljs-comment"># 显示原图</span><br>    plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>), plt.imshow(img, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;Original Image&#x27;</span>), plt.xticks([]), plt.yticks([])<br>    <br>    <span class="hljs-comment"># 显示x方向边缘</span><br>    plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>), plt.imshow(sobelx, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;Sobel X&#x27;</span>), plt.xticks([]), plt.yticks([])<br>    <br>    <span class="hljs-comment"># 显示y方向边缘</span><br>    plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>), plt.imshow(sobely, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;Sobel Y&#x27;</span>), plt.xticks([]), plt.yticks([])<br>    <br>    plt.show()<br><br><span class="hljs-comment"># 调用函数</span><br>sobel_edge_detection(<span class="hljs-string">&#x27;&lt;your-image-file-path&gt;&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p><strong>实验效果：</strong></p><figure><img src="https://pic.imgdb.cn/item/6629f28c0ea9cb1403f0bed2.png"alt="实验效果图" /><figcaption aria-hidden="true">实验效果图</figcaption></figure><h2 id="五实验分析">五、实验分析</h2><p><strong>对于参考代码：</strong></p><p>实验结果显示：参考代码能够很好的将图像边界清晰地突出，并用不同颜色显示出图像中不同对象的边界。使用了Otsu阈值处理，自动根据图像的灰度分布选择最佳阈值，适用于图像的二值化，有效地去除了背景噪声。通过开运算和膨胀操作改善了图像的结构，有助于更清晰地分离前景和背景。利用距离变换和分水岭算法实现图像分割，先通过距离变换确定对象的前景区域，再通过分水岭算法准确地分割出对象，适用于对象和背景紧密相连的情况。</p><p><strong>对于改进代码</strong>：</p><p>实验结果显示：改进代码会在操作图像前，检查图像是否成功加载；在<code>cv2.waitKey(0)</code>后添加<code>cv2.destroyAllWindows()</code>以确保所有OpenCV窗口都被正确关闭。</p><p><strong>基于边缘检测的方法：</strong></p><p>实验结果显示：通过使用使用Sobel算子进行边缘检测，通过对图像X、Y分别进行边缘检测操作，该方法简单、快捷，能够很好的将图像的边缘区域很好的提取出来。一些小部分的边缘也能很好的体现出来，这是基于分水岭代码所没有的。</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像</tag>
      
      <tag>计算机视觉</tag>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Learn More, Study Less!》-读书笔记-4</title>
    <link href="/2024/04/24/4-24blog/"/>
    <url>/2024/04/24/4-24blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>人需要真理，就像瞎子需要明快的引路人一样。——高尔基</p></blockquote><span id="more"></span><h1 id="the-debug-phase调试阶段">The Debug Phase——调试阶段</h1><p>整体学习包含五个步骤：</p><p>1、获取 2、理解 3、探索 4、调试 5、应用</p><p>在昨天，我们学习了整体学习的3个步骤：1、获取知识2、理解知识3、探索知识</p><p>其中每一个都有其小小的注意点：</p><ul><li><p>获取知识要求我们获取知识的<strong>简单性</strong>、<strong>价值性</strong>、<strong>速度性</strong>；</p></li><li><p>理解知识要求我们能明白知识的<strong>表面</strong>含义，每个含义代表什么要搞清楚；</p></li><li><p>探索知识要求我们从<strong>深度</strong>、<strong>广度</strong>、<strong>宽度</strong>去理解探索知识，让知识彻底连接起来构成网络。提升我们的理解。</p></li></ul><p>当然我们这三个步骤中还有最重要的是调试，也叫<strong>测试</strong>。测试可以让我们跟踪自己的缺点，从而进行改进。</p><ul><li>测试具有实时性。你在每个阶段都应该对自己进行询问：<ol type="1"><li>获取阶段--我以前是否听过/听过这个想法💡？</li><li>理解阶段--我是否（在表面上）理解了这个想法的含义？</li><li>探索阶段--我是否理解这个想法的来源，他和什么相关，以及什么其他的领域可以和他联系起来？</li><li>调试阶段--我是不是漏掉了什么，或者和别的想法进行了错误的关联？</li><li>应用阶段--我是否可以在生活当中使用这个想法？</li></ol></li><li>测试具有目的性。通过测试来确定自己对于某个想法的理解程度或掌握程度，看自己处在哪一个阶段。</li><li>测试的结果具有判断性。如果我们在哪一个阶段得到的答案是否，那我们能说，你在这个阶段是不合格的，你目前的进度只是比前一个阶段好。</li><li>测试具有自发性。测试的问题并不难，但是要求我们具有很高的自我意识。</li></ul><p>这五个层次并不是线性的，不是一级一级的关系，而是同级的。说人话，这五个步骤有可能你对于应用阶段你很擅长，但是完全不是很能理解这个技能怎么来的，为什么这么做？也是有可能的，所以我们要把他们看成是不断循环的，才能更好地理解他们。</p><h1id="pinpointing-your-weaknesses-in-the-sequence指出自己的弱点">PinpointingYour Weaknesses in the Sequence——指出自己的弱点</h1><p>通过自我测试，找到自己长期存在的弱点。比如你在获取和理解方面很擅长，但是在应用方面可能很差，这就要求我们对症下药，改进我么的缺点。</p><p>怎么找到自己的弱点，作者没有给出，也没有具体规则，但是通过总结我们可以发现：</p><h2 id="一对于获取阶段">一、对于获取阶段</h2><p>糟糕的获取往往表现在两种方式之一：</p><p>1）阅读或听讲需要很长时间。2）需要重新阅读教科书/笔记才能获得所有基本信息。</p><p>导致整个的原因可能是：</p><ol type="1"><li>有不好的阅读/学习习惯。</li></ol><p>如果你经常阅读的时候分心，或者需要更长的时间来阅读，或者多次阅读同一材料。</p><ol start="2" type="1"><li>有不好的记笔记习惯。</li></ol><p>这可能是记笔记太多或太少。记笔记太多会阻止你在教授讲话时思考。记笔记太少/质量太差可能会阻止你重新获取第一次没有正确理解的信息。</p><ol start="3" type="1"><li>不理解基本术语或英语</li></ol><p>如果不是以英语为母语（或者正在学习的任何语言），我们将会在解释中犯错误。如果缺乏正在学习领域的基本术语，就可能会感到困惑。</p><p>吸收不良的解决办法是改善你的学习、阅读和笔记习惯。吸收不是学习最重要的阶段，所以如果你做得不完美，我也不会担心。</p><h2 id="二对于理解阶段">二、对于理解阶段</h2><p>理解不良往往表现在：</p><ol type="1"><li>你正在阅读，但不知道作者在说什么。</li><li>你的笔记（非常清晰）对你来说没有任何意义。</li></ol><p>对于笔记，作者建议可以更多地寻找写的好的解释，来帮助自己理解表面含义。比喻和隐喻等方法只有在理解了表面含义的基础上才能更进一步。</p><p>大多数人在记忆想法时遇到的绊脚石是<strong>交叉应用</strong>和<strong>联系</strong>。当你不明白时，放慢速度，要求不同的解释。</p><h2 id="三对于探索阶段">三、对于探索阶段</h2><p>糟糕的探索表现为缺乏灵活性。</p><p>当您理解了一个想法，但无法将其与您所学到的其他东西<strong>联系</strong>起来时，就会出现这种情况。</p><p>如果要你来解决一个变化了数字的公式题目，你可能就不会了。</p><p>在探索阶段，不能将解决问题的能力更广泛地应用在本领域，我们就可以说，你对探索阶段不够擅长。</p><p><strong>比如</strong>：假设约翰尼上了一门基础统计学课程。他理解了公式的基础知识，并记住了教授在解决数学问题时给出的例子。现在，约翰尼在考试中遇到一个问题，要求他用与老师教授的略微不同的方式使用公式。他做不到——问题在于探索。</p><p>然而，如果约翰尼轻松通过了测试，那么他的探索能力可能很强。但是，假设他在<strong>生活中</strong>遇到一个统计问题，他会利用他在课程中学到的原则并应用它们吗？或者这些原则无法从课堂跳到现实生活？如果他做不到这一点，那就是应用问题。</p><h2 id="四对于调试阶段">四、对于调试阶段</h2><p>糟糕的调试表现为连接不准确。</p><p>一是你探索的太少，探索的少，问题就少；问题少了，你需要更改的问题就少；要更改的问题少了，你对问题的理解就越片面。</p><p>连接不准确其实可以说是，你对问题的理解出现偏颇、有歧义。可能在某一时刻，你是对的，但在大部分情况下，你是错的。比如：在一场比赛里，你为你支持的一方欢呼，后面比赛里，你支持的队伍赢了。然后你得出结论：观众的欢呼会使一支运动队获胜。但这一定是对的吗？我仅仅依靠的是一场比赛的实验，并没有更多的去探索，去实践。这个想法，自然是狭义的，不完整的。</p><ul><li><p>如果你没有经常发现自己在问题上出错，那就说明你没有进行足够的调试。</p></li><li><p>如果你总是认为自己是正确的，那么你很可能没有对自己所做的工作进行足够的批判性检查。</p></li></ul><h2 id="五对于应用阶段">五、对于应用阶段</h2><p>当你不能在现实世界中采取行动时，就会产生应用弱点。</p><p>如果你不能在任何地方使用它们，那么拥有出色的理论是毫无用处的。</p><p>有“书本知识”但缺乏常识的人通常是那些在应用中失败的人。解决这一阶段更多的是实践，而不是技术。<strong>走出去，进行受控实验，</strong>对你的想法进行测试。</p><h2 id="识别自己的弱点">识别自己的弱点</h2><p>对于一个企业家来说，你如果能雇一个画画厉害的人来帮你画画，那你自己就不需要去学习画画来，亲自画画。</p><p>但是身为一个学习者，我们不能雇佣别人来帮我们探索或者应用想法，所以我们应该识别自己的弱点，并改善它。</p><p>一开始，学习新的东西需要时间，但是当你掌握的时候，他就会融入到你的自然策略当中。</p>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
      <category>《learn-more-study-less》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Learn More, Study Less!》-读书笔记-3</title>
    <link href="/2024/04/23/4-23blog/"/>
    <url>/2024/04/23/4-23blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>深窥自己的心，而后发觉一切的奇迹在你自己。——培根</p></blockquote><span id="more"></span><h1 id="the-acquire-phase">The Acquire Phase</h1><p>获取阶段</p><p>这个阶段代表信息进入大脑所走的路径。你处理信息的方式，决定你大脑最后能接受到什么样的信息。</p><p>在评估你在这个阶段的表现时，以下是一些需要考虑的因素：</p><ul><li>你需要多长时间才能阅读一页有90%理解度的材料？</li><li>你实际关注了多少讲课内容？</li></ul><p>在获取知识阶段，处理信息的多少、好坏，最终决定了你学习的好坏。在第一步丢失的任何信息都一去不复返了。所以再获取信息的时候，应该关注三个主要目标：</p><ol type="1"><li>简单性-Simplicity</li><li>数量-Volume</li><li>速度-Speed</li></ol><h2 id="acquiring-for-simplicity">Acquiring for Simplicity</h2><p>在我们阅读文本阶段，文本中难免出现冗余的信息，这时候我们可以通过转换文本表述，来进行信息的简化。</p><p>比如：我非常非常非常非常爱吃蛋糕。</p><p>你可以转化为：我爱吃蛋糕。</p><blockquote><p>阅读要求你尽可能地吸收最纯粹的信息。简单意味着你获取的信息具有最低的冗余度。</p></blockquote><p>当学到我们会的东西的时候，就不用费心再去记录那些我们已经会的知识，可以放更多的笔墨在不会的知识上。</p><h2 id="acquiring-for-volume">Acquiring for Volume</h2><blockquote><p>As long as you account for simplicity, your should be trying to getthe most information possible. Reading one sentence from this bookoffers far less understanding than reading every page. The moreinformation you can process, the more you will understand. Someone whoreads a 100 books a year will usually have more knowledge than someonewho reads only 2 or 3.</p><p>只要考虑到简洁性，你就应该尽可能获取最多的信息。阅读本书中的一句话远不如阅读每一页。你能处理的信息越多，你就能理解得越多。一年读100 本书的人通常比只读两三本书的人掌握更多的知识。</p></blockquote><p>读到这里，我的理解是：用小知识来逐步理解大知识。当我们获得的数量越来越多，对于知识的掌握也必然逐步变多！有种“农村包围城市”的思想。</p><h2 id="acquiring-for-speed">Acquiring for Speed</h2><p>在所有条件都相同的情况下，用三十分钟读完一本书比用一个小时读完一本书要好。但速度往往与数量和简洁性背道而驰。一般来说，速度越快，你所能吸收的信息就越少，你在决定获取什么信息时的鉴别力就越差。</p><h1 id="the-understand-phase">The Understand Phase</h1><p>理解阶段</p><p>没有理解，输入就无从谈起。如果你不理解一本书所要表达的表面意思，那么在考试中记住它或在现实生活中应用它的可能性几乎是不存在的。</p><p>整体学习顺序可以分为三个层次，每个层次都增加了对信息的理解程度。<strong>理解阶段</strong>是第一个层次，其次是<strong>探索阶段</strong>，最后是<strong>应用阶段</strong>。每个层次都为你遇到的信息提供了更多的深度。</p><p>在理解阶段，你正在获取信息的<u>表面信息</u>。例如，如果你正在学习一个新的数学公式，你知道公式中符号的基本含义，以及可能使用该公式解决的问题。如果你重复公式足够多次，你甚至可能记住它。死记硬背的学习只是理解阶段的学习。</p><p>仅仅达到这个阶段就表明你已经把信息联系得足够多了，你可以理解上下文了。公式对你来说，不仅仅是随机的曲线和字母了。</p><p>不幸的是，你了解的知识只在表面。你可能无法确定这个公式是如何推导出来的，它与其他公式有什么关系，或者它如何应用于你所学到的知识之外的问题。</p><p>理解阶段，是大多数人停止的地方，而聪明人会超越这个阶段。</p><p>尽管停留在这一阶段存在局限性，但这是最关键的。除非你能获取并理解信息的表面，否则你就没有机会建立深度。</p><p>理解阶段是最基础的阶段，但也是很简单的一个阶段，很多人往往停留在这一阶段或者在这一阶段处理信息太过简单，没有理解信息的表面，也就没办法更进一步。</p><p><strong>Tip：</strong></p><p>如果不能立即理解某些东西，并不意味着你没有全面学习。我的建议是，当你遇到一个棘手的问题时，把它分解成几个部分。具体缩小你不理解的东西，这样你就可以通过进一步阅读来填补空白。</p><h1 id="the-explore-phase">The Explore Phase</h1><p>探索阶段</p><p><strong>探索是整体学习的真正开始。</strong>有了你对信息表层的基本理解，现在你要尝试将信息与其他概念联系起来。在这里，你会开始使用模型来简化和扩展你的构建。你还会拓宽你的理解，不仅了解信息是如何推导出来的，还要了解它与什么相关。</p><p>对自己问问题：</p><ul><li><p>它来自哪里？</p></li><li><p>公式的不同组成部分代表什么？</p></li><li><p>公式的哪些元素可以更改，以及这种变化的结果是什么？</p></li><li><p>在功能或形式上，有哪些其他公式与此相似？</p></li></ul><p>仅仅理解是不够的，因为好奇心会驱使你把它与新的材料联系起来。</p><p>探索想法有三种主要方式：<strong>深度探索</strong>、<strong>横向探索</strong>和<strong>纵向探索</strong>。</p><h3 id="depth-exploration">Depth Exploration</h3><p>信息来自某个地方。一个公式是从哪里来的？一个发现是如何做出的？为什么事情是这样的？</p><p>深度探索要求你创建链接到基础信息。你不仅理解一个公式，而且理解它的证明。你知道为什么证明被开发出来，由谁开发出来的。</p><p>通过深度探索，你的公式在其他链接思想的基础上得到支持</p><p>深度探索的缺点是通常需要额外的研究。有些课程会提供一些深度，但很少达到探索一个想法所需的程度。</p><p><strong>深度探索可能是锁定一个想法的最佳方法，但也是最耗时的。</strong></p><h3 id="lateral-exploration">Lateral Exploration</h3><p><strong>信息不是孤立的。</strong>哪些公式在功能或设计上与这一公式相似？同一时间，同一人或同一领域还发现了哪些其他发现？这一事实周围还有哪些其他事实？</p><p><strong>横向探索要求你围绕信息创建链接。</strong>通常这意味着你采取模型，并在它们之间链接信息。将发生在古希腊的一件事与发生在古中国的另一件事联系起来。</p><p>横向探索比深度探索需要更少的研究，但需要更多的<strong>创造力</strong>。它要求你看到可能最初并不存在的联系。你的教授可能不会向你展示一个公式与另一个公式的所有可能相似之处和比较。</p><h3 id="vertical-exploration">Vertical Exploration</h3><p>信息遵循<strong>模式</strong>，这些模式可以在其他信息中找到。我可以把这个公式比作自然事件，比如水流或开车吗？这个发现与完全不同的历史事件有什么关系？这个想法与完全不同的想法<strong>有什么相似之处</strong>。在什么不同事件里面有什么相同之处。</p><p><strong>垂直探索是最困难的，也是最具创造性的学习方式。</strong>但是，如果使用得当，它可以比深度探索所需的背景研究更快地完成。</p><p><strong>整体学习不需要花哨，只要好奇并提出问题，你就可以探索一个想法。</strong></p><h1 id="总结">总结</h1><p>获得、理解、探索，我们认知的边界就是我们世界的边界。</p><p>学习分为获得信息、理解信息、和探索信息。</p><p>获得信息是学习的第一步，学习的好坏，接受知识的多寡，都取决与这一步，我们对于信息的获得具有主观性，我们应当对所获得的只是有第一步的思考，学会编辑想要学到的信息。</p><p>理解信息是学习的第二步。理解表面只是的意思，方便后续的探索和建立知识框架。理解是最基础的阶段，但也是很简单的一个阶段，很多人往往停留在这一阶段或者在这一阶段处理信息太过简单，没有理解信息的表面，也就没办法更进一步。</p><p>探索阶段是学习的第三步。探索一个问题，应该要好好的思考它的多面性：深度、宽度、垂直方向进行学习。可是这么多东西，你一个一个的都记下来，好像不太现实，所以我们就必须减少我们获得信息的冗余，这和我们在第一步，要求我们获得消息，要简单和快速的要求不谋而合。</p><p>可以说这三步可以是环环相扣，一步可以连着一步。这很累，所以很多人只是停留在第二步，理解知识阶段。又想起《认知觉醒》的一句话：“在自己的拉伸区学习”，不要太难，不要太简单，不要太急，不用太慢。</p><p>这个度很难把握，但是却是最好的学习状态。</p>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
      <category>《learn-more-study-less》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统-频域分析</title>
    <link href="/2024/04/22/4-22blog/"/>
    <url>/2024/04/22/4-22blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>辛勤的蜜蜂永没有时间悲哀。——布莱克</p></blockquote><p><span id="more"></span></p><h1 id="摘要">摘要</h1><p>本文对信号与系统的频域分析进行学习分享以及记录。</p><h1 id="周期信号">周期信号</h1><p>对周期信号做频谱分析，采用的工具是—傅里叶级数（FS）</p><p>频谱的横坐标是<spanclass="math inline">\(\omega_0\)</span>，但它的频谱是离散谱。</p><p>傅里叶级数通俗点解释就是：用很多很多个相同的、已知的函数（比如：<spanclass="math inline">\(e^{t}\)</span>或者<spanclass="math inline">\(\sin(t)\)</span>、<spanclass="math inline">\(\cos(t)\)</span>）的叠加，形成一个周期函数。</p><h2 id="虚指数表示">1.(虚)指数表示</h2><p>傅里叶级数指数表示，公式如下： <span class="math display">\[\tilde{x}\small(t\small) = \sum^{+\infty}_{n=-\infty}C_ne^{n\omega_0t}\text{\quad\quad}(1)\]</span> 上面的式子，解释起来，就是由很多个指数函数<spanclass="math inline">\(e^{n\omega_0 t}\)</span>，乘上一个加权值：<spanclass="math inline">\(C_n\)</span>，然后再叠加在一起，形成的<spanclass="math inline">\(x\small(t\small)\)</span>。</p><p>其中，我们把<spanclass="math inline">\(C_n\)</span>称作<strong>频谱</strong>。 <spanclass="math inline">\(C_n\)</span>是<strong>复数</strong>。 <spanclass="math display">\[C_n = \frac{1}{T_0}\int^{\frac{T}{2}}_{-\frac{T}{2}}\\tilde{x}\small(t\small)\ e^{jn\omega_0t}\text{\quad\quad}(2)\]</span></p><ul><li>上面两个式子总是成对出现；</li><li>傅里叶计数优点：<strong>理论简单</strong>、<strong>简洁</strong>；</li><li>缺点：得到的值是<strong>复数</strong>，实验过程中难以通过测量得到值。（实验仪器只能测实数）</li></ul><h2 id="三角形式">2.三角形式</h2><p>由刚刚我们知道，指数形式有很多优点，但是也有缺点：理论得出的值不好实验表示。</p><p>于是我们必须通过其他的方法来解决这个问题：欧拉公式~秒了！</p><p>回顾一下小学三年级学过的欧拉公式： <span class="math display">\[e^ {ix}= (\cos x+i·\sin x)\text{\quad\quad}(3)\]</span> 如果不会，在自己看<ahref="%5B欧拉公式_百度百科%20(baidu.com)%5D(https://baike.baidu.com/item/欧拉公式/92066)">百度</a>。（链接贴这里了，自己看）</p><p>回到三角形式，我们知道欧拉公式可以展开成三角形式，所以公式（1）就可以变成：<span class="math display">\[\tilde{x}\small(t\small) = \sum^{+\infty}_{n=0}\big[a_n·\cos(n\omega_0t)+b_n·\sin(n\omega_0t)  \big]\text{\quad\quad}(4)\]</span> 当然，也可以写成<strong>直流+交流</strong>的形式： <spanclass="math display">\[\tilde{x}\small(t\small) =a_0 +\sum^{+\infty}_{n=1}\big[a_n·\cos(n\omega_0t)+b_n·\sin(n\omega_0t)  \big]\text{\quad\quad}(5)\]</span> 所以，我们其实还可以通过欧拉公式变化，得到一个公式： <spanclass="math display">\[C_n = \frac{a_n-j·b_n}{2}\text{\quad\quad}(6)\]</span> 同时我们能变化<span class="math inline">\(C_n\)</span>得到：<span class="math display">\[C_n=|C_n|·e^{j\varphi_n}\text{\quad\quad}(7)\]</span> 其中，<spanclass="math inline">\(|C_n|\)</span>我们称其为幅度，他画的图叫<strong>幅度函数</strong>；<spanclass="math inline">\(\varphi_n\)</span>称其为相位，画的图叫<strong>相位函数</strong>。</p><p>本质上，它们两个构成了<strong>频谱</strong>，分析频谱，其实就是分析这两个东西。</p><hr /><p>我们看到公式（5），发现经过变换后，公式里面已经没有复数。只有系数<spanclass="math inline">\(a_n、b_n\)</span>还没确定，对里面的两个系数进行求解，公式如下：<span class="math display">\[\begin{cases}a_n =\frac{2}{T_0}\int^{t+T}_{t}\tilde{x}\small(t\small)\cos(\omega_0nt)·dt\\b_n =\frac{2}{T_0}\int^{t+T}_{t}\tilde{x}\small(t\small)\sin(\omega_0nt)·dt\\a_0 = \frac{1}{T_0}\int^{t+T}_{t}\tilde{x}\small(t\small)·dt\\end{cases}\text{\quad\quad}(8)\]</span></p><h2 id="频谱特点">3.频谱特点</h2><ul><li>离散型</li><li>发散性</li><li>有效带宽</li></ul><h2 id="周期展开">4.周期展开</h2><p>具有对称特性的傅里叶级数。</p><p>我们对具有特定性质的周期，可以通过数学特性，减少计算量。</p><h3 id="偶对称">1.偶对称</h3><ul><li>形式：<span class="math inline">\(\tilde{x}(t) =\tilde{x}(-t)\)</span></li></ul><p>偶对称关于y轴对称，所以只需要计算一半的周期即可。 <spanclass="math display">\[\begin{cases}a_n =\frac{4}{T_0}\int^{t+T}_{t}\tilde{x}\small(t\small)\cos(\omega_0nt)·dt\\b_n=0\end{cases}\text{\quad\quad}(9)\]</span></p><ul><li>含有直流和余弦项，不含有正弦项。</li></ul><h3 id="奇对称">2.奇对称</h3><ul><li>形式：<span class="math inline">\(\tilde{x}(t) =-\tilde{x}(-t)\)</span></li></ul><p>奇对称关于原点对称，所以只需要计算一半的周期即可。 <spanclass="math display">\[\begin{cases}a_n = 0\\b_n=\frac{4}{T_0}\int^{t+T}_{t}\tilde{x}\small(t\small)\sin(\omega_0nt)·dt\end{cases}\text{\quad\quad}(10)\]</span></p><ul><li>含有正弦项，不含有余弦项和直流分量</li></ul><h3 id="半波重叠">3.半波重叠</h3><ul><li>形式：<span class="math inline">\(\tilde{x}(t) =\tilde{x}(t+\frac{T_0}{2})\)</span></li><li>一个周期<spanclass="math inline">\(T_0\)</span>内，刚好存在两个一模一样的周期<spanclass="math inline">\(T_1\)</span>波。</li></ul><p><span class="math display">\[C_n = \frac{2}{T_0}\int^{\frac{T}{2}}_{-\frac{T}{2}}\\tilde{x}\small(t\small)\ e^{j2n\omega_0t}\ dt\text{\quad\quad}(11)\]</span></p><ul><li>只含有偶次分量，可能有直流分量。</li></ul><h3 id="半波镜像">4.半波镜像</h3><ul><li>形式：<span class="math inline">\(\tilde{x}(t) =-\tilde{x}(t\pm\frac{T_0}{2})\)</span></li><li>令<span class="math inline">\(\tilde{x}\small(t\small)=\tilde{x}_1\small(t\small)-\tilde{x}\small(t-\frac{T_0}{2}\small)\)</span> 得到：</li></ul><p><span class="math display">\[\tilde{x}_1\small(t\small)+\tilde{x}_1\small(t-\frac{T_0}{2}\small) =\sum^{+\infty}_{n=-\infty,n为奇}2C_ne^{-n\omega_0t}\text{\quad\quad}(12)\]</span></p><ul><li>保留奇次谐波分量，无直流。</li></ul>]]></content>
    
    
    <categories>
      
      <category>信号与系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理－图像分割方法</title>
    <link href="/2024/04/21/4-21blog/"/>
    <url>/2024/04/21/4-21blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我这个人走得很慢，但是我从不后退。——亚伯拉罕·林肯</p></blockquote><p>本文主要介绍图像分割方法中，基于阈值分割的方法；并通过实验进行分析。</p><p><span id="more"></span></p><h1 id="图像分割方法">图像分割方法</h1><ol type="1"><li>基于阈值分割方法</li><li>基于边缘分割方法</li><li>基于区域分割方法</li><li>基于特定理论分割方法</li><li>基于深度学习分割方法。</li></ol><h1 id="基于阈值处理的图像分割算法">基于阈值处理的图像分割算法</h1><h2 id="灰度阈值基础">灰度阈值基础</h2><p>给定灰度图像，假设该图像有目标物体和背景像素所构成，现在要从图像中提取目标物体，一个最为直接的方法就是使用一个固定阈值将目标物体像素与背景像素分开，以区域为目标物体区域，否则为背景区域。</p><h2 id="阈值的选择">阈值的选择</h2><ul><li>全局阈值</li><li>自适应阈值</li><li>最优化阈值</li></ul><h2 id="阈值直方图的特点">阈值直方图的特点</h2><p>直方图呈现双峰特征：</p><ul><li>一个峰表示前景</li><li>一个峰表示后景</li></ul><h2 id="全局阈值处理">全局阈值处理</h2><p>当图像中存在较大的灰度变化时，使用全局阈值处理的方法一般就能够取得较好的效果。但我们仍希望对于一幅图像，能够找到一个相对合理的阈值来作为全局阈值。因而就有迭代的阈值图像分割算法。算法流程如下：</p><p>初始化全局阈值</p><p>基于分割该图像，产生两组像素：由灰度值大于的像素组成，由灰度值小于等于的像素组成</p><p>对和像素分别计算平均灰度值和</p><p>计算一个新的阈值</p><p>重复第2到第4步，直到连续迭代中的值间的差小于一个预定的参数为止。</p><p>下面来看一个使用全局阈值的图像分割例子。直接读入图像，先基于Numpy进行灰度化和二值化处理。</p><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>img = cv2.imread(<span class="hljs-string">&#x27;25.png&#x27;</span>)<br>img1 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)<br>plt.imshow(img1)<br>plt.show()<br><br><span class="hljs-comment"># 灰度化</span><br>y = <span class="hljs-number">0.2126</span>*img[:,:,<span class="hljs-number">2</span>] + <span class="hljs-number">0.7152</span>*img[:,:,<span class="hljs-number">1</span>] + <span class="hljs-number">0.0722</span>*img[:,:,<span class="hljs-number">0</span>]<br>img[:,:,<span class="hljs-number">0</span>] = y<br>img[:,:,<span class="hljs-number">1</span>] = y<br>img[:,:,<span class="hljs-number">2</span>] = y<br><span class="hljs-comment"># 以128为阈值进行二值化</span><br>y[y&gt;=<span class="hljs-number">128</span>] = <span class="hljs-number">255</span><br>y[y&lt;<span class="hljs-number">128</span>] = <span class="hljs-number">0</span><br>img[:,:,<span class="hljs-number">0</span>] = y<br>img[:,:,<span class="hljs-number">1</span>] = y<br>img[:,:,<span class="hljs-number">2</span>] = y<br>plt.imshow(img);<br></code></pre></td></tr></table></figure><p><strong>效果</strong>：</p><figure><img src="https://pic.imgdb.cn/item/66249ad60ea9cb1403c71caa.png"alt="原图" /><figcaption aria-hidden="true">原图</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/66249ad60ea9cb1403c71cd1.png"alt="分割效果图" /><figcaption aria-hidden="true">分割效果图</figcaption></figure><p>opencv也提供了全局阈值的分割方法，处理<strong>代码</strong>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img1 = cv2.imread(<span class="hljs-string">&#x27;25.png&#x27;</span>)<br>img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB)<br>plt.imshow(img1)<br>plt.show()<br><br>img = cv2.imread(<span class="hljs-string">&#x27;25.png&#x27;</span>,<span class="hljs-number">0</span>)<br>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)<br>ret, thresh1 = cv2.threshold(img, <span class="hljs-number">128</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>plt.imshow(img)<br>plt.show()<br><br>plt.imshow(thresh1);<br></code></pre></td></tr></table></figure><p>​ <strong>效果</strong>：</p><p><img src="https://pic.imgdb.cn/item/66249ad60ea9cb1403c71caa.png"alt="原图" /> ​</p><figure><img src="https://pic.imgdb.cn/item/66249ad60ea9cb1403c71d7c.png"alt="灰度图" /><figcaption aria-hidden="true">灰度图</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/66249b270ea9cb1403c7a803.png"alt="分割后的效果图" /><figcaption aria-hidden="true">分割后的效果图</figcaption></figure><p>可以看到：小矮人--艾泽--的胡子几乎不被标记出来。</p><p>一是因为他的胡子覆盖了整个脸部，导致没有明显的边缘信息；</p><p>我们说边缘，其实就是像素值变化大的地方。</p><p>阈值法的核心就是选择阈值，来很好的标记边缘。</p><p>因此我们可以看到阈值法的优点：<strong>快、简单</strong>。</p><p>但是缺点也很明显，不够聪明、灵活，当出现背景颜色变化不明显的时候，可能不能很好的分割边缘。</p><h1 id="大津法otsu">大津法（OTSU）</h1><p>基于阈值的图像二值化方法的一个关键在于如何选定阈值，这可以视作为一个全局寻优问题。大津法也即OTSU法，是由日本学者大津展之于1979年提出的一种图像阈值分割方法。该方法将阈值划分视作是一个统计决策问题，其目的在于将像素分配给两组或多组的过程中使得引入的平均误差最小。大津法给出的方案是使得两组之间的类间方差最大时的阈值为最优阈值。所以大津法也叫最大类间方差法。</p><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>OTSU = cv2.imread(<span class="hljs-string">&#x27;25.png&#x27;</span>)<br><span class="hljs-comment"># img = img.astype(np.float)</span><br>H, W, C = OTSU.shape<br><span class="hljs-comment"># 灰度化</span><br>out = <span class="hljs-number">0.2126</span>*OTSU[:,:,<span class="hljs-number">2</span>] + <span class="hljs-number">0.7152</span>*OTSU[:,:,<span class="hljs-number">1</span>] + <span class="hljs-number">0.0722</span>*OTSU[:,:,<span class="hljs-number">0</span>]<br>out = out.astype(np.uint8)<br><span class="hljs-comment"># 初始化类间方差和最佳阈值</span><br>max_sigma = <span class="hljs-number">0</span><br>max_t = <span class="hljs-number">0</span><br> <br><span class="hljs-comment"># 遍历迭代</span><br><span class="hljs-keyword">for</span> _t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">255</span>):<br>    <span class="hljs-comment"># 小于阈值t的类v0</span><br>    v0 = out[np.where(out&lt;_t)]<br>    <span class="hljs-comment"># 计算v0均值</span><br>    M0 = np.mean(v0) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(v0) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0.</span><br>    <span class="hljs-comment"># v0类像素占比</span><br>    w0 = <span class="hljs-built_in">len</span>(v0)/(H*W)<br>    <span class="hljs-comment"># 大于阈值t的类v1</span><br>    v1 = out[np.where(out&gt;=_t)]<br>    <span class="hljs-comment"># 计算v1均值</span><br>    M1 = np.mean(v1) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(v1) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0.</span><br>    <span class="hljs-comment"># v1类像素占比</span><br>    w1 = <span class="hljs-built_in">len</span>(v1)/(H*W)<br>    <span class="hljs-comment"># 类间方差</span><br>    Sb2 = w0*w1*((M0-M1)**<span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 寻优</span><br>    <span class="hljs-keyword">if</span> Sb2 &gt; max_sigma:<br>        max_sigma = Sb2<br>        max_t = _t<br>        <br><span class="hljs-comment"># 打印最佳阈值        </span><br><span class="hljs-built_in">print</span>(max_t)<br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><blockquote><p>108</p></blockquote><p>最佳阈值是108，带入进行二值化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>OTSU = cv2.imread(<span class="hljs-string">&#x27;25.png&#x27;</span>)<br><span class="hljs-comment"># 灰度化</span><br>y = <span class="hljs-number">0.2126</span>*OTSU[:,:,<span class="hljs-number">2</span>] + <span class="hljs-number">0.7152</span>*OTSU[:,:,<span class="hljs-number">1</span>] + <span class="hljs-number">0.0722</span>*OTSU[:,:,<span class="hljs-number">0</span>]<br>img[:,:,<span class="hljs-number">0</span>] = y<br>img[:,:,<span class="hljs-number">1</span>] = y<br>img[:,:,<span class="hljs-number">2</span>] = y<br><span class="hljs-comment"># 以108为阈值进行二值化</span><br>y[y&gt;=<span class="hljs-number">108</span>] = <span class="hljs-number">255</span><br>y[y&lt;<span class="hljs-number">108</span>] = <span class="hljs-number">0</span><br>OTSU[:,:,<span class="hljs-number">0</span>] = y<br>OTSU[:,:,<span class="hljs-number">1</span>] = y<br>OTSU[:,:,<span class="hljs-number">2</span>] = y<br>plt.imshow(OTSU);<br></code></pre></td></tr></table></figure><p><strong>效果：</strong></p><figure><img src="https://pic.imgdb.cn/item/66249b280ea9cb1403c7a82a.png"alt="效果图" /><figcaption aria-hidden="true">效果图</figcaption></figure><p>opencv中直接提供了大津法的实现方法，如下代码所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;25.png&#x27;</span>)<br><span class="hljs-comment"># 灰度化</span><br>img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br><span class="hljs-comment"># 大津法阈值化处理</span><br>ret, th = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY+cv2.THRESH_OTSU)<br>plt.imshow(th);<br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/66249b280ea9cb1403c7a88f.png"alt="效果图" /> ​</p><p><strong>对比试验</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原图</span><br>img1 = cv2.imread(<span class="hljs-string">&#x27;25.png&#x27;</span>)<br>img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB)<br>plt.imshow(img1)<br>plt.show()<br><span class="hljs-comment"># 对比全局阈值与大津法</span><br>plt.imshow(thresh1)<br>plt.show()<br>plt.imshow(OTSU);<br></code></pre></td></tr></table></figure><p>​</p><p><img src="https://pic.imgdb.cn/item/66249ad60ea9cb1403c71caa.png"alt="原图" /> ​</p><figure><img src="https://pic.imgdb.cn/item/66249b270ea9cb1403c7a803.png"alt="全局阈值效果图" /><figcaption aria-hidden="true">全局阈值效果图</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/66249b280ea9cb1403c7a82a.png"alt="大津法效果图" /><figcaption aria-hidden="true">大津法效果图</figcaption></figure><h2 id="实验分析">实验分析</h2><p>可以看到，大津法对于艾泽的帽子，处理的很好。脸颊胡子边缘也处理得当。</p><h2 id="实验小结">实验小结</h2><p>基于阈值的图像分割方法简单直接，计算速度快，在图像灰度差异较大的情况下，是首选的分割方法。</p><p>但阈值分割方法本身也存在抗噪能力弱、使用条件严格等缺点，所以往往会配合图像滤波去噪等方法一起使用。</p><h1 id="backgroundsubtractormog">BackgroundSubtractorMOG</h1><p>这是一个基于混合高斯模型的背景前景分割算法。来自论文：An improvedadaptive background mixture model for real-time tracking with shadowdetection。</p><p>它使用的方法是对每个背景像素由k个混合高斯模型进行建模，k通常为3或5。彩色信息在场景中存在时间的比例作为高斯混合模型的权重大小。最有可能的背景颜色信息是停留时间最长且更为静止的。</p><p>编写代码的时候需要使用一个函数来创建的一个背景对象cv2.createBackgroundSubtractorMOG()。</p><p>这里有一些可选参数，如历史时间（length ofhistory），高斯模型的数量，阈值等等。这些值全部被设置为缺省。</p><p>获取背景后，进入视频循环，使用函数backgroundsubtractor.apply()来获取前景的蒙板。</p><p>函数原型：</p><p>retval = cv.bgsegm.createBackgroundSubtractorMOG( [, history[,nmixtures[, backgroundRatio[, noiseSigma]]]] )</p><p>参数：</p><p>history Length of the history.<br /></p><p>nmixtures Number of Gaussian mixtures.<br /></p><p>backgroundRatio Background ratio.<br /></p><p>noiseSigma Noise strength (standard deviation of the brightness oreach color channel). 0 means some automatic value.</p><p><strong>代码（以弃用）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br>cap = cv2.VideoCapture(<span class="hljs-number">0</span>)<br>fgbg = cv2.createBackgroundSubtractorMOG()<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>    ret, frame = cap.read()<br>    fgmask = fgbg.apply(frame)<br>    cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>,fgmask) <br>    <span class="hljs-keyword">if</span> k == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br>cap.release()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p>cv.bgsegm.createBackgroundSubtractorMOG()</p><p>截至本文编辑发布，查阅发现该方法以弃用【3】；</p><h1 id="backgroundsubtractormog2">BackgroundSubtractorMOG2</h1><p>这个也是以高斯混合模型为基础的背景/前景分割算法。它是以 2004 年 和2006 年 Z.Zivkovic 的两篇文章为基础的。这个算法的一个特点是它为每一个像素选择一个合适数目的高斯分布。(上一个方法中我们使用是K 高斯分布)。</p><p>这样就会对由于亮度等发生变化引起的场景变化产生更好的适应。</p><p>和前面一样我们需要创建一个背景对象。但在这里我们我们可以选择是否检测阴影。如果detectShadows =True(默认值)，它就会检测并将影子标记出来，但是这样做会降低处理速度。影子会被标记为灰色。</p><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><br>cap = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br>fgbg = cv2.createBackgroundSubtractorMOG2()<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>    ret, frame = cap.read()<br><br>    fgmask = fgbg.apply(frame)<br><br>    cv2.imshow(<span class="hljs-string">&#x27;org&#x27;</span>,frame)<br>    cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>,fgmask)<br>    k = cv2.waitKey(<span class="hljs-number">30</span>) &amp; <span class="hljs-number">0xff</span><br>    <span class="hljs-keyword">if</span> k == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br><br>cap.release()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><h2 id="实验结果">实验结果</h2><figure><img src="https://pic.imgdb.cn/item/66249ad50ea9cb1403c71c48.gif"alt="实验视频" /><figcaption aria-hidden="true">实验视频</figcaption></figure><p>该方法对亮度变换非常敏感！</p><h1 id="总结">总结</h1><p>本文对图像分割方法中的基于阈值分割方法进行代码复现，并参考资料进行其他方法的比较实验。实验效果显示完美。</p><h1 id="参考链接">参考链接：</h1><p>【1】https://blog.csdn.net/weixin_37737254/article/details/120610103</p><p>【2】https://blog.csdn.net/tengfei461807914/article/details/81588808</p><p>【3】https://blog.csdn.net/u014737138/article/details/80389977</p><p>【4】<ahref="https://zhuanlan.zhihu.com/p/31103280#:~:text=%E8%83%8C%E6%99%AF%E5%87%8F%E9%99%A4%20%28Background%20Subtraction%29%E6%98%AF%E8%AE%B8%E5%A4%9A%E5%9F%BA%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%9A%84%E4%BB%BB%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E9%A2%84%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4%E3%80%82,%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E6%9C%89%E5%AE%8C%E6%95%B4%E7%9A%84%E9%9D%99%E6%AD%A2%E7%9A%84%E8%83%8C%E6%99%AF%E5%B8%A7%EF%BC%8C%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%B8%A7%E5%B7%AE%E6%B3%95%E6%9D%A5%E8%AE%A1%E7%AE%97%E5%83%8F%E7%B4%A0%E5%B7%AE%E4%BB%8E%E8%80%8C%E8%8E%B7%E5%8F%96%E5%88%B0%E5%89%8D%E6%99%AF%E5%AF%B9%E8%B1%A1%E3%80%82%20%E4%BD%86%E6%98%AF%E5%9C%A8%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E8%83%BD%E6%B2%A1%E6%9C%89%E8%BF%99%E6%A0%B7%E7%9A%84%E5%9B%BE%E5%83%8F%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%BB%8E%E6%88%91%E4%BB%AC%E6%8B%A5%E6%9C%89%E7%9A%84%E4%BB%BB%E4%BD%95%E5%9B%BE%E5%83%8F%E4%B8%AD%E6%8F%90%E5%8F%96%E8%83%8C%E6%99%AF%E3%80%82%20%E5%BD%93%E8%BF%90%E5%8A%A8%E7%89%A9%E4%BD%93%E6%9C%89%E9%98%B4%E5%BD%B1%E6%97%B6%EF%BC%8C%E7%94%B1%E4%BA%8E%E9%98%B4%E5%BD%B1%E4%B9%9F%E5%9C%A8%E7%A7%BB%E5%8A%A8%EF%BC%8C%E6%83%85%E5%86%B5%E4%BC%9A%E5%8F%98%E7%9A%84%E5%8F%98%E5%BE%97%E6%9B%B4%E5%8A%A0%E5%A4%8D%E6%9D%82%E3%80%82%20%E4%B8%BA%E6%AD%A4%E5%BC%95%E5%85%A5%E4%BA%86%E8%83%8C%E6%99%AF%E5%87%8F%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%8C%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%80%E6%96%B9%E6%B3%95%E6%88%91%E4%BB%AC%E8%83%BD%E5%A4%9F%E4%BB%8E%E8%A7%86%E9%A2%91%E4%B8%AD%E5%88%86%E7%A6%BB%E5%87%BA%E8%BF%90%E5%8A%A8%E7%9A%84%E7%89%A9%E4%BD%93%E5%89%8D%E6%99%AF%EF%BC%8C%E4%BB%8E%E8%80%8C%E8%BE%BE%E5%88%B0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%9A%84%E7%9B%AE%E7%9A%84%E3%80%82">zhihulianjie</a></p>]]></content>
    
    
    <categories>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
      <tag>python</tag>
      
      <tag>图像</tag>
      
      <tag>openCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Learn More, Study Less!》-读书笔记-2</title>
    <link href="/2024/04/20/4-20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/04/20/4-20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>任何问题都有解决的办法，无法可想的事是没有的。——爱迪生</p></blockquote><span id="more"></span><h1 id="整体学习的顺序">整体学习的顺序</h1><p>到目前为止，我描述了当信息存储在你的头脑中时，它看起来是什么样子。</p><p>但真正的问题是，它最初是如何到达那里的？</p><blockquote><p>I’ve divided up almost all learning tasks into several unique steps.Often you won’t need to complete all the steps to understand enough topass a test. The steps might not always follow in the same order. Youmay go back to the first step after completing the second before movingonto the third.</p></blockquote><p>我几乎把所有的学习任务分成几个独特的步骤。通常，你不需要完成所有步骤就能理解足够通过考试。这些步骤可能并不总是按照相同的顺序进行。你可能在完成第二步后回到第一步，然后再进入第三步。</p><p>重要的是，这些步骤中的每一个步骤都代表了学习中涉及的关键活动。当你在这个过程中反复错过一个步骤，或者完成得不好时，信息就不会被正确地存储。学习失败，信息无法进入你的整体网络。</p><hr /><h3 id="整体学习的顺序-1">整体学习的顺序</h3><ol type="1"><li><strong>Acquire</strong></li><li><strong>Understand</strong></li><li><strong>Explore</strong></li><li><strong>Debug</strong></li><li><strong>Apply</strong></li></ol><p>1）获取 2）理解 3）探索 4）调试 5）应用</p><p>最后一步是测试，他不在这些的里面，但适用于里面的每个步骤。</p><p>测试是检查你是否很好地执行了这些步骤。如果没有严格的自我测试（当你到达考试房间时，已经太晚了），你可能不会意识到一个步骤执行得不好。</p><ol type="1"><li><strong>Acquire</strong></li></ol><p>信息通过你的眼睛和耳朵进入的地方。</p><p>阅读、在课堂上做笔记或个人经历都是获取阶段的一部分。</p><p>这里的<strong>目标是</strong>以<strong>最压缩的形式</strong>获得<strong>准确的信息</strong>。</p><ol start="2" type="1"><li><strong>Understand</strong></li></ol><p><strong>理解</strong>意味着接受<strong>原始信息</strong>，并给它<strong>一个上下文</strong>。</p><p>这将是你为了学习而需要执行的最基本的相互联系。</p><ol start="3" type="1"><li><strong>Explore</strong></li></ol><p>探索阶段是整体学习真正发力的地方。</p><p>在这里，您将形成所需的模型、高速公路和更广泛的连接，以构建清晰的结构。</p><ol start="4" type="1"><li><strong>Debug</strong></li></ol><p>调试阶段查找<strong>模型</strong>和公路中的<strong>错误</strong>。</p><p>此阶段修剪连接，因此无效的连接将不会保留，或者将被限制在它们工作的区域。</p><ol start="5" type="1"><li><strong>Apply</strong></li></ol><p>应用阶段将调试提升到了最终水平，通过与现实世界中这些信息的操作方式进行比较进行调整。</p><p>如果这些理解不能针对现实世界进行定制，那么它们就是无用的。</p><p>在这一步上的失败可能是那些有书本知识但似乎无法在课堂外使用这些知识的人的例子。</p><ol start="6" type="1"><li><strong>Test</strong></li></ol><p>在所有六个阶段中，您应该不断测试您的方法并学习。这将帮助您快速识别学习系统中的问题，并帮助您开发新的技术来克服弱点。</p><p>本书后半部分的不同技术适用于序列的不同阶段。</p><p><strong>快速阅读</strong>可以帮助获取想法，<strong>基于流程的笔记</strong>和<strong>隐喻</strong>可以帮助探索想法。</p><p><strong>模型调试</strong>和<strong>基于项目的学习</strong>可以帮助你调试和应用想法。</p>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
      <category>《learn-more-study-less》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机视觉-学习笔记-腐蚀与膨胀</title>
    <link href="/2024/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/"/>
    <url>/2024/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/</url>
    
    <content type="html"><![CDATA[<h1 id="腐蚀与膨胀">腐蚀与膨胀</h1><p>腐蚀与膨胀是图像形态学的两种核心操作，通过合理的使用，可以实现图像各类操作。</p><p><span id="more"></span></p><blockquote><p>人生的奋斗目标不要太大，认准一件事情，投入兴趣与热情坚持去做，你就会成功。</p><p>俞敏洪(新东方教育集团创始人)</p></blockquote><h1 id="腐蚀">1.腐蚀</h1><ul><li>腐蚀操作可以让图像沿着自己的边缘向内收缩；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dst = cv2.erode(src, kernel, anchor, iterations, borderType, borderValue)<br></code></pre></td></tr></table></figure><p><strong>src</strong>: 原始图像</p><p><strong>kernel</strong>：腐蚀使用的核</p><p><strong>anchor</strong>：可选参数，核的锚点位置</p><p><strong>iterations</strong>：可选参数，腐蚀迭代次数，默认为1</p><p><strong>borderType</strong>：可选参数，边界样式，建议默认</p><p><strong>borderValue</strong>：可选参数，边界值，建议默认</p><p>返回值说明： dst：经过腐蚀之后的图像。</p><p>在openCV做腐蚀通常使用Numpy模块来创建核数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>k = np.ones((<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), np.uint8)<br></code></pre></td></tr></table></figure><p>行列数越大，计算出的效果越粗糙；</p><p>行列数越小，解算出的结果越精细。</p><p><strong>示例1</strong></p><p>将仙人球图像进行腐蚀操作</p><p><strong>原图像</strong></p><figure><img src="https://pic.imgdb.cn/item/662291010ea9cb140304ae92.jpg"alt="cactus.jpg" /><figcaption aria-hidden="true">cactus.jpg</figcaption></figure><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;cactus.jpg&quot;</span>)  <span class="hljs-comment"># 读取原图</span><br>k = np.ones((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), np.uint8)  <span class="hljs-comment"># 创建3*3的数组作为核</span><br>cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>, img)  <span class="hljs-comment"># 显示原图</span><br>dst = cv2.erode(img, k)  <span class="hljs-comment"># 腐蚀操作</span><br>cv2.imshow(<span class="hljs-string">&quot;dst&quot;</span>, dst)  <span class="hljs-comment"># 显示腐蚀效果</span><br>cv2.imwrite(<span class="hljs-string">&quot;cactus1.jpg&quot;</span>,dst)  <span class="hljs-comment"># 保存图片</span><br>cv2.waitKey()  <span class="hljs-comment"># 按下任何键盘按键后</span><br>cv2.destroyAllWindows()  <span class="hljs-comment"># 释放所有窗体</span><br></code></pre></td></tr></table></figure><p><strong>效果</strong>：</p><figure><img src="https://pic.imgdb.cn/item/662291020ea9cb140304af04.jpg"alt="cactus1.jpg" /><figcaption aria-hidden="true">cactus1.jpg</figcaption></figure><h1 id="膨胀">2.膨胀</h1><ul><li>膨胀和腐蚀相反，当核在图像的边缘移动时，会将图像边缘填补新的像素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dst = cv2.dilate(src, kernel, anchor, iterations, borderType, borderValue)<br></code></pre></td></tr></table></figure><p><strong>src</strong>: 原始图像</p><p><strong>kernel</strong>：腐蚀使用的核</p><p><strong>anchor</strong>：可选参数，核的锚点位置</p><p><strong>iterations</strong>：可选参数，腐蚀迭代次数，默认为1</p><p><strong>borderType</strong>：可选参数，边界样式，建议默认</p><p><strong>borderValue</strong>：可选参数，边界值，建议默认</p><p>返回值说明：</p><p>dst：经过腐蚀之后的图像。</p><p><strong>实例2</strong></p><figure><img src="https://pic.imgdb.cn/item/662291140ea9cb140304d6be.jpg"alt="sunset.jpg" /><figcaption aria-hidden="true">sunset.jpg</figcaption></figure><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;sunset.jpg&quot;</span>)  <span class="hljs-comment"># 读取原图</span><br>k = np.ones((<span class="hljs-number">9</span>, <span class="hljs-number">9</span>), np.uint8)  <span class="hljs-comment"># 创建9*9的数组作为核</span><br>cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>, img)  <span class="hljs-comment"># 显示原图</span><br>dst = cv2.dilate(img, k)  <span class="hljs-comment"># 膨胀操作</span><br>cv2.imshow(<span class="hljs-string">&quot;dst&quot;</span>, dst)  <span class="hljs-comment"># 显示膨胀效果</span><br>cv2.imwrite(<span class="hljs-string">&quot;sunset1.jpg&quot;</span>,dst) <span class="hljs-comment"># 保存图片</span><br>cv2.waitKey()  <span class="hljs-comment"># 按下任何键盘按键后</span><br>cv2.destroyAllWindows()  <span class="hljs-comment">#释放所有窗体</span><br></code></pre></td></tr></table></figure><p><strong>效果</strong>：</p><figure><img src="https://pic.imgdb.cn/item/662291140ea9cb140304d724.jpg"alt="sunset1.jpg" /><figcaption aria-hidden="true">sunset1.jpg</figcaption></figure><h1 id="开运算">3.开运算</h1><ul><li>开运算就是将图片先进行腐蚀操作，在进行膨胀操作；</li><li>开运算可以用来抹除图像外部的细节（或者噪声）；</li><li>在某些情况下，可用于统计二叉树节点数量；</li></ul><p><strong>实例3</strong>：</p><figure><img src="https://pic.imgdb.cn/item/662291020ea9cb140304af5d.png"alt="nigella.png" /><figcaption aria-hidden="true">nigella.png</figcaption></figure><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;nigella.png&quot;</span>)  <span class="hljs-comment"># 读取原图</span><br>k = np.ones((<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), np.uint8)  <span class="hljs-comment"># 创建5*5的数组作为核</span><br>cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>, img)  <span class="hljs-comment"># 显示原图</span><br>dst = cv2.erode(img, k)  <span class="hljs-comment"># 腐蚀操作</span><br>dst = cv2.dilate(dst, k)  <span class="hljs-comment"># 膨胀操作</span><br>cv2.imshow(<span class="hljs-string">&quot;dst&quot;</span>, dst)  <span class="hljs-comment"># 显示开运算结果</span><br>cv2.imwrite(<span class="hljs-string">&quot;nigella1.jpg&quot;</span>,dst) <span class="hljs-comment"># 保存图片</span><br>cv2.waitKey()  <span class="hljs-comment"># 按下任何键盘按键后</span><br>cv2.destroyAllWindows() <span class="hljs-comment"># 释放所有窗体</span><br></code></pre></td></tr></table></figure><p><strong>效果</strong>：</p><figure><img src="https://pic.imgdb.cn/item/662291020ea9cb140304b033.jpg"alt="nigella1.jpg" /><figcaption aria-hidden="true">nigella1.jpg</figcaption></figure><h1 id="闭运算">4.闭运算</h1><ul><li>闭运算就是将图像先进行膨胀操作，再进行腐蚀操作；</li><li>闭运算可以抹除图像内部的细节；</li><li>除了抹除细节，还会让一些离得较近的区域合并成一块；</li></ul><p><strong>示例4</strong>：</p><figure><img src="https://pic.imgdb.cn/item/662291140ea9cb140304d76a.png"alt="tianye.png" /><figcaption aria-hidden="true">tianye.png</figcaption></figure><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;tianye.png&quot;</span>)  <span class="hljs-comment"># 读取原图</span><br>k = np.ones((<span class="hljs-number">15</span>, <span class="hljs-number">15</span>), np.uint8)  <span class="hljs-comment"># 创建15*15的数组作为核</span><br>cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>, img)  <span class="hljs-comment"># 显示原图</span><br>dst = cv2.dilate(img, k)  <span class="hljs-comment"># 膨胀操作</span><br>dst = cv2.erode(dst, k)  <span class="hljs-comment"># 腐蚀操作</span><br>cv2.imshow(<span class="hljs-string">&quot;dst2&quot;</span>, dst)  <span class="hljs-comment"># 显示闭运算结果</span><br>cv2.imwrite(<span class="hljs-string">&quot;tianye1.jpg&quot;</span>,dst) <span class="hljs-comment"># 保存图片</span><br>cv2.waitKey()  <span class="hljs-comment"># 按下任何键盘按键后</span><br>cv2.destroyAllWindows()  <span class="hljs-comment"># 释放所有窗体</span><br></code></pre></td></tr></table></figure><p><strong>效果</strong>：</p><figure><img src="https://pic.imgdb.cn/item/662291140ea9cb140304d7ac.jpg"alt="tianye1.jpg" /><figcaption aria-hidden="true">tianye1.jpg</figcaption></figure><h1 id="形态学方法">5.形态学方法</h1><ul><li>除了开运算和闭运算，还有其他的方法：<ul><li>梯度运算</li><li>顶帽运算</li><li>黑帽运算</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dst = cv2.morphologyEx(scr, op, kernel, anchor, iterations, borderType, bordreValue)<br></code></pre></td></tr></table></figure><p>参数说明：</p><p><strong>scr</strong>：原始图像</p><p><strong>op</strong>：操作类型</p><table><thead><tr class="header"><th><strong>操作类型</strong></th><th><strong>信息</strong></th></tr></thead><tbody><tr class="odd"><td><strong>c2.MORPH_ERODE</strong></td><td><strong>腐蚀操作</strong></td></tr><tr class="even"><td><strong>cv.MORPH_DILATE</strong></td><td><strong>膨胀操作</strong></td></tr><tr class="odd"><td><strong>cv2.MORPH_OPEN</strong></td><td><strong>开运算</strong></td></tr><tr class="even"><td><strong>cv2.MORPH_CLOSE</strong></td><td><strong>闭运算</strong></td></tr><tr class="odd"><td><strong>cv2.ORPH_GRADIENT</strong></td><td><strong>梯度运算</strong></td></tr><tr class="even"><td><strong>cv.MORPH_TOPHAT</strong></td><td><strong>顶帽运算</strong></td></tr><tr class="odd"><td><strong>cv2.MORPH_BLACKHAT</strong></td><td><strong>黑帽运算</strong></td></tr></tbody></table><p><strong>kernel</strong>：操作过程中所使用的核；</p><p><strong>anchor</strong>：可选参数，核的锚点位置</p><p><strong>iterations</strong>：可选参数，腐蚀迭代次数，默认为1</p><p><strong>borderType</strong>：可选参数，边界样式，建议默认</p><p><strong>borderValue</strong>：可选参数，边界值，建议默认</p><p>返回值说明：</p><p><strong>dst</strong>：经过腐蚀之后的图像。</p><h2 id="梯度运算">5.1梯度运算</h2><ul><li>梯度指的是图像梯度，可以简单理解为图像像素的变化程度；</li><li>如果几个连续的像素，其像素的值跨度越大，则梯度值就越大；</li><li>膨胀-腐蚀=轮廓图像</li><li>得到的轮廓图像只是一个大致轮廓，不精准；</li></ul><p><strong>示例5</strong>：</p><figure><img src="https://pic.imgdb.cn/item/662291020ea9cb140304b069.png"alt="spider.png" /><figcaption aria-hidden="true">spider.png</figcaption></figure><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;spider.png&quot;</span>)  <span class="hljs-comment"># 读取原图</span><br>k = np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>), np.uint8)  <span class="hljs-comment"># 创建5*5的数组作为核</span><br>cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>, img)  <span class="hljs-comment"># 显示原图</span><br>dst = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, k) <span class="hljs-comment"># 进行梯度运算</span><br>cv2.imshow(<span class="hljs-string">&quot;dst&quot;</span>, dst)  <span class="hljs-comment"># 显示梯度运算结果</span><br>cv2.imwrite(<span class="hljs-string">&quot;spider1.jpg&quot;</span>,dst) <span class="hljs-comment"># 保存图片</span><br>cv2.waitKey()  <span class="hljs-comment"># 按下任何键盘按键后</span><br>cv2.destroyAllWindows()  <span class="hljs-comment"># 释放所有窗体</span><br></code></pre></td></tr></table></figure><p><strong>效果</strong>：</p><figure><img src="https://pic.imgdb.cn/item/6622910d0ea9cb140304c5e6.jpg"alt="spider1.jpg" /><figcaption aria-hidden="true">spider1.jpg</figcaption></figure><h2 id="顶帽运算">5.2顶帽运算</h2><ul><li>原图-原图开运算=外部信息图</li><li>开运算=先腐蚀，再膨胀</li><li>开运算会抹除图像的外部信息</li><li>所以会得到没有外部细节的图像</li></ul><p><strong>实例6</strong>：</p><figure><img src="https://pic.imgdb.cn/item/662291020ea9cb140304b069.png"alt="spider.png" /><figcaption aria-hidden="true">spider.png</figcaption></figure><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;spider.png&quot;</span>)  <span class="hljs-comment"># 读取原图</span><br>k = np.ones((<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), np.uint8)  <span class="hljs-comment"># 创建5*5的数组作为核</span><br>cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>, img)  <span class="hljs-comment"># 显示原图</span><br>dst = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, k)  <span class="hljs-comment"># 进行顶帽运算</span><br>cv2.imshow(<span class="hljs-string">&quot;dst&quot;</span>, dst)  <span class="hljs-comment"># 显示顶帽运算结果</span><br>cv2.imwrite(<span class="hljs-string">&quot;spider2.jpg&quot;</span>,dst) <span class="hljs-comment"># 保存图片</span><br>cv2.waitKey()  <span class="hljs-comment"># 按下任何键盘按键后</span><br>cv2.destroyAllWindows()  <span class="hljs-comment"># 释放所有窗体</span><br></code></pre></td></tr></table></figure><p><strong>效果</strong>：</p><figure><img src="https://pic.imgdb.cn/item/6622910d0ea9cb140304c616.jpg"alt="spider2.jpg" /><figcaption aria-hidden="true">spider2.jpg</figcaption></figure><h2 id="黑帽运算">5.3黑帽运算</h2><ul><li>原图闭运算-原图=内部细节图</li><li>闭运算=先膨胀，再腐蚀</li><li>闭运算会抹掉内部细节</li><li>所以会得到内部信息图</li></ul><p><strong>实例7</strong>：</p><figure><img src="https://pic.imgdb.cn/item/6622910d0ea9cb140304c64f.png"alt="spider2.png" /><figcaption aria-hidden="true">spider2.png</figcaption></figure><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;spider2.png&quot;</span>)  <span class="hljs-comment"># 读取原图</span><br>k = np.ones((<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), np.uint8)  <span class="hljs-comment"># 创建5*5的数组作为核</span><br>cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>, img)  <span class="hljs-comment"># 显示原图</span><br>dst = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, k)  <span class="hljs-comment"># 进行黑帽运算</span><br>cv2.imshow(<span class="hljs-string">&quot;dst&quot;</span>, dst)  <span class="hljs-comment"># 显示黑帽运算结果</span><br>cv2.imwrite(<span class="hljs-string">&quot;spider3.jpg&quot;</span>,dst) <span class="hljs-comment"># 保存图片</span><br>cv2.waitKey()  <span class="hljs-comment"># 按下任何键盘按键后</span><br>cv2.destroyAllWindows()  <span class="hljs-comment"># 释放所有窗体</span><br></code></pre></td></tr></table></figure><p><strong>效果</strong>：</p><figure><img src="https://pic.imgdb.cn/item/6622910d0ea9cb140304c68d.jpg"alt="spider3.jpg" /><figcaption aria-hidden="true">spider3.jpg</figcaption></figure><h1 id="总结">总结</h1><p>本实验对图片的腐蚀与膨胀进行学习，腐蚀和膨胀是图像形态学的两种核心操作，通过合理的使用，可以实现图像各类操作。</p><p>参考书籍：《PythonOpenCV从入门到实践》</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>图像</tag>
      
      <tag>学习笔记</tag>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简历的制作与实例-学习笔记</title>
    <link href="/2024/04/18/%E7%AE%80%E5%8E%86%E7%9A%84%E5%88%B6%E4%BD%9C%E4%B8%8E%E5%AE%9E%E4%BE%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/04/18/%E7%AE%80%E5%8E%86%E7%9A%84%E5%88%B6%E4%BD%9C%E4%B8%8E%E5%AE%9E%E4%BE%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="简历的制作">简历的制作</h1><p>个人笔记，仅供学习！</p><p><span id="more"></span></p><h2 id="建立的结构与内容规划">1、建立的结构与内容规划</h2><ul><li>个人信息<ul><li>姓名</li><li>联系方式</li><li>年龄</li><li>所在地</li><li>求职意向</li></ul></li><li>教育背景<ul><li>毕业院校</li><li>学历</li><li>主修专业</li></ul></li><li>工作经历<ul><li>实习</li><li>兼职</li><li>全职</li></ul></li><li>自我评价<ul><li>体现亮点</li></ul></li><li>其他项目<ul><li>项目经历</li><li>奖项荣誉</li><li>技能证书</li></ul></li></ul><p>其他的内容：</p><ul><li><p>求职意向</p></li><li><p>求职地点</p><ul><li>企业可能会看你生活所在地点，如果不符合企业要求，就有可能被刷。——企业希望得到稳定性，不希望你才上几天班就跑路了。</li></ul></li></ul><p>好的简历的标准：——匹配最重要！</p><p><imgsrc="https://pic.imgdb.cn/item/6620d64c0ea9cb1403f34cf0.jpg" /></p><p>其他细节：</p><ul><li>结构简单、条理清晰</li><li>简洁-<ul><li>一张纸</li></ul></li><li>重点和优势突出<ul><li>提炼核心内容</li><li>成果、产出</li></ul></li><li>数值化的呈现<ul><li>可信度会变高</li><li>专业性会变强</li></ul></li><li>匹配度（最重要）<ul><li>与目标公司、目标岗位要匹配</li><li>不然人家凭什么要你？</li></ul></li></ul><h2 id="基本信息">2、基本信息</h2><ul><li><p>不一定要很全面，但是一定要够清楚！</p></li><li><p>尽量不要用生活照片，看你的求职公司是否严肃，选择适合的照片。有的公司可能就会看你是不是够活泼~</p></li><li><p>证件照，秒了~但是照片也不一定是必要的。</p></li><li><p>电话📞、联系方式一点要有！</p></li><li><p>结合目标岗位提出你的求职意向，看菜下饭。</p></li><li><p>机灵点，你在厦门招聘，求职意向地点你就写厦门，在哪里就写哪里。</p></li></ul><h2 id="教育背景">3、教育背景</h2><ul><li><p>教育经历，学会断句。</p></li><li><p>学会用排版、<strong>加粗</strong>、<em>斜体</em>、<u>下划线</u>、等文本格式来帮助自己，突出自己的优势。</p></li></ul><h2 id="实习经历-在校经历">4、实习经历-在校经历</h2><ol type="1"><li>实习单位介绍<ol type="1"><li>将你工作单位进行简单介绍</li><li>让用人单位知道你原来地方，<strong>你原来的平台的好坏</strong>。</li><li>聪明点，如果好你就写多点，不好你就不写或者略写。</li></ol></li><li>岗位职责描述<ol type="1"><li>讲清楚你做了什么</li><li>没什么不好意思的，大白话简单讲清楚就好</li></ol></li><li>工作成果展示<ol type="1"><li>你工作的成果<ol type="1"><li>老板最喜欢你给他创造价值，你要把你工作的成果，体现出来。</li><li>没有也没关系，体现你已经掌握了哪些能力、了解过哪些信息，这会更快让你融入企业。</li></ol></li></ol></li><li>技能应用实践<ol type="1"><li>学到什么，掌握了什么</li><li>大体就一个原则：<strong>你会什么、能节约多少时间或者节省多少资源</strong>。</li></ol></li><li>学习收获总结</li></ol><p>写作的过程一样，注重排版！</p><p><imgsrc="https://pic.imgdb.cn/item/6620d64c0ea9cb1403f34d6a.jpg" /></p><p><strong>！！！</strong>：你的简历一定是真实的、有效的。如果你没有经历，或者经历少，就多去参加活动，<strong>一定要诚实！！！</strong>。</p><p><strong>写作套路</strong>：量化、结果、收获</p><p><strong>排版</strong>：突出重点</p><h3 id="工作经历">工作经历</h3><p>近五年是否够稳定，是否会经常辞职。</p><p>不够稳定的话，对公司来说，会浪费时间再去找人。</p><h2 id="技能">5、技能</h2><ul><li>计算机技能<ul><li>熟练掌握办公软件，可以去写你会哪些<strong>高级</strong>函数。</li><li>现在不会没事，这个可以学的</li></ul></li><li>语言能力<ul><li>四六级证书</li><li>你的英语使用场景</li></ul></li><li>证书资格<ul><li>与岗位匹配</li><li>含金量高的写！</li><li>别学网上的，写巴拉巴拉啥的，很chun</li></ul></li><li>实践经验<ul><li>体现自己的能力</li><li>可以主要写自己，在这段经历里，主要的成就、效果、担任的身份。</li></ul></li></ul><h2 id="自我评价">6、自我评价</h2><p>可以从一下几个方面来讲，择优挑选：</p><ol type="1"><li><p>从业背景</p></li><li><p>创意能力强</p></li><li><p>沟通能力</p></li><li><p>业务能力</p></li><li><p>其他-兴趣爱好</p></li></ol><h2 id="常见问题与细节">常见问题与细节</h2><ul><li>格式花哨、复杂或太过简单；</li><li>不要有错别字；</li><li>想表达的内容不够清晰，没有分点；</li><li>少用含糊不清的词。不要让HR做阅读理解！</li><li>写清自己的任职需求；看菜下饭；</li><li>多用数据，突出自己的成果量化；</li><li>方便阅读，多用短句，便于阅读；</li><li>导出为PDF；PDF最稳定！</li><li>命名细节：命名格式：“姓名+性别+岗位+联系方式📞电话号码”</li><li>懂礼貌，没中也没事，做人一点更要懂礼貌；</li><li>掌握发送的时间。别大半夜的发，很没礼貌，第一映像减分；</li><li>针对不同岗位，准备不同的简历；</li></ul><p>面试技巧：</p><ul><li>在简历上用词要严谨；比如：我熟练使用python，熟练Java语言，了解C语言；</li><li>当面试官问你C语言，你就可以说一两句C语言，然后跟一句，：“我熟悉Java、python”，这样把话题引向自己熟悉的领域。更不会尴尬。</li></ul>]]></content>
    
    
    <categories>
      
      <category>简历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>简历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机视觉-图像视觉实验-实验2</title>
    <link href="/2024/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%9B%BE%E5%83%8F%E8%A7%86%E8%A7%89%E5%AE%9E%E9%AA%8C-%E5%AE%9E%E9%AA%8C2/"/>
    <url>/2024/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%9B%BE%E5%83%8F%E8%A7%86%E8%A7%89%E5%AE%9E%E9%AA%8C-%E5%AE%9E%E9%AA%8C2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>失败是坚忍的最后考验。——俾斯麦</p></blockquote><p><span id="more"></span></p><h2 id="一实验目的">一、实验目的</h2><p>用OpenCV编写一个车辆计数程序，强化对课堂讲授内容如图像腐蚀、轮廓提取、边缘检测、视频读写等知识的深入理解和灵活应用。</p><h2 id="二实验要求">二、实验要求</h2><p>1、用OpenCV编写一个车辆计数程序，对一段视频里道路上的来往车辆进行计数统计，要求避免同一车辆重复统计，并尽量避免漏检、错检；</p><p>2、撰写实验报告，内容包括实验原理、实验过程、关键代码注释、实验结果解释以及实验分析。实验分析部分需要指出实验结果的优劣原因，并提出进一步提高实验性能的方法或手段。</p><p>3、使用Python版的OpenCV编写代码。</p><h2 id="三实验原理">三、实验原理</h2><p>本实验旨在使用OpenCV编写一个车辆计数程序，对一段视频中道路上的车辆进行计数统计。</p><ol type="1"><li><strong>视频读取和预处理</strong>：首先使用cv2.VideoCapture函数读取视频帧，然后将每一帧转换为灰度图像（cv2.cvtColor函数），以便进行后续处理。接下来，对图像进行高斯模糊（cv2.GaussianBlur函数），以去除噪声。</li><li><strong>背景减除</strong>：通过创建一个背景减除器（cv2.createBackgroundSubtractorMOG2函数），可以根据当前帧和之前帧的差异来提取前景物体。使用该背景减除器对预处理后的图像进行处理，得到前景掩码。</li><li><strong>形态学操作</strong>：使用形态学操作对前景掩码进行处理，以去除小斑块和噪声。首先进行腐蚀操作（cv2.erode函数），然后进行<strong>膨胀操作</strong>（cv2.dilate函数），以还原并放大前景物体。接着，进行<strong>闭操作</strong>（cv2.morphologyEx函数），以去除物体内部的小块。</li><li><strong>轮廓提取</strong>：使用cv2.findContours函数从处理后的图像中提取轮廓。得到轮廓后，可以通过计算轮廓的边界矩形（cv2.boundingRect函数）来获取车辆的位置和大小。</li><li><strong>车辆计数</strong>：对每个边界矩形进行宽度和高度的判断，以验证是否为有效的车辆。将有效的车辆用矩形框标记出来，并记录其中心点坐标。如果车辆的中心点通过预设的检测线（line_high）并且满足一定的偏移要求（offset），则将其计数为一辆车辆。最后，显示车辆计数结果和标记后的图像。</li></ol><p><strong>参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>min_w = <span class="hljs-number">90</span><br>min_h = <span class="hljs-number">90</span><br><br><span class="hljs-comment">#检测线的高度</span><br>line_high = <span class="hljs-number">550</span><br><br><span class="hljs-comment">#线的偏移</span><br>offset = <span class="hljs-number">7</span><br><br><span class="hljs-comment">#统计车的数量</span><br>carno =<span class="hljs-number">0</span><br><br><span class="hljs-comment">#存放有效车辆的数组</span><br>cars = []<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">center</span>(<span class="hljs-params">x, y, w, h</span>):<br>    x1 = <span class="hljs-built_in">int</span>(w/<span class="hljs-number">2</span>)<br>    y1 = <span class="hljs-built_in">int</span>(h/<span class="hljs-number">2</span>)<br>    cx = x + x1<br>    cy = y + y1<br><br>    <span class="hljs-keyword">return</span> cx, cy<br><br>cap = cv2.VideoCapture(<span class="hljs-string">&#x27;video.mp4&#x27;</span>)<br><br>bgsubmog =cv2.createBackgroundSubtractorMOG2()<br><span class="hljs-comment">#形态学kernel</span><br>kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    ret, frame = cap.read()<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-literal">True</span>):     <br><br>        <span class="hljs-comment">#灰度</span><br>        cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br>        <span class="hljs-comment">#去噪（高斯）</span><br>        blur = cv2.GaussianBlur(frame, (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), <span class="hljs-number">5</span>)<br>        <span class="hljs-comment">#去背影</span><br>        mask = bgsubmog.apply(blur)<br><br>        <span class="hljs-comment">#腐蚀， 去掉图中小斑块</span><br>        erode = cv2.erode(mask, kernel) <br><br>        <span class="hljs-comment">#膨胀， 还原放大</span><br>        dilate = cv2.dilate(erode, kernel, iterations = <span class="hljs-number">3</span>)<br><br>        <span class="hljs-comment">#闭操作，去掉物体内部的小块</span><br>        close = cv2.morphologyEx(dilate, cv2.MORPH_CLOSE, kernel)<br>        close = cv2.morphologyEx(close, cv2.MORPH_CLOSE, kernel)<br><br>        cnts, h = cv2.findContours(close, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)<br>    <br>        <span class="hljs-comment">#画一条检测线</span><br>        cv2.line(frame, (<span class="hljs-number">10</span>, line_high), (<span class="hljs-number">1200</span>, line_high), (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)<br><br>        <span class="hljs-keyword">for</span> (i, c) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(cnts):<br>            (x,y,w,h) = cv2.boundingRect(c)<br><br>            <span class="hljs-comment">#对车辆的宽高进行判断</span><br>            <span class="hljs-comment">#以验证是否是有效的车辆</span><br>            isValid = ( w &gt;= min_w ) <span class="hljs-keyword">and</span> ( h &gt;= min_h) <br>            <span class="hljs-keyword">if</span>( <span class="hljs-keyword">not</span> isValid):<br>                <span class="hljs-keyword">continue</span><br><br>            <span class="hljs-comment">#到这里都是有效的车 </span><br>            cv2.rectangle(frame, (x, y), (x+w, y+h), (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br>            cpoint = center(x, y, w, h)<br>            cars.append(cpoint) <br>            cv2.circle(frame, (cpoint), <span class="hljs-number">5</span>, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>), -<span class="hljs-number">1</span>)<br><br>            <span class="hljs-keyword">for</span> (x, y) <span class="hljs-keyword">in</span> cars:<br>                <span class="hljs-keyword">if</span>( (y &gt; line_high - offset) <span class="hljs-keyword">and</span> (y &lt; line_high + offset ) ):<br>                    carno +=<span class="hljs-number">1</span><br>                    cars.remove((x , y ))<br>                    <span class="hljs-built_in">print</span>(carno)<br>        <br>        cv2.putText(frame, <span class="hljs-string">&quot;Cars Count:&quot;</span> + <span class="hljs-built_in">str</span>(carno), (<span class="hljs-number">500</span>, <span class="hljs-number">60</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="hljs-number">2</span>, (<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-number">5</span>)<br>        cv2.imshow(<span class="hljs-string">&#x27;video&#x27;</span>, frame)<br>        <span class="hljs-comment">#cv2.imshow(&#x27;erode&#x27;, close)</span><br>    <br>    key = cv2.waitKey(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span>(key == <span class="hljs-number">27</span>):<br>        <span class="hljs-keyword">break</span><br><br>cap.release()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><h2 id="四实验结果">四、实验结果</h2><h3 id="实验部分视频"><strong>实验部分视频：</strong></h3><p><imgsrc="https://pic.imgdb.cn/item/661f927d0ea9cb1403af857c.gif" /></p><h3 id="实验部分结果"><strong>实验部分结果：</strong></h3><p><imgsrc="https://pic.imgdb.cn/item/661f92c50ea9cb1403b1b11e.gif" /></p><ol type="1"><li><strong>视频显示</strong>：</li></ol><p>视频应该会显示当前帧处理后的图像，其中车辆被红色矩形框标注，并且车辆中心点会用红点表示。</p><p>会有一条蓝绿色的线（检测线）在视频帧的 <em>line_high</em>位置画出。</p><ol start="2" type="1"><li><strong>车辆计数</strong>：</li></ol><p>当车辆通过检测线时，<em>carno</em>数字会增加，并且车辆通过的计数会在视频帧上的左上角显示，格式为<em>"CarsCount: 数字"</em>。</p><p>每当有车辆通过检测线时，程序将在终端输出当前的车辆总数。</p><h2 id="五实验分析">五、实验分析</h2><ol type="1"><li><strong>背景减除的效果</strong>:</li></ol><p>背景减除是用来分离前景（移动的车辆）和背景（静止的环境）的关键步骤。如果视频中的背景相对静止且车辆有足够的移动，bgsubmog应能够有效地提取车辆作为前景。</p><p>如果视频中有树木摇晃、其他移动物体或者光照变化等动态背景因素，可能会造成误检。</p><ol start="2" type="1"><li><strong>车辆大小筛选</strong>:</li></ol><p>通过设定阈值 min_w 和min_h，代码筛选掉了小于这些尺寸的所有轮廓。这有助于减少噪声和非车辆物体的干扰，但如果有遮挡或车辆距离摄像机太远导致其看起来很小，这些车辆可能会被错误地排除。</p><ol start="3" type="1"><li><strong>形态学操作</strong>:</li></ol><p>腐蚀和膨胀操作旨在清除噪点和填充车辆中的空隙。这些操作通常会提高轮廓检测的质量，但如果参数选择不当，可能导致车辆轮廓的过度腐蚀（变细）或相邻车辆的轮廓融合。</p><ol start="4" type="1"><li><strong>车辆计数逻辑</strong>:</li></ol><p>车辆计数逻辑依赖于检测线和车辆中心点之间的关系。这个简单的方法适用于车流量不密集、车辆间隔明显的场景。在高密度交通或多车道情况下，可能需要更复杂的逻辑来避免重复计数或漏计。</p><ol start="5" type="1"><li><strong>程序的稳定性和性能</strong>:</li></ol><p>检测和计数逻辑运行在一个无限循环中，这种方法适用于实时视频处理。但如果视频中有很多小物体或噪声，增加的计算负担可能导致性能问题，比如延迟或跳帧。</p><ol start="6" type="1"><li><strong>计数的准确性</strong>:</li></ol><p>计数准确性取决于轮廓检测的质量和车辆通过检测线的判断准确性。如果轮廓检测出现误差或车辆中心点的计算不准确，可能会导致计数不准确。</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像</tag>
      
      <tag>计算机视觉</tag>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Learn More, Study Less!》-读书笔记-1</title>
    <link href="/2024/04/17/4-17%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/04/17/4-17%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如果是玫瑰，它总会开花的。——歌德</p></blockquote><span id="more"></span><h1 id="第一部分整体学习策略">第一部分：整体学习策略</h1><p>The Holistic Learning Strategy</p><h4 id="什么是整体学习">什么是整体学习？</h4><ol type="1"><li>整体学习是一种学习理论，它更准确地描述了你的大脑是如何工作的；</li><li>整体学习是死记硬背的对立面。</li><li>整体学习创建<strong>信息网络</strong>。一个想法与另一个想法相关。这种想法的相互联系使你可以轻松地通过完整的理解进行导航。</li></ol><hr /><h4 id="在整体学习中该如何学习">在整体学习中，该如何学习？</h4><ol type="1"><li>在整体学习中，思想不是<strong>孤立地</strong>学习的。</li><li>学习任何东西都需要<strong>联想</strong>。你可以建立更多的<strong>联想</strong>，这些联想<strong>越强大</strong>，效果就<strong>越好</strong>；</li><li>整体学习者不会采取如此有组织的方式来存储信息（这也许可以解释为什么如此多的聪明人组织能力很差）。相反，整体学习者将一切联系起来。</li></ol><p>当然，当你看不到其他选择时，死记硬背似乎是有道理的。</p><p>死记硬背是粗糙和低效的，但它仍然<strong>比没有好</strong>。</p><hr /><h4 id="人的大脑如何储存信息">人的大脑如何储存信息？</h4><p>人的大脑靠的是数以千亿的神经元相互连接构成的，思考、记忆等等大脑活动离不开神经元的参与。</p><p>当然，科学还有很长的路要走，才能发现大脑中的物理联系。整体学习只是建议了一种看待聪明人如何学习的方法。</p><hr /><h1 id="整体学习的三个主要思想">整体学习的三个主要思想</h1><ol type="1"><li><strong>Constructs</strong></li><li><strong>Models</strong></li><li><strong>Highways</strong></li></ol><p>1）构造2）模型3）高速公路</p><h1 id="constructs">Constructs</h1><p>想象一个结构就像你头脑中的城市一样。在一个城市中，你有成千上万的建筑物，你可以在其中旅行。有些是大的和重要的，通过道路连接到你的城市中的数百个其他建筑物。其他不那么重要，只有几条小路通往它们。</p><p><br /></p><p>在你的知识背景中，你的脑海中充满了这些城市。你的基本数学和语言技能可能是大型、高效的城市。你没有问题从3+4-10到10*3+7导航。这些问题很容易，因为你的基本数学结构高度发达。</p><p><br /></p><p>而理解，是产生这些高度发展的结构的结果。</p><p><br /></p><p>有没有某些学科你一学就懂？这些学科对你来说很容易理解，似乎显而易见。这可能是因为这些学科属于高度发展的结构。它们就像城市一样，道路干净，没有交通拥堵。建筑物得到维护，很少有整个路径被封锁。</p><p>相反，有些主题你很难理解。这些就像新建或设计糟糕的城市。道路通向很多地方。很容易迷路，还有许多建筑需要存在，但尚未建成，或者迷失在道路和错误的方向中。</p><p>问问自己这个问题：在一个城市中，哪座建筑最容易找到？</p><p>A）通过数百条道路与其他建筑相连的建筑；</p><p>B）只有一条泥土小路连接到另一座建筑的建筑。</p><p>A中的建筑更容易找到。如果你走错了路，你最终到达目的地不会有太多麻烦。</p><p>在B的情况下，你依靠的是你偶然发现唯一与最终目的地相连的建筑。</p><p><br /></p><blockquote><p>When building constructs, your goal is to create as many possibleinterconnections as possible between ideas. Smart people tend to do thisprocess naturally. As each concept comes up, it is automatically linkedwith other ideas.</p></blockquote><p>在构建建筑时，你的目标是在想法之间创造尽可能多的相互联系。聪明的人往往会自然地这样做。每当一个概念出现时，它就会自动与其他想法联系起来。</p><p><br /></p><blockquote><p>Your constructs weren't built in a day. There is no magical techniqueto immediately “get” any subject. Having a powerful construct comes fromlinking concepts together, one idea at a time.</p></blockquote><p>你的构建不是一天建成的。没有神奇的技术可以立即“得到”任何主题。拥有强大的构建来自将概念联系在一起，一次一个想法。</p><h1 id="models">Models</h1><p>如果说构建是整体学习的大门，那么模型就是关键。</p><p>模型是简化的构建。</p><p>它们是更大理解的快照，旨在便携和易于存储。</p><p>当试图快速学习新概念时，模型是必不可少的。</p><p><br /></p><p><strong>模型</strong>可以采取各种形式。</p><p>然而，目标总是相同的：<strong>压缩信息</strong>。</p><p>通过采取几个核心概念并将它们连接成一个形式，您就可以创建一个模型。</p><ul><li>模型不需要有完美的准确性，它们只需要结合几个想法，使它们更易于管理。</li><li>一旦我有了一个新的结构，我就可以建立这种理解，并纠正任何错误。</li></ul><p>模型的解释：</p><blockquote><p>通过主观意识借助实体或者虚拟表现，构成客观阐述形态结构的一种表达目的的物件（物件并不等于物体，不局限于实体与虚拟、不限于平面与立体）。</p><p>——百度百科</p></blockquote><p><br /></p><h3 id="模型的分类"><strong>模型的分类</strong></h3><ul><li>数学模型<ul><li>代数方程</li><li>微分方程</li><li>几何、数理逻辑等</li></ul></li><li>物理模型<ul><li>实物模型</li><li>类比模型</li></ul></li><li>结构模型</li><li>工业模型</li><li>仿真模型<ul><li>计算机、模拟计算机、混合计算机运行的程序表达的模型。</li></ul></li><li>人力资源模型</li><li>思维模型</li></ul><p><br /></p><p>模型将几个关键思想存储在一个图像或概念中。这种压缩形成了未来理解的种子，可以<u>链接</u>和<u>细化</u>。</p><p>模型不需要是图像。它只需要是一种现有的理解，将几个关键思想压缩到一个模型中。</p><p>可视化只是其中一种方法。</p><p>模型不需要建立在特定的图像上，可以是你已经掌握的概念。通过一个构造为另一个构造提供工具来建立模型。</p><h1 id="highways">Highways</h1><p>Constructs建立在连接建筑物的道路上。</p><p>虽然拥有数百条城际公路是有用的，但它没有利用你整体大脑的真正力量。为了做到这一点，你需要添加高速公路：<strong>孤立构建之间的联系。</strong></p><p><br /></p><p>一条高速公路是连接两个完全不同想法的参考。如果你正在阅读一本生物学教科书，并从你正在学习的商业课程中进行比较，那将是一条高速公路。</p><p><br /></p><p>高速公路的好处不是立竿见影的。</p><p>如果你想在学校取得成功，大多数老师都会强调要有明确的结构，而不是大脑里装满高速公路。</p><p><strong>然而，高速公路有助于创造力。</strong></p><p><strong>创造力</strong>可以被看作是能够利用这些高速公路，在以前空无一物的领土中建立新的结构。</p><p><br /></p><p>作为一个学习者，建立高速公路可以给你更多的灵活性。通常，如果你不明白老师教课的方式，你就会完全迷失方向。有了高速公路，你可以从<strong>不同的学科</strong>中导入自己的<strong>理解</strong>。</p><p>从而来帮助自己理解概念。</p><p>常见的结构有：</p><ul><li>感官结构</li><li>关系结构</li><li>基本数学结构</li></ul><p>这些结构的灵活引入，可以加快我们理解知识点。</p>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
      <category>《learn-more-study-less》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swin Transformer：使用偏移窗口的分层视觉变换器</title>
    <link href="/2024/04/16/Swin-Transformer/"/>
    <url>/2024/04/16/Swin-Transformer/</url>
    
    <content type="html"><![CDATA[<p>Swin Transformer: Hierarchical Vision Transformer using ShiftedWindows</p><h2 id="摘要">摘要</h2><p>本论文提出了一种名为SwinTransformer的新型视觉Transformer模型，它能够作为通用的计算机视觉骨干网络。</p><span id="more"></span><p>从语言到视觉的Transformer模型的适应性挑战源于两个领域之间的差异，如视觉实体的尺度变化较大以及图像中像素的高分辨率相对于文本中的单词。为了解决这些差异，我们提出了一种分层Transformer，其表示是通过<em>偏移窗口</em>计算的。偏移窗口方案通过将自注意力计算限制<strong>在非重叠的本地窗口内</strong>，同时也允许跨窗口连接，从而带来了更高的效率。这种分层架构具有在不同尺度上建模的灵活性，并且在图像大小方面具有<em>线性的计算复杂度</em>。SwinTransformer的这些特性使其与广泛范围的视觉任务兼容，包括图像分类（在ImageNet-1K上的87.3的top-1准确度）以及密集预测任务，如目标检测（在COCO测试集上的58.7的boxAP和51.1的maskAP）和语义分割（在ADE20K验证集上的53.5的mIoU）。其性能大大超越了先前的最先进技术，分别在COCO上提升了+2.7的boxAP和+2.6的maskAP，并在ADE20K上提升了+3.2的mIoU，显示了基于Transformer的模型作为视觉骨干的潜力。分层设计和偏移窗口方法也对所有MLP架构具有益处。代码和模型可以在<ahref="https://github.com/microsoft/Swin-Transformer">https://github.com/microsoft/Swin-Transformer</a>上公开获取。</p><h2 id="引言">1、引言</h2><p>计算机视觉中的建模长期以来一直由卷积神经网络（CNNs）主导。从AlexNet的问世以及它在ImageNet图像分类挑战中的革命性表现开始，CNN架构通过规模的扩大、连接的加强以及更复杂形式的卷积等方式变得越来越强大。由于CNNs在各种视觉任务中作为骨干网络，这些架构的进步导致了性能的提升，从而广泛推动了整个领域的发展。</p><p>另一方面，在自然语言处理（NLP）中，网络架构的演变走上了一条不同的道路，如今普遍的架构是Transformer。Transformer设计用于序列建模和转录任务，其以使用注意力机制来建模数据中的长距离依赖关系而引人注目。它在语言领域取得了巨大的成功，这导致研究人员研究如何将其应用于计算机视觉，最近在特定任务上取得了有希望的结果，特别是在图像分类和联合视觉-语言建模方面。</p><p>在本论文中，我们试图扩展Transformer的适用性，使其能够像在NLP中一样成为计算机视觉的通用骨干网络，就像CNN在视觉中一样。我们观察到，在将其在语言领域的高性能转移到视觉领域时，存在着显著的挑战，这可以通过两种模态之间的差异来解释。其中之一涉及到尺度。与在语言Transformer中作为处理基本单元的单词标记不同，视觉元素的尺度可以有很大的变化，这在诸如目标检测等任务中受到关注。在现有的基于Transformer的模型中，标记都是固定尺度的，这在视觉应用中不合适。另一个差异是图像中像素的分辨率要比文本段落中的单词高得多。存在许多像语义分割这样的视觉任务需要在像素级别进行密集预测，对于高分辨率图像来说，这将变得棘手，因为其自注意力的计算复杂度与图像尺寸的平方成正比。</p><p><strong>为了克服这些问题</strong> ，我们提出了一个名为SwinTransformer的通用Transformer骨干网络，它构建了分层特征图，并具有线性的图像大小计算复杂度。如<ahref="#图1">图1(a)</a>所示，SwinTransformer通过从小尺寸的图块开始（用灰色轮廓标出）并逐渐合并深层Transformer层中的相邻图块来构建分层表示。借助这些分层特征图，SwinTransformer模型可以方便地利用高级技术进行像素级别的密集预测，如特征金字塔网络（FPN）或U-Net。通过在划分图像的非重叠窗口内局部计算自注意力来实现线性的计算复杂度（用红色轮廓标出）。每个窗口中的图块数量是固定的，因此复杂度变为与图像大小成线性关系。这些优点使得SwinTransformer能够成为各种视觉任务的通用骨干网络，与之前的基于Transformer的架构形成对比，后者只能生成单一分辨率的特征图，并具有二次复杂度。</p><p><img src="https://pic.imgdb.cn/item/661e0a7c0ea9cb1403e039f2.png" alt="tu_1" style="zoom:67%;" /></p><div data-align="center"><strong><a name="图1">图1. (a) 提出的SwinTransformer通过在更深的层次中合并图像块（灰色显示）来构建分层特征图，并且由于仅在每个本地窗口内计算自注意力（红色显示），它对输入图像大小具有线性的计算复杂度。因此，它可以作为图像分类和密集识别任务的通用骨干网络。(b) 相比之下，先前的视觉Transformer [20]生成单一低分辨率的特征图，并且由于在全局范围内计算自注意力，对输入图像大小具有二次计算复杂度。</a></strong></div><p>SwinTransformer的一个关键设计元素是在连续的自注意层之间移动窗口划分，如<ahref="#图2">图2</a>所示。</p><p><img src="https://pic.imgdb.cn/item/661e0a7d0ea9cb1403e03aa9.png" alt="img" style="zoom: 33%;" /></p><div data-align="center"><strong><a name="图2">图2. 展示了在提议的SwinTransformer架构中计算自注意力的移位窗口方法。在第l层（左侧），采用了常规的窗口分区方案，并在每个窗口内计算自注意力。在下一层l+1（右侧），窗口分区被移位，产生了新的窗口。在新窗口中的自注意力计算穿越了第l层中先前窗口的边界，从而在它们之间建立了连接。</a></strong></div><p>移动的窗口连接了前一层的窗口，提供了它们之间的连接，显著增强了建模能力（参见<ahref="#表4">表4</a>）。这种策略在实际应用的延迟方面也很高效：<u>窗口内的所有查询块共享相同的键集</u>，这有利于硬件中的内存访问。相比之下，早期基于滑动窗口的自注意方法在一般硬件上存在延迟较低的问题，因为不同的查询像素有不同的键集。我们的实验证明，所提出的移动窗口方法比滑动窗口方法具有更低的延迟，但在建模能力上类似（见<ahref="#表5">表5</a>和<ahref="#表6">表6</a>）。<em>移动窗口方法也对所有MLP架构具有益处</em>。</p><p>所提出的SwinTransformer在图像分类、目标检测和语义分割等识别任务上取得了强劲的性能。它在这三个任务上的性能显著优于ViT/ DeiT [20, 63] 和ResNe(X)t模型 [30,70]，并且具有类似的延迟。其在COCO测试集的58.7的box AP和51.1的maskAP超过了先前最先进的结果，分别提高了+2.7的box AP（无外部数据的Copy-paste[26]）和+2.6的mask AP（DetectoRS[46]）。在ADE20K语义分割任务中，它在验证集上获得了53.5的mIoU，比先前最先进的SETR[81]提高了+3.2的mIoU。在ImageNet-1K图像分类任务中，它实现了87.3%的top-1准确度。</p><p>我们相信，在计算机视觉和自然语言处理之间采用统一的架构可以使两个领域受益，因为它将便于对视觉和文本信号进行联合建模，并且可以更深入地共享两个领域的建模知识。我们希望SwinTransformer在各种视觉问题上的优异性能可以在社区中深化这种信念，并鼓励对视觉和语言信号进行统一建模。</p><h2 id="相关工作">2、 相关工作</h2><p><strong>CNN及其变体</strong>CNN（卷积神经网络）在整个计算机视觉领域作为标准网络模型。虽然CNN已经存在了几十年[40]，但直到AlexNet的引入[39]，CNN才起飞并成为主流。自那时以来，人们提出了更深层次、更有效的卷积神经网络架构，进一步推动了计算机视觉中的深度学习浪潮，例如VGG[52]、GoogleNet [57]、ResNet [30]、DenseNet [34]、HRNet[65]和EfficientNet [58]等。</p><p>除了这些架构的进步，还有许多关于改进单个卷积层的工作，如深度卷积[70]和可变形卷积[18,84]。虽然CNN及其变体仍然是计算机视觉应用的主要骨干架构，但我们强调了类似Transformer的架构在视觉和语言之间进行统一建模的巨大潜力。我们的工作在几个基本的视觉识别任务上取得了强劲的性能，我们希望它能对模型的发展方向做出一定的贡献。</p><p><strong>基于自注意力的骨干网络架构</strong>受到自注意力层和Transformer在自然语言处理领域的成功启发，一些研究利用自注意力层来替代流行的ResNet中的一些或全部空间卷积层[33,50,80]。在这些研究中，自注意力是在每个像素的局部窗口内计算的，以加速优化过程[33]，并且它们在准确性和计算量之间取得了稍微更好的平衡，相比于ResNet架构。然而，它们昂贵的内存访问导致了实际延迟明显大于卷积网络[33]。我们提出了在连续层之间移动窗口的方法，而不是使用滑动窗口，这使得在通用硬件上能够更高效地实现。</p><p><strong>自注意力/Transformer以补充CNN</strong>另一方面，一些工作尝试将标准的CNN架构与自注意力层或Transformer相结合。自注意力层可以通过提供编码远程依赖关系或异质交互的能力来增强骨干网络[67,7, 3, 71, 23, 74, 55]或头部网络[32,27]。最近，Transformer中的编码-解码设计已经应用于目标检测和实例分割任务[8,13, 85,56]。我们的工作探索了将Transformer用于基本视觉特征提取的适应性，与这些工作相辅相成。</p><p><strong>基于Transformer的视觉骨干网络</strong>与我们的工作最相关的是Vision Transformer（ViT）[20]及其后续研究[63, 72,15, 28,66]。ViT的开创性工作直接将Transformer架构应用于非重叠的中等大小图像块，用于图像分类。与卷积网络相比，它在图像分类方面取得了令人印象深刻的速度-准确性平衡。虽然ViT需要大规模训练数据集（如JFT-300M）才能表现良好，但DeiT[63]引入了一些训练策略，使得ViT在使用较小的ImageNet-1K数据集时也能有效。ViT在图像分类任务上的结果令人鼓舞，但其架构不适用于作为密集视觉任务的通用骨干网络，或者当输入图像分辨率较高时，由于其低分辨率的特征图以及与图像大小成二次方增加的复杂度。</p><p>有一些研究将ViT模型应用于目标检测和语义分割等密集视觉任务，通过直接上采样或反卷积的方式，但性能相对较低[2,81]。与我们同时进行的工作是一些修改ViT架构以获得更好图像分类性能的研究[72,15, 28]。经验上，我们发现我们的SwinTransformer架构在图像分类方面在这些方法中实现了最佳的速度-准确性平衡，尽管我们的工作侧重于通用性能而不是专门分类。</p><p>另一项同时进行的工作[66]探索了一条类似的思路，以在Transformers中构建多分辨率特征图。它的复杂度仍然与图像大小成二次方，而我们的复杂度是线性的，同时也是在本地操作的，这在建模视觉信号中的高相关性方面已被证明是有效的。我们的方法既高效又有效，实现了在COCO目标检测和ADE20K语义分割上的最先进准确性。</p><h2 id="模型">3、 模型</h2><h3 id="总体架构">3.1 总体架构</h3><p><a href="#图3">图3</a>展示了SwinTransformer架构的概览，图中展示了迷你版本（Swin-T）。</p><figure><img src="https://pic.imgdb.cn/item/661e0a7d0ea9cb1403e03b13.png"alt="tu_3" /><figcaption aria-hidden="true">tu_3</figcaption></figure><div data-align="center"><strong><a name="图3">图3. (a) Swin Transformer（Swin-T）的架构；(b)两个连续的SwinTransformer块（使用方程（3）的符号表示）。W-MSA和SW-MSA分别是具有常规和移位窗口配置的多头自注意力模块。</a></strong></div><p>首先，它通过一个补丁分割模块将输入的RGB图像分割成非重叠的补丁，类似于ViT。每个补丁被视为一个“标记”，其特征被设置为原始像素RGB值的连接。在我们的实现中，我们使用了一个4×4的补丁大小，因此每个补丁的特征维度为<span class="math inline">\(4×4×3=48\)</span>。然后，在这个原始值特征上应用一个线性嵌入层，将其投影到一个任意维度（记作<span class="math inline">\(C\)</span> ）。</p><p>对这些补丁标记应用了多个带有修改的自注意力计算的Transformer块（称为SwinTransformer块）。这些Transformer块保持了标记的数量（<spanclass="math inline">\({H\over4} ×{W\over4}\)</span>），与线性嵌入一起被称为“<strong>阶段</strong>1”。</p><p>为了产生一个分层表示，随着网络变得更深，标记的数量通过补丁合并层进行减少。第一个补丁合并层将每组<span class="math inline">\(2×2\)</span>相邻补丁的特征连接起来，并在4C维度的连接特征上应用一个线性层。这将标记的数量减少了<span class="math inline">\(2×2=4\)</span> 倍（分辨率降低了 <spanclass="math inline">\(2\)</span> 倍），输出维度设置为 <spanclass="math inline">\(2C\)</span> 。随后，应用SwinTransformer块进行特征变换，分辨率保持在 <spanclass="math inline">\({H\over8} × {W\over8}\)</span>。这个第一个补丁合并和特征变换的阶段被标记为<strong>“阶段2”</strong>。这个过程重复两次，分别作为<strong>“阶段3”</strong>和<strong>“阶段4”</strong>，输出分辨率分别为<span class="math inline">\({H\over16} × {W\over16}\)</span> 和 <spanclass="math inline">\({H\over32}× {W\over32}\)</span>。这些阶段共同产生了一个分层表示，其特征图分辨率与典型的卷积网络（如VGG[52] 和 ResNet [30]）相同。</p><p>因此，所提出的架构可以方便地替代现有方法中的骨干网络，用于各种视觉任务。</p><p><strong>Swin Transformer块</strong> SwinTransformer通过将Transformer块中的标准多头自注意力（MSA）模块替换为基于移动窗口的模块（在第3.2节中描述），同时保持其他层不变而构建。如<ahref="#图3">图3(b)</a>所示，一个SwinTransformer块包括一个基于移动窗口的MSA模块，后跟一个包含GELU非线性的2层MLP。在每个MSA模块和每个MLP之前都应用了一个LayerNorm（LN）层，并在每个模块后应用了一个残差连接。</p><h3 id="基于移动窗口的自注意力">3.2. 基于移动窗口的自注意力</h3><p>标准的Transformer架构[64]以及其用于图像分类的调整版本[20]都进行全局自注意力计算，其中计算了一个标记与所有其他标记之间的关系。全局计算导致了相对于标记数量的二次复杂度，这使得它在许多需要大量标记进行密集预测或表示高分辨率图像的视觉问题中不适用。</p><p><strong>非重叠窗口内的自注意力</strong></p><p>为了实现高效建模，我们提议在本地窗口内计算自注意力。这些窗口以非重叠的方式均匀划分图像。假设每个窗口包含<span class="math inline">\(M × M\)</span>个补丁，全局MSA模块和基于图像的窗口的计算复杂度分别如下：</p><p><span class="math display">\[Ω(MSA) = 4hwC² + 2(hw)²C，\]</span></p><p><span class="math display">\[Ω(W-MSA) = 4hwC² + 2M²hwC,\]</span></p><p>其中前者相对于补丁数量 <span class="math inline">\(hw\)</span>是二次复杂度，而后者在固定 <span class="math inline">\(M\)</span>（默认为 <span class="math inline">\(7\)</span> ）时是线性的。对于大的<span class="math inline">\(hw\)</span>值，全局自注意力计算通常是无法承受的，而基于窗口的自注意力是可扩展的。</p><p><strong>连续模块中的移动窗口划分</strong>基于窗口的自注意力模块缺乏窗口之间的连接，这限制了其建模能力。为了在保持非重叠窗口的高效计算的同时引入跨窗口连接，我们提出了一种移动窗口划分方法，在连续的SwinTransformer块中交替使用两种划分配置。</p><p>如<ahref="#图2">图2</a>表示，第一个模块使用常规的窗口划分策略，从左上角像素开始，<span class="math inline">\(8×8\)</span> 的特征图被均匀划分成 <spanclass="math inline">\(4×4\)</span> 大小的 <spanclass="math inline">\(2×2\)</span> 窗口（ <span class="math inline">\(M= 4\)</span>）。然后，下一个模块采用了一个窗口配置，它从前一层的配置中移位，通过将窗口从常规划分的窗口中移动（<span class="math inline">\(\lfloor M/2，M/2\rfloor\)</span>）个像素。</p><p><span class="math inline">\(\hat{z}^{l}=W-MSA(LN(z^{l-1}))+z^{l-1},\\\)</span></p><p><span class="math inline">\(z^l=MLP(LN(\hat{z}^l))+\hat{z}^l,\\\)</span></p><p><spanclass="math inline">\(\hat{z}^{l+1}=SW-MSA(LN(z^l))+z^l,\)</span></p><p><spanclass="math inline">\(z^{l+1}=MLP(LN(\hat{z}^{l+1}))+\hat{z}^{l+1},\\\)</span></p><p>这里 <span class="math inline">\(\hat{z}^{l}\)</span> 和 <spanclass="math inline">\({z}^{l}\)</span> 分别表示块 <spanclass="math inline">\(l\)</span> 的 (S)W-MSA 模块和 MLP模块的输出特征；W-MSA 和 SW-MSA分别表示基于常规和移动窗口划分配置的窗口式多头自注意力。</p><p>移动窗口划分方法在前一层中引入了相邻非重叠窗口之间的连接，并在图像分类、目标检测和语义分割等任务中被发现是有效的，如<ahref="#表4">表4</a>所示。</p><p><strong>对于移动配置的高效批处理计算</strong>移动窗口划分的一个问题是它会导致更多的窗口，从 <spanclass="math inline">\(\lceil {h\over M}\rceil \times \lceil {w\overM}\rceil\)</span> 到 <span class="math inline">\((\lceil {h\overM}\rceil+1 )\times (\lceil {w\over M}\rceil+1)\)</span>在移动配置中，其中一些窗口将小于 <span class="math inline">\(M ×M\)</span> 。一个简单的解决方案是将较小的窗口填充到 <spanclass="math inline">\(M × M\)</span>的大小，并在计算注意力时将填充的值屏蔽掉。当常规划分中窗口的数量较小时，例如<span class="math inline">\(2 × 2\)</span>，采用这种简单解决方案会导致显著的增加计算量（<spanclass="math inline">\(2 × 2\rightarrow 3 ×3\)</span>，增加了2.25倍）。</p><p>在这里，我们提出了一种更高效的批处理计算方法，通过向左上方向循环移位，如<ahref="#图4"><strong>图4</strong></a>所示。</p><figure><img src="https://pic.imgdb.cn/item/661e0a7d0ea9cb1403e03b81.png"alt="tu_4" /><figcaption aria-hidden="true">tu_4</figcaption></figure><div data-align="center"><strong>图4.对于在移位窗口分区中的自注意力的高效批处理计算方法的示意图。</strong></div><p>在这种移位后，一个批处理窗口可能由几个在特征图中不相邻的子窗口组成，因此采用了一个掩码机制来限制自注意力计算在每个子窗口内进行。通过循环移位，批处理窗口的数量保持与常规窗口划分相同，因此也是高效的。这种方法的低延迟在<ahref="#表5">表5</a>中显示。</p><p><strong>相对位置偏置</strong> 在计算自注意力时，我们遵循[49, 1, 32,33]的做法，通过在计算相似性时为每个头部添加一个相对位置偏置 <spanclass="math inline">\(B ∈ \R ^{M^2×M^2}\)</span> ：</p><p><span class="math display">\[\text{Attention(Q, K, V)} = \text {SoftMax}(QKᵀ /\sqrt  {d} + B)V,\]</span></p><p>其中 $Q, K, V ∈ <sup>{M</sup>2×d} $ 是查询、键和值矩阵；<spanclass="math inline">\(d\)</span> 是查询/键的维度，<spanclass="math inline">\(M^2\)</span>是窗口中的补丁数量。由于每个轴上的相对位置在范围<spanclass="math inline">\([-M + 1, M -1]\)</span>内，我们将一个尺寸较小的偏置矩阵 <spanclass="math inline">\(\hat{B}∈ \R^{(2M-1)×(2M-1)}\)</span>参数化，并且从 <span class="math inline">\(\hat{B}\)</span> 中取出 <spanclass="math inline">\(B\)</span> 中的值。</p><p>我们观察到相对位置偏置项明显改善了与没有该偏置项或使用绝对位置嵌入的对应模型相比的性能，如<ahref="#表4">表4</a>所示。进一步将绝对位置嵌入添加到输入中（如[20]中所示）会略微降低性能，因此在我们的实现中没有采用这种方法。</p><p>在预训练过程中学到的相对位置偏置也可以用于通过双三次插值[20,63]初始化具有不同窗口大小的模型，以进行微调。</p><h3 id="架构变体">3.3. 架构变体</h3><p>我们构建了我们的基础模型，称为Swin-B，其模型大小和计算复杂度与ViT-B/DeiT-B类似。我们还介绍了Swin-T、Swin-S和Swin-L，它们的模型大小和计算复杂度分别为基础模型的0.25×、0.5×和2×。请注意，Swin-T和Swin-S的复杂度与ResNet-50（DeiT-S）和ResNet-101相似，窗口大小默认设置为<spanclass="math inline">\(M = 7\)</span>。每个头的查询维度为<spanclass="math inline">\(d = 32\)</span>，每个MLP的扩展层为<spanclass="math inline">\(α =4\)</span>，对于所有实验，这些模型变体的架构超参数如下：</p><ul><li>Swin-T: C = 96, 层级数量 = {2, 2, 6, 2}</li><li>Swin-S: C = 96, 层级数量 = {2, 2, 18, 2}</li><li>Swin-B: C = 128, 层级数量 = {2, 2, 18, 2}</li><li>Swin-L: C = 192, 层级数量 = {2, 2, 18, 2}</li></ul><p>这里的 <span class="math inline">\(C\)</span>是第一个阶段隐藏层的通道数。模型大小、理论计算复杂度（FLOPs）以及用于ImageNet图像分类的模型变体的吞吐量详见<ahref="#表1">表1</a>。</p><h2 id="实验">4、 实验</h2><p>我们在ImageNet-1K图像分类[19]、COCO目标检测[43]和ADE20K语义分割[83]上进行了实验。接下来，我们首先将提出的SwinTransformer架构与先前的技术水平进行比较，然后对SwinTransformer的重要设计元素进行了实验验证。</p><h3 id="imagenet-1k上的图像分类">4.1. ImageNet-1K上的图像分类</h3><p><strong>设置：</strong>对于图像分类，我们在ImageNet-1K[19]上评估了提出的SwinTransformer，该数据集包含来自1,000个类别的1.28M训练图像和50K验证图像。我们报告了单个裁剪的top-1准确度。我们考虑了两种训练设置：</p><ul><li><p>常规的ImageNet-1K训练：此设置主要遵循[63]。我们使用AdamW[37]优化器进行300个epoch的训练，使用余弦衰减学习率调度器和20个epoch的线性热身。我们使用批大小为1024，初始学习率为0.001，权重衰减为0.05。在训练中，我们包括了[63]中的大多数增强和正则化策略，但不包括重复的增强[31]和EMA[45]，因为它们并不能提升性能。值得注意的是，这与[63]相反，在ViT的训练中，重复的增强对于稳定训练是至关重要的。</p></li><li><p>在ImageNet-22K上进行预训练，然后在ImageNet-1K上进行微调：我们还在更大的ImageNet-22K数据集上进行预训练，该数据集包含了1420万张图像和22,000个类别。我们使用AdamW优化器进行90个epoch的训练，使用线性衰减学习率调度器和5个epoch的线性热身。我们使用批大小为4096，初始学习率为0.001，权重衰减为0.01。在ImageNet-1K的微调中，我们使用批大小为1024，学习率保持为<spanclass="math inline">\(10^{-5}\)</span>，权重衰减为<spanclass="math inline">\(10^{-8}\)</span>，训练模型30个epoch。</p></li></ul><p><strong>常规ImageNet-1K训练的结果。</strong> 如<ahref="#表1(a)"><strong>表1(a)</strong></a>所示，其中与其他主干网络进行了比较，包括基于Transformer和ConvNet的网络。</p><div data-align="center"><strong><a name="表1">表1.在ImageNet-1K分类任务上不同骨干网络的比较。吞吐量使用[68]的GitHub存储库和V100GPU进行测量，遵循[63]的方法。</a></strong></div><div data-align="center"><strong><a name="表1(a)">(a)使用常规的ImageNet-1K训练的模型</a></strong></div><table><thead><tr class="header"><th>方法</th><th>图像尺寸</th><th>参数数量</th><th>计算量 (FLOPs)</th><th>吞吐量 (图像/秒)</th><th>ImageNet Top-1 准确率</th></tr></thead><tbody><tr class="odd"><td>RegNetY-4G [48]</td><td>224x224</td><td>21M</td><td>4.0G</td><td>1156.7</td><td>80.0</td></tr><tr class="even"><td>RegNetY-8G [48]</td><td>224x224</td><td>39M</td><td>8.0G</td><td>591.6</td><td>81.7</td></tr><tr class="odd"><td>RegNetY-16G [48]</td><td>224x224</td><td>84M</td><td>16.0G</td><td>334.7</td><td>82.9</td></tr><tr class="even"><td>EffNet-B3 [58]</td><td>300x300</td><td>12M</td><td>1.8G</td><td>732.1</td><td>81.6</td></tr><tr class="odd"><td>EffNet-B4 [58]</td><td>380x380</td><td>19M</td><td>4.2G</td><td>349.4</td><td>82.9</td></tr><tr class="even"><td>EffNet-B5 [58]</td><td>456x456</td><td>30M</td><td>9.9G</td><td>169.1</td><td>83.6</td></tr><tr class="odd"><td>EffNet-B6 [58]</td><td>528x528</td><td>43M</td><td>19.0G</td><td>96.9</td><td>84.0</td></tr><tr class="even"><td>EffNet-B7 [58]</td><td>600x600</td><td>66M</td><td>37.0G</td><td>55.1</td><td>84.3</td></tr><tr class="odd"><td>ViT-B/16 [20]</td><td>384x384</td><td>86M</td><td>55.4G</td><td>85.9</td><td>77.9</td></tr><tr class="even"><td>ViT-L/16 [20]</td><td>384x384</td><td>307M</td><td>190.7G</td><td>27.3</td><td>76.5</td></tr><tr class="odd"><td>DeiT-S [63]</td><td>224x224</td><td>22M</td><td>4.6G</td><td>940.4</td><td>79.8</td></tr><tr class="even"><td>DeiT-B [63]</td><td>224x224</td><td>86M</td><td>17.5G</td><td>292.3</td><td>81.8</td></tr><tr class="odd"><td>DeiT-B [63]</td><td>384x384</td><td>86M</td><td>55.4G</td><td>85.9</td><td>83.1</td></tr><tr class="even"><td>Swin-T</td><td>224x224</td><td>29M</td><td>4.5G</td><td>755.2</td><td>81.3</td></tr><tr class="odd"><td>Swin-S</td><td>224x224</td><td>50M</td><td>8.7G</td><td>436.9</td><td>83.0</td></tr><tr class="even"><td>Swin-B</td><td>224x224</td><td>88M</td><td>15.4G</td><td>278.1</td><td>83.5</td></tr><tr class="odd"><td>Swin-B</td><td>384x384</td><td>88M</td><td>47.0G</td><td>84.7</td><td>84.5</td></tr></tbody></table><div data-align="center"><strong><a name="表1(b)">(b) 使用ImageNet-22K预训练的模型</a></strong></div><table><thead><tr class="header"><th>方法</th><th>图像尺寸</th><th>参数数量</th><th>计算量 (FLOPs)</th><th>吞吐量 (图像/秒)</th><th>ImageNet Top-1 准确率</th></tr></thead><tbody><tr class="odd"><td>R-101x3 [38]</td><td>384x384</td><td>388M</td><td>204.6G</td><td>-</td><td>84.4</td></tr><tr class="even"><td>R-152x4 [38]</td><td>480x480</td><td>937M</td><td>840.5G</td><td>-</td><td>85.4</td></tr><tr class="odd"><td>ViT-B/16 [20]</td><td>384x384</td><td>86M</td><td>55.4G</td><td>85.9</td><td>84.0</td></tr><tr class="even"><td>ViT-L/16 [20]</td><td>384x384</td><td>307M</td><td>190.7G</td><td>27.3</td><td>85.2</td></tr><tr class="odd"><td>Swin-B</td><td>224x224</td><td>88M</td><td>15.4G</td><td>278.1</td><td>85.2</td></tr><tr class="even"><td>Swin-B</td><td>384x384</td><td>88M</td><td>47.0G</td><td>84.7</td><td>86.4</td></tr><tr class="odd"><td>Swin-L</td><td>384x384</td><td>197M</td><td>103.9G</td><td>42.1</td><td>87.3</td></tr></tbody></table><hr /><p>与先前的最先进的基于Transformer的架构DeiT [63]相比，SwinTransformer明显超过了复杂度相似的DeiT架构：使用224x224的输入，Swin-T（81.3%）比DeiT-S（79.8%）提高了+1.5%；使用224x224/384x384的输入，Swin-B（83.3%/84.5%）比DeiT-B（81.8%/83.1%）提高了+1.5%/1.4%。</p><p>与最先进的ConvNets，如RegNet [48]和EfficientNet [58]相比，SwinTransformer实现了稍微更好的速度-准确度权衡。值得注意的是，尽管RegNet[48]和EfficientNet [58]是通过彻底的架构搜索得到的，但提出的SwinTransformer是从标准的Transformer进行了改进，具有进一步提升的潜力。</p><p><strong>使用ImageNet-22K预训练的结果</strong>我们还对容量更大的Swin-B和Swin-L进行了ImageNet-22K的预训练。在ImageNet-1K图像分类上进行微调的结果如表1(b)所示。对于Swin-B，ImageNet-22K的预训练带来了1.8%~1.9%的提升，相比于从头开始在ImageNet-1K上训练。与以前在ImageNet-22K预训练的最佳结果相比，我们的模型在速度-准确度权衡方面取得了显著的改进：Swin-B获得了86.4%的top-1准确度，比具有类似推理吞吐量（84.7比85.9图像/秒）和稍低FLOPs（47.0G比55.4G）的ViT高2.4%。更大的Swin-L模型实现了87.3%的top-1准确度，比Swin-B模型好0.9%。</p><h3 id="在coco上进行目标检测">4.2. 在COCO上进行目标检测</h3><p><strong>设置</strong>：我们在COCO2017数据集上进行目标检测和实例分割实验，该数据集包含了118K张训练图片，5K张验证图片和20K张测试图片。我们在验证集上进行了消融研究，并在测试集上进行了系统级别的比较。</p><p>对于消融研究，我们考虑了四种典型的目标检测框架：级联MaskR-CNN、ATSS、RepPoints v2和SparseRCNN。对于这四种框架，我们使用了相同的设置：多尺度训练（将输入调整大小，使较短的一侧在480到800之间，较长的一侧最多为1333）、AdamW优化器（初始学习率为0.0001，权重衰减为0.05，批量大小为16）和3x调度（36个epochs）。</p><p>对于系统级别的比较，我们采用了改进版HTC（标记为HTC++），其中包括instaboost、更强大的多尺度训练、6x调度、soft-NMS和ImageNet-22K预训练模型作为初始化。</p><p>我们将我们的SwinTransformer与标准的ConvNets（如ResNe(X)t）和先前的Transformer网络（如DeiT）进行了比较。比较时，只更改了主干网络，其他设置保持不变。值得注意的是，由于SwinTransformer和ResNe(X)t具有分层特征图，因此它们可以直接应用于上述所有框架。而DeiT只产生单一分辨率的特征图，无法直接应用。为了公平比较，我们按照[81]的方法使用反卷积层为DeiT构建分层特征图。</p><p><strong>与ResNe(X)t的比较：</strong> <ahref="#表2(a)"><strong>表2(a)</strong></a>列出了Swin-T和ResNet-50在四个目标检测框架上的结果。我们的Swin-T架构在模型大小、FLOPs和延迟略大的情况下，带来了稳定的+3.4∼4.2的boxAP增益。</p><p><strong><a href="#表2(b)">表2(b)</a></strong>比较了使用Cascade MaskR-CNN时Swin Transformer和不同模型容量的ResNe(X)t。SwinTransformer实现了51.9的box AP和45.0的maskAP的高检测精度，分别比ResNeXt101-64x4d高出+3.6和+3.3，后者具有相似的模型大小、FLOPs和延迟。</p><p>在改进的HTC框架的更高基线上，实现了52.3的box AP和46.0的mask AP，SwinTransformer的增益也很高，分别为+4.1的box AP和+3.1的mask AP（<strong>见<ahref="#表2(c)">表2(c)</a></strong>）。</p><div data-align="center"><strong><a name="表2">表2. 在COCO目标检测和实例分割任务上的结果。†表示使用了额外的反卷积层来产生分层特征图。*表示使用了多尺度测试。</a></strong></div><div data-align="center"><strong><a name="表2(a)">(a) 不同的框架</a></strong></div><table><thead><tr class="header"><th>方法</th><th>骨干网络</th><th>APbox</th><th>APbox50</th><th>APbox75</th><th>参数数量</th><th>FLOPs</th><th>FPS</th></tr></thead><tbody><tr class="odd"><td>Cascade Mask R-CNN</td><td>R-50</td><td>46.3</td><td>64.3</td><td>50.5</td><td>82M</td><td>739G</td><td>18.0</td></tr><tr class="even"><td>Swin-T</td><td>-</td><td>50.5</td><td>69.3</td><td>54.9</td><td>86M</td><td>745G</td><td>15.3</td></tr><tr class="odd"><td>ATSS</td><td>R-50</td><td>43.5</td><td>61.9</td><td>47.0</td><td>32M</td><td>205G</td><td>28.3</td></tr><tr class="even"><td>Swin-T</td><td>-</td><td>47.2</td><td>66.5</td><td>51.3</td><td>36M</td><td>215G</td><td>22.3</td></tr><tr class="odd"><td>RepPointsV2</td><td>R-50</td><td>46.5</td><td>64.6</td><td>50.3</td><td>42M</td><td>274G</td><td>13.6</td></tr><tr class="even"><td>Swin-T</td><td>-</td><td>50.0</td><td>68.5</td><td>54.2</td><td>45M</td><td>283G</td><td>12.0</td></tr><tr class="odd"><td>Sparse R-CNN</td><td>R-50</td><td>44.5</td><td>63.4</td><td>48.2</td><td>106M</td><td>166G</td><td>21.0</td></tr><tr class="even"><td>Swin-T</td><td>-</td><td>47.9</td><td>67.3</td><td>52.3</td><td>110M</td><td>172G</td><td>18.4</td></tr></tbody></table><div data-align="center"><strong><a name="表2(b)">(b) 不同的骨干网络，使用Cascade MaskR-CNN</a></strong></div><table><thead><tr class="header"><th>骨干网络</th><th>APbox</th><th>APbox50</th><th>APbox75</th><th>APmask</th><th>APmask50</th><th>APmask75</th><th>参数数量</th><th>FLOPs</th><th>FPS</th></tr></thead><tbody><tr class="odd"><td>DeiT-S</td><td>48.0</td><td>67.2</td><td>51.7</td><td>41.4</td><td>64.2</td><td>44.3</td><td>80M</td><td>889G</td><td>10.4</td></tr><tr class="even"><td>R50</td><td>46.3</td><td>64.3</td><td>50.5</td><td>40.1</td><td>61.7</td><td>43.4</td><td>82M</td><td>739G</td><td>18.0</td></tr><tr class="odd"><td>Swin-T</td><td>50.5</td><td>69.3</td><td>54.9</td><td>43.7</td><td>66.6</td><td>47.1</td><td>86M</td><td>745G</td><td>15.3</td></tr><tr class="even"><td>X101-32</td><td>48.1</td><td>66.5</td><td>52.4</td><td>41.6</td><td>63.9</td><td>45.2</td><td>101M</td><td>819G</td><td>12.8</td></tr><tr class="odd"><td>Swin-S</td><td>51.8</td><td>70.4</td><td>56.3</td><td>44.7</td><td>67.9</td><td>48.5</td><td>107M</td><td>838G</td><td>12.0</td></tr><tr class="even"><td>X101-64</td><td>48.3</td><td>66.4</td><td>52.3</td><td>41.7</td><td>64.0</td><td>45.1</td><td>140M</td><td>972G</td><td>10.4</td></tr><tr class="odd"><td>Swin-B</td><td>51.9</td><td>70.9</td><td>56.5</td><td>45.0</td><td>68.4</td><td>48.7</td><td>145M</td><td>982G</td><td>11.6</td></tr></tbody></table><div data-align="center"><strong><a name="表2(c)">(c) 系统级别的比较</a></strong></div><table style="width:100%;"><thead><tr class="header"><th>方法</th><th>mini-val</th><th>test-dev</th><th>参数数量</th><th>FLOPs</th><th>APbox</th><th>APmask</th><th>APbox</th><th>APmask</th></tr></thead><tbody><tr class="odd"><td>RepPointsV2</td><td>*</td><td>*</td><td>185M</td><td>1440G</td><td>55.9</td><td>47.2</td><td>56.0</td><td>47.4</td></tr><tr class="even"><td>Copy-paste</td><td>55.9</td><td>47.2</td><td>185M</td><td>1440G</td><td>56.0</td><td>47.4</td><td>-</td><td>-</td></tr><tr class="odd"><td>Swin-B (HTC++)</td><td>56.4</td><td>49.1</td><td>160M</td><td>1043G</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr class="even"><td>Swin-L (HTC++)</td><td>57.1</td><td>49.5</td><td>284M</td><td>1470G</td><td>57.7</td><td>50.2</td><td>58.7</td><td>51.1</td></tr><tr class="odd"><td>Swin-L (HTC++)*</td><td>58.0</td><td>50.4</td><td>284M</td><td>-</td><td>58.7</td><td>51.1</td><td>-</td><td>-</td></tr></tbody></table><p>关于推理速度，虽然ResNe(X)t是通过高度优化的Cudnn函数构建的，但我们的架构是使用内置的PyTorch函数实现的，并非所有函数都经过了良好的优化。深度优化超出了本文的范围。</p><p><strong>与DeiT的比较：</strong> 使用Cascade MaskR-CNN框架，DeiT-S的性能如<ahref="#表2(b)"><strong>表2(b)</strong></a>所示。Swin-T的结果比DeiT-S高出+2.5的boxAP和+2.3的mask AP，模型大小相似（86M对比80M），推理速度显著更高（15.3FPS对比10.4FPS）。DeiT的推理速度较低主要是因为其对输入图像大小的复杂度为二次方。</p><p><strong>与之前的最先进模型的比较：</strong><ahref="#表2(c)"><strong>表2(c)</strong></a>将我们的最佳结果与之前的最先进模型进行了比较。我们的最佳模型在COCO测试集（test-dev）上实现了58.7的boxAP和51.1的mask AP，比先前的最佳结果分别高出+2.7的box AP（Copy-paste[26]，不使用外部数据）和+2.6的mask AP（DetectoRS [46]）。</p><p><strong>语义分割在ADE20K数据集上的实验设置：</strong> ADE20K [83]是一个广泛使用的语义分割数据集，涵盖了150个语义类别。总共有2.5万张图像，其中2万张用于训练，2千张用于验证，另外3千张用于测试。我们在mmseg[16]中使用UperNet作为基本框架，因为它具有较高的效率。更多细节将在附录中提供。</p><p><strong>结果：</strong><ahref="#表3"><strong>表格3</strong></a>列出了不同方法/骨干网络组合的mIoU、模型大小（#参数）、FLOPs和FPS。</p><div data-align="center"><strong><a name="表3">表3. ADE20K语义分割的结果（在验证集和测试集上）。†表示使用了额外的反卷积层来产生分层特征图。 ‡ 表示该模型在 ImageNet-22K上进行了预训练。</a></strong></div><table><thead><tr class="header"><th>方法</th><th>主干网络</th><th>mIoU (val)</th><th>mIoU (test)</th><th>参数数量</th><th>FLOPs</th><th>FPS</th></tr></thead><tbody><tr class="odd"><td>DANet [23]</td><td>ResNet-101</td><td>45.2</td><td>-</td><td>69M</td><td>1119G</td><td>15.2</td></tr><tr class="even"><td>DLab.v3+ [11]</td><td>ResNet-101</td><td>44.1</td><td>-</td><td>63M</td><td>1021G</td><td>16.0</td></tr><tr class="odd"><td>ACNet [24]</td><td>ResNet-101</td><td>45.9</td><td>38.5</td><td>-</td><td>-</td><td>-</td></tr><tr class="even"><td>DNL [71]</td><td>ResNet-101</td><td>46.0</td><td>56.2</td><td>69M</td><td>1249G</td><td>14.8</td></tr><tr class="odd"><td>OCRNet [73]</td><td>ResNet-101</td><td>45.3</td><td>56.0</td><td>56M</td><td>923G</td><td>19.3</td></tr><tr class="even"><td>UperNet [69]</td><td>ResNet-101</td><td>44.9</td><td>-</td><td>86M</td><td>1029G</td><td>20.1</td></tr><tr class="odd"><td>OCRNet [73]</td><td>HRNet-w48</td><td>45.7</td><td>-</td><td>71M</td><td>664G</td><td>12.5</td></tr><tr class="even"><td>DLab.v3+ [11]</td><td>ResNeSt-101</td><td>46.9</td><td>55.1</td><td>66M</td><td>1051G</td><td>11.9</td></tr><tr class="odd"><td>DLab.v3+ [11]</td><td>ResNeSt-200</td><td>48.4</td><td>-</td><td>88M</td><td>1381G</td><td>8.1</td></tr><tr class="even"><td>SETR [81]</td><td>T-Large‡</td><td>50.3</td><td>61.7</td><td>308M</td><td>-</td><td>-</td></tr><tr class="odd"><td>UperNet</td><td>DeiT-S†</td><td>44.0</td><td>-</td><td>52M</td><td>1099G</td><td>16.2</td></tr><tr class="even"><td>UperNet</td><td>Swin-T</td><td>46.1</td><td>-</td><td>60M</td><td>945G</td><td>18.5</td></tr><tr class="odd"><td>UperNet</td><td>Swin-S</td><td>49.3</td><td>-</td><td>81M</td><td>1038G</td><td>15.2</td></tr><tr class="even"><td>UperNet</td><td>Swin-B‡</td><td>51.6</td><td>-</td><td>121M</td><td>1841G</td><td>8.7</td></tr><tr class="odd"><td>UperNet</td><td>Swin-L‡</td><td><strong>53.5</strong></td><td><strong>62.8</strong></td><td>234M</td><td>3230G</td><td>6.2</td></tr></tbody></table><p>从这些结果可以看出，与计算成本相似的DeiT-S相比，Swin-S的mIoU要高出5.3（49.3比44.0）。它也比ResNet-101高出4.4mIoU，比ResNeSt-101 [78] 高出2.4mIoU。我们的经过ImageNet-22K预训练的Swin-L模型在验证集上达到了53.5mIoU，超过了之前最好的模型，其mIoU高出3.2（SETR [81]的mIoU为50.3，但其模型规模更大）。</p><h3 id="ablation-study">4.4. Ablation Study</h3><p>在这一部分中，我们对所提出的SwinTransformer中的重要设计元素进行了剖析，使用了ImageNet-1K图像分类、COCO目标检测的级联掩蔽R-CNN，以及ADE20K语义分割的UperNet。</p><p><strong>Shifted Windows</strong> <ahref="#表4"><strong>表4</strong></a>报告了在三个任务上对移位窗口方法进行的剖析。</p><div data-align="center"><strong><a name="表4">表格 4.偏移窗口方法和不同位置嵌入方法的消融研究，使用 Swin-T架构在三个基准上进行，不做偏移：所有自注意力模块采用常规窗口划分，不做偏移；abs.pos.: ViT 的绝对位置嵌入项；rel. pos.:默认设置下的相对位置偏置项（参见公式（4））；app.:公式（4）中的第一个缩放的点积项。</a></strong></div><table><thead><tr class="header"><th></th><th>ImageNet</th><th>ImageNet</th><th>COCO</th><th>COCO</th><th>ADE20K</th></tr></thead><tbody><tr class="odd"><td></td><td>top-1</td><td>top-5</td><td><span class="math inline">\(AP^{box}\)</span></td><td><span class="math inline">\(AP^{mask}\)</span></td><td>mIoU</td></tr><tr class="even"><td>无偏移窗口</td><td>80.2</td><td>95.1</td><td>47.7</td><td>41.5</td><td>43.3</td></tr><tr class="odd"><td>偏移窗口</td><td>81.3</td><td>95.6</td><td>50.5</td><td>43.7</td><td>46.1</td></tr><tr class="even"><td>无位置编码</td><td>80.1</td><td>94.9</td><td>49.2</td><td>42.6</td><td>43.8</td></tr><tr class="odd"><td>绝对位置编码</td><td>80.5</td><td>95.2</td><td>49.0</td><td>42.4</td><td>43.2</td></tr><tr class="even"><td>绝对+相对位置编码</td><td>81.3</td><td>95.6</td><td>50.2</td><td>43.4</td><td>44.0</td></tr><tr class="odd"><td>相对位置编码（无应用）</td><td>79.3</td><td>94.7</td><td>48.2</td><td>41.9</td><td>44.1</td></tr><tr class="even"><td>相对位置编码</td><td>81.3</td><td>95.6</td><td>50.5</td><td>43.7</td><td>46.1</td></tr></tbody></table><p>使用移位窗口划分的Swin-T优于在每个阶段都建立在单窗口划分的对应模型，对于ImageNet-1K，top-1准确度提高了+1.1%，对于COCO，boxAP/mask AP提高了+2.8/+2.2，对于ADE20K，mIoU提高了+2.8。</p><p><strong>相对位置偏置</strong> <a href="#表4"><strong>表4</strong></a>还报告了相对位置偏置的剖析。相对位置偏置对于所有三个任务都是有效的，相对于没有位置编码和具有绝对位置嵌入的模型，它们分别提高了+3.3/+3.2box AP，+2.3/+2.9 mask AP和+2.3/+2.9mIoU。这表明了相对位置偏置的有效性。同时值得注意的是，虽然包含绝对位置嵌入可以提高图像分类的准确度（+0.4%），但会降低目标检测和语义分割的准确度（COCO的-0.2box/mask AP，ADE20K的-0.6 mIoU）。</p><p><strong>不同自注意方法</strong> <ahref="#表5"><strong>表5</strong></a>比较了不同自注意计算方法的实际速度以及实现。</p><div data-align="center"><strong><a name="表5">表格5. 在V100GPU上不同自注意力计算方法和实现的实际速度。</a></strong></div><table><thead><tr class="header"><th>方法</th><th>MSA in a stage (ms)S1</th><th>S2</th><th>S3</th><th>S4</th><th>Arch. (FPS)T</th><th>S</th><th>B</th></tr></thead><tbody><tr class="odd"><td>滑动窗口 (朴素)</td><td>122.5</td><td>38.3</td><td>12.1</td><td>7.6</td><td>183</td><td>109</td><td>77</td></tr><tr class="even"><td>滑动窗口 (内核)</td><td>7.6</td><td>4.7</td><td>2.7</td><td>1.8</td><td>488</td><td>283</td><td>187</td></tr><tr class="odd"><td>Performer [14]</td><td>4.8</td><td>2.8</td><td>1.8</td><td>1.5</td><td>638</td><td>370</td><td>241</td></tr><tr class="even"><td>窗口 (无偏移)</td><td>2.8</td><td>1.7</td><td>1.2</td><td>0.9</td><td>770</td><td>444</td><td>280</td></tr><tr class="odd"><td>偏移窗口 (填充)</td><td>3.3</td><td>2.3</td><td>1.9</td><td>2.2</td><td>670</td><td>371</td><td>236</td></tr><tr class="even"><td>偏移窗口 (循环)</td><td>3.0</td><td>1.9</td><td>1.3</td><td>1.0</td><td>755</td><td>437</td><td>278</td></tr></tbody></table><p>我们的循环实现比朴素的填充更具硬件效率，特别是对于更深的阶段。总体而言，它使Swin-T、Swin-S和Swin-B分别提速了13%、18%和18%。</p><p>在四个网络阶段上，基于提议的移位窗口方法构建的自注意模块，在朴素/内核实现上比基于滑动窗口的模块更高效，分别为40.8×/2.5×，20.2×/2.5×，9.3×/2.1×和7.6×/1.8×。总的来说，基于移位窗口的SwinTransformer架构在Swin-T、Swin-S和Swin-B上比基于滑动窗口的变体分别快4.1/1.5、4.0/1.5和3.6/1.5倍。表6比较了它们在三个任务上的准确性，表明它们在视觉建模方面具有相似的准确性。</p><p>与Performer[14]相比，后者是最快的Transformer架构之一（参见[60]），所提出的基于移位窗口的自注意计算和整体的SwinTransformer架构略快（见<ahref="#表5">表5</a>），同时使用Swin-T在ImageNet-1K上比Performer提高了+2.3%的top-1准确度（见<ahref="#表6">表6</a>）。</p><div data-align="center"><strong><a name="表6">表格6.在三个基准测试中，使用不同自注意力计算方法的SwinTransformer的准确度。</a></strong></div><table style="width:100%;"><thead><tr class="header"><th></th><th></th><th>ImageNet</th><th>ImageNet</th><th>COCO</th><th>COCO</th><th>ADE20K</th></tr></thead><tbody><tr class="odd"><td></td><td>Backbone</td><td>top-1</td><td>top-5</td><td><span class="math inline">\(AP^{box}\)</span></td><td><span class="math inline">\(AP^{mask}\)</span></td><td>mIoU</td></tr><tr class="even"><td>滑动窗口</td><td>Swin-T</td><td>81.4</td><td>95.6</td><td>50.2</td><td>43.5</td><td>45.8</td></tr><tr class="odd"><td>表演家 [14]</td><td>Swin-T</td><td>79.0</td><td>94.2</td><td>-</td><td>-</td><td>-</td></tr><tr class="even"><td>移动窗口</td><td>Swin-T</td><td>81.3</td><td>95.6</td><td>50.5</td><td>43.7</td><td>46.1</td></tr></tbody></table><h2 id="结论">5、 结论</h2><p>本文介绍了SwinTransformer，这是一种新的视觉Transformer模型，它生成了一个分层的特征表示，并且相对于输入图像大小具有线性的计算复杂度。SwinTransformer在COCO目标检测和ADE20K语义分割任务上取得了最先进的性能，明显超越了先前的最佳方法。我们希望SwinTransformer在各种视觉问题上的强大性能能够鼓励对视觉和语言信号进行统一建模。</p><p>作为SwinTransformer的关键组成部分，基于移位窗口的自注意力机制在视觉问题上表现出色且高效，我们期待着在自然语言处理领域中进一步研究其应用。</p>]]></content>
    
    
    <categories>
      
      <category>论文翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>论文阅读</tag>
      
      <tag>Swin Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理-直方图分析</title>
    <link href="/2024/04/14/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%88%86%E6%9E%90/"/>
    <url>/2024/04/14/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="图像直方图分析及实验">图像直方图分析及实验</h1><span id="more"></span><p>1.1 使用 OpenCV 统计直方图</p><p>函数 cv2.calcHist 可以帮助我们统计一幅图像的直方图。我们一起来熟悉一下这个函数和它的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cv2.calcHist(images, channels, mask, histSize, ranges, hist, accumulate)<br></code></pre></td></tr></table></figure><ul><li><p><strong>images</strong>：原图像（图像格式为 uint8 或float32）。当传入函数时应该 用中括号 [] 括起来，例如：[img]。</p></li><li><p><strong>channels</strong>：同样需要用中括号括起来，它会告诉函数我们要统计那幅图像的直方图。如果输入图像是灰度图，它的值就是 [0]；如果是彩色图像的话，传入的参数可以是 [0]，[1]，[2] 它们分别对应着通道B，G，R。</p></li><li><p><strong>mask</strong>: 掩模图像。要统计整幅图像的直方图就把它设为None。但是如果你想统计图像某一部分的直方图的话，你就需要制作一个掩模图像，并使用它。（后边有例子）</p></li><li><p><strong>histSize</strong>：BIN的数目。也应该用中括号括起来，例如：[256]。</p></li><li><p><strong>ranges:</strong> 像素值范围，通常为 [0，256]</p></li><li><p><strong>hist</strong>：是一个 256x1的数组作为返回值，每一个值代表了与次灰度值对应的像素点数目。</p></li><li><p><strong>accumulate</strong>：是一个布尔值，用来表示直方图是否叠加。</p></li></ul><hr /><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br> <br>img1 = cv2.imread(<span class="hljs-string">&#x27;28.png&#x27;</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 别忘了中括号 [img],[0],None,[256],[0,256]，只有 mask 没有中括号</span><br>hist1 = cv2.calcHist([img1], [<span class="hljs-number">0</span>], <span class="hljs-literal">None</span>, [<span class="hljs-number">256</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br> <br>img2 = cv2.imread(<span class="hljs-string">&#x27;28.png&#x27;</span>)<br>color = (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-keyword">for</span> i, col <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(color):<br>    histr = cv2.calcHist([img2], [i], <span class="hljs-literal">None</span>, [<span class="hljs-number">256</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br>    plt.subplot(<span class="hljs-number">224</span>), plt.plot(histr, color=col),<br>    plt.xlim([<span class="hljs-number">0</span>, <span class="hljs-number">256</span>]), plt.title(<span class="hljs-string">&#x27;Histogram&#x27;</span>)<br>    <br> <br>plt.subplot(<span class="hljs-number">221</span>), plt.imshow(img1, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;Image1&#x27;</span>)<br>plt.subplot(<span class="hljs-number">222</span>), plt.hist(img1.ravel(), <span class="hljs-number">256</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>]),<br>plt.title(<span class="hljs-string">&#x27;Histogram&#x27;</span>), plt.xlim([<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br>plt.subplot(<span class="hljs-number">223</span>), plt.imshow(cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)), plt.title(<span class="hljs-string">&#x27;Image2&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>效果：</strong></p><figure><img src="https://pic.imgdb.cn/item/661b82f868eb935713d6b96a.png"alt="原图" /><figcaption aria-hidden="true">原图</figcaption></figure><figure><img src="https://pic.imgdb.cn/item/661b848968eb935713d7a6af.png"alt="直方图分析分析" /><figcaption aria-hidden="true">直方图分析分析</figcaption></figure><p><strong>对蓝色变量累积分布图：</strong></p><figure><img src="https://pic.imgdb.cn/item/661b854d68eb935713d80912.png"alt="B变量累积分布图" /><figcaption aria-hidden="true">B变量累积分布图</figcaption></figure><h1 id="直方图均衡">直方图均衡</h1><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>img = cv2.imread(<span class="hljs-string">&#x27;28.png&#x27;</span>,<span class="hljs-number">0</span>)<br>cv2.imshow(<span class="hljs-string">&#x27;img1&#x27;</span>,img)<br><br><span class="hljs-comment"># 直方图均衡</span><br>equ = cv2.equalizeHist(img)<br>res = np.hstack((img,equ))<br><span class="hljs-comment">#stacking images side-by-side</span><br>cv2.imshow(<span class="hljs-string">&#x27;img2&#x27;</span>,res)<br>cv2.waitKey()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p><strong>直方图均衡之前</strong></p><p><imgsrc="https://pic.imgdb.cn/item/661b854d68eb935713d80912.png" /></p><p><strong>直方图均衡后</strong></p><p><imgsrc="https://pic.imgdb.cn/item/661b888668eb935713dc212a.png" /></p><h1 id="总结">总结</h1><p>本实验对图像的直方图进行分析，并进行图片的直方图均衡、直方图分析，了解直方图均衡方法，明白直方图均衡可以很好的均衡图片的像素分布。</p><p>当然本实验也有不足，没能很好地展现直方图均衡前后图片的变化。根据书上的学习可以预先知道，直方图分析可以使得灰度图片变得更清晰可读。</p>]]></content>
    
    
    <categories>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
      <tag>python</tag>
      
      <tag>图像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记</title>
    <link href="/2024/04/13/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/04/13/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="python-平时常用用法">python 平时常用用法</h1><p>待完善。。。</p><span id="more"></span><ul><li><p>字典赋值：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dictname [key] = value<br></code></pre></td></tr></table></figure></p></li><li><p>字符串添加元素：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.join([str1,str2])<br></code></pre></td></tr></table></figure></p></li><li><p>删除字符串中非字母和数字元素：</p><ul><li><p>方法一：isalnum()方法</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">string_value = <span class="hljs-string">&quot;alphanumeric@123__&quot;</span><br>s = <span class="hljs-string">&#x27;&#x27;</span>.join(ch <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> string_value <span class="hljs-keyword">if</span> ch.isalnum())<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure></p><p><strong>输出：</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">alphanumeric123<br></code></pre></td></tr></table></figure></p></li><li><p>方法二：使用正则表达式</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>string_value = <span class="hljs-string">&quot;alphanumeric@123__&quot;</span><br>s=re.sub(<span class="hljs-string">r&#x27;[\W_]+&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, string_value)<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure></p><p><strong>输出：</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">alphanumeric123<br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>字符串转大小写：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;www.runoob.com&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.upper())          <span class="hljs-comment"># 把所有字符中的小写字母转换成大写字母</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.lower())          <span class="hljs-comment"># 把所有字符中的大写字母转换成小写字母</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.capitalize())     <span class="hljs-comment"># 把第一个字母转化为大写字母，其余小写</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.title())          <span class="hljs-comment"># 把每个单词的第一个字母转化为大写，其余小写</span><br></code></pre></td></tr></table></figure></p><p><strong>输出：</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">WWW.RUNOOB.COM<br>www.runoob.com<br>Www.runoob.com<br>Www.Runoob.Com<br></code></pre></td></tr></table></figure></p></li><li><p>字符串删除字符：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;abc:cba&#x27;</span><br>s1 = s[:<span class="hljs-number">3</span>] + s[-<span class="hljs-number">3</span>:]<br><span class="hljs-built_in">print</span>(s1)<br></code></pre></td></tr></table></figure></p><p><strong>输出：</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">abccba<br></code></pre></td></tr></table></figure></p></li><li><p>初始化字典</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化字典 dic ，且所有 key 的初始 value 都为 0</span><br>dic = defaultdict(<span class="hljs-built_in">int</span>)<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>    dic[c] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> t:<br>        dic[c] -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> dic.values():<br>            <span class="hljs-keyword">if</span> val != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></p></li><li><p>排列组合</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># combinations(iterable, r) 函数接受一个可迭代对象 iterable 和一个整数 r，</span><br><span class="hljs-comment"># 返回一个包含所有长度为 r 的组合的可迭代对象。</span><br><span class="hljs-comment"># 组合是不考虑顺序的子集。</span><br><br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations<br><br><span class="hljs-comment"># 语法：combinations(iterable, r)</span><br><br><span class="hljs-comment"># 示例</span><br>iterable = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>r = <span class="hljs-number">2</span><br>result = combinations(iterable, r)<br><br><span class="hljs-comment"># 注意：combinations() 返回的是一个迭代器，需要将其转换为列表或使用循环访问元素</span><br>combinations_list = <span class="hljs-built_in">list</span>(result)<br><span class="hljs-built_in">print</span>(combinations_list)<br></code></pre></td></tr></table></figure></p></li></ul><h1 id="python内置函数">python内置函数</h1><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;"></th><th style="text-align: left;">内置函数</th><th style="text-align: left;"></th><th style="text-align: left;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-abs.html">abs()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-divmod.html">divmod()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-input.html">input()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-open.html">open()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-staticmethod.html">staticmethod()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-all.html">all()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-enumerate.html">enumerate()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-int.html">int()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-ord.html">ord()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-str.html">str()</a></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-any.html">any()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-eval.html">eval()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-isinstance.html">isinstance()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-pow.html">pow()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-sum.html">sum()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-basestring.html">basestring()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-execfile.html">execfile()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-issubclass.html">issubclass()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-print.html">print()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-super.html">super()</a></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-bin.html">bin()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-file.html">file()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-iter.html">iter()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-property.html">property()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/att-tuple-tuple.html">tuple()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-bool.html">bool()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-filter.html">filter()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/att-string-len.html">len()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-range.html">range()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-type.html">type()</a></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-bytearray.html">bytearray()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-float.html">float()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/att-list-list.html">list()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-raw_input.html">raw_input()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-unichr.html">unichr()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-callable.html">callable()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/att-string-format.html">format()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-locals.html">locals()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-reduce.html">reduce()</a></td><td style="text-align: left;">unicode()</td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-chr.html">chr()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-frozenset.html">frozenset()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-long.html">long()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-reload.html">reload()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-vars.html">vars()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-classmethod.html">classmethod()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-getattr.html">getattr()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-map.html">map()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-repr.html">repr()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-xrange.html">xrange()</a></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-cmp.html">cmp()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-globals.html">globals()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-max.html">max()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/att-list-reverse.html">reverse()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-zip.html">zip()</a></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-compile.html">compile()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-hasattr.html">hasattr()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-memoryview.html">memoryview()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-round.html">round()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-__import__.html"><strong>import</strong>()</a></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-complex.html">complex()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-hash.html">hash()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/func-number-min.html">min()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-set.html">set()</a></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-delattr.html">delattr()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-help.html">help()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-next.html">next()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-setattr.html">setattr()</a></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-dict.html">dict()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-hex.html">hex()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python3/python-func-object.html">object()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-slice.html">slice()</a></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-dir.html">dir()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-id.html">id()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-oct.html">oct()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-sorted.html">sorted()</a></td><td style="text-align: left;"><ahref="https://www.runoob.com/python/python-func-exec.html">exec内置表达式</a></td></tr></tbody></table><h1 id="python-abs函数">python abs()函数</h1><h2 id="描述">描述</h2><p>abs() 函数返回数字的绝对值。</p><hr /><h3 id="语法">语法</h3><p>以下是 abs() 方法的语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">( x )</span></span><br></code></pre></td></tr></table></figure><hr /><h3 id="参数">参数</h3><ul><li>x -- 数值表达式。</li></ul><hr /><h3 id="返回值">返回值</h3><p>函数返回x（数字）的绝对值。</p><hr /><h2 id="实例">实例</h2><p>以下展示了使用 abs() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;abs(-45) : &quot;</span>, <span class="hljs-built_in">abs</span>(-<span class="hljs-number">45</span>) <br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;abs(100.12) : &quot;</span>, <span class="hljs-built_in">abs</span>(<span class="hljs-number">100.12</span>) <br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;abs(119L) : &quot;</span>, <span class="hljs-built_in">abs</span>(<span class="hljs-number">119L</span>)<br></code></pre></td></tr></table></figure><p>以上实例运行后输出结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(-<span class="hljs-number">45</span>)</span></span> :  <span class="hljs-number">45</span><br><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-number">100.12</span>)</span></span> :  <span class="hljs-number">100.12</span><br><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-number">119</span>L)</span></span> :  <span class="hljs-number">119</span><br></code></pre></td></tr></table></figure><hr /><h1 id="python-divmod-函数">Python divmod() 函数</h1><p>python divmod()函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a %b)。</p><p>在 python 2.3 版本之前不允许处理复数。</p><h2 id="函数语法">函数语法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">divmod</span><span class="hljs-params">(a, b)</span></span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>a: 数字</li><li>b: 数字</li></ul><h2 id="实例-1">实例</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">&gt;&gt;&gt;<span class="hljs-built_in">divmod</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>) <br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>&gt;&gt;&gt; <span class="hljs-built_in">divmod</span>(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>) <br>(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>) <br>&gt;&gt;&gt; <span class="hljs-built_in">divmod</span>(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>j,<span class="hljs-number">1</span>+<span class="hljs-number">0.5</span>j) <br>((<span class="hljs-number">1</span>+<span class="hljs-number">0</span>j), <span class="hljs-number">1.5</span>j)<br></code></pre></td></tr></table></figure><hr /><h1 id="python-staticmethod-函数">Python staticmethod() 函数</h1><p>python staticmethod 返回函数的静态方法。</p><p>该方法不强制要求传递参数，如下声明一个静态方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> C(object):<br>    <span class="hljs-variable">@staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">arg1, arg2, ...</span>):<br>        ...<br></code></pre></td></tr></table></figure><p>以上实例声明了静态方法 <strong>f</strong>，从而可以实现实例化使用<strong>C().f()</strong>，当然也可以不实例化调用该方法<strong>C.f()</strong>。</p><h2 id="函数语法-1">函数语法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">staticmethod</span><span class="hljs-params">(function)</span></span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>无</li></ul><h2 id="实例-2">实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python # -*- coding: UTF-8 -*-  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">object</span>):    <br><span class="hljs-meta">    @staticmethod    </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;runoob&#x27;</span>);  <br>        <br>C.f();          <span class="hljs-comment"># 静态方法无需实例化 </span><br>cobj = C() <br>cobj.f()        <span class="hljs-comment"># 也可以实例化后调用</span><br></code></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">runoob</span><br><span class="hljs-attribute">runoob</span><br></code></pre></td></tr></table></figure><hr /><h1 id="python-all函数">python all函数</h1><h2 id="描述-1">描述</h2><p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为TRUE，<u>如果是返回 True，否则返回 False。</u></p><p>元素除了是 0、空、None、False 外都算 True。</p><p>函数等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">iterable</span>):<br>  <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> iterable:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> element:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>Python 2.5 以上版本可用。</p><h3 id="语法-1">语法</h3><p>以下是 all() 方法的语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">all</span><span class="hljs-params">(iterable)</span></span><br></code></pre></td></tr></table></figure><h3 id="参数-1">参数</h3><ul><li>iterable -- 元组或列表。</li></ul><h3 id="返回值-1">返回值</h3><p>如果iterable的所有元素不为0、''、False或者iterable为空，all(iterable)返回True，否则返回False；</p><p><strong>注意：</strong>空元组、空列表返回值为True，这里要特别注意。</p><hr /><h2 id="实例-3">实例</h2><p>以下展示了使用 all() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]) <span class="hljs-comment"># 列表list，元素都不为空或0</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>])  <span class="hljs-comment"># 列表list，存在一个为空的元素</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>，<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])      <span class="hljs-comment"># 列表list，存在一个为0的元素</span><br><span class="hljs-literal">False</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>((<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>)) <span class="hljs-comment"># 元组tuple，元素都不为空或0</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>((<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>))  <span class="hljs-comment"># 元组tuple，存在一个为空的元素</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))      <span class="hljs-comment"># 元组tuple，存在一个为0的元素</span><br><span class="hljs-literal">False</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>([])       <span class="hljs-comment"># 空列表</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">all</span>(())       <span class="hljs-comment"># 空元组</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><hr /><h1 id="python-enumerate函数">python enumerate()函数</h1><h2 id="描述-2">描述</h2><p>enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在for 循环当中。</p><p>Python 2.3. 以上版本可用，2.6 添加 start 参数。</p><h3 id="语法-2">语法</h3><p>以下是 enumerate() 方法的语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">enumerate</span><span class="hljs-params">(sequence, [start=<span class="hljs-number">0</span>])</span></span><br></code></pre></td></tr></table></figure><h3 id="参数-2">参数</h3><ul><li>sequence -- 一个序列、迭代器或其他支持迭代对象。</li><li>start -- 下标起始位置的值。</li></ul><h3 id="返回值-2">返回值</h3><p>返回 enumerate(枚举) 对象。</p><hr /><h2 id="实例-4">实例</h2><p>以下展示了使用 enumerate() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>seasons = [<span class="hljs-string">&#x27;Spring&#x27;</span>, <span class="hljs-string">&#x27;Summer&#x27;</span>, <span class="hljs-string">&#x27;Fall&#x27;</span>, <span class="hljs-string">&#x27;Winter&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">enumerate</span>(seasons))<br>[(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Spring&#x27;</span>), (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Summer&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Fall&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Winter&#x27;</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">enumerate</span>(seasons, start=<span class="hljs-number">1</span>))    <span class="hljs-comment"># 下标从 1 开始</span><br>[(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Spring&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Summer&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Fall&#x27;</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Winter&#x27;</span>)]<br></code></pre></td></tr></table></figure><h3 id="普通的-for-循环">普通的 for 循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>i = <span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>seq = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> seq:<br><span class="hljs-meta">... </span>  <span class="hljs-built_in">print</span> i, seq[i]<br><span class="hljs-meta">... </span>  i += <span class="hljs-number">1</span><br>...<br><span class="hljs-number">0</span> one<br><span class="hljs-number">1</span> two<br><span class="hljs-number">2</span> three<br></code></pre></td></tr></table></figure><h3 id="for-循环使用-enumerate">for 循环使用 enumerate</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>seq = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i, element <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(seq):<br><span class="hljs-meta">... </span>  <span class="hljs-built_in">print</span> i, element<br>...<br><span class="hljs-number">0</span> one<br><span class="hljs-number">1</span> two<br><span class="hljs-number">2</span> three<br></code></pre></td></tr></table></figure><hr /><h1 id="python-ord-函数">Python ord() 函数</h1><hr /><h2 id="描述-3">描述</h2><p>ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr()函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python定义范围，则会引发一个 TypeError 的异常。</p><h3 id="语法-3">语法</h3><p>以下是 ord() 方法的语法:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-variable">c</span>)</span><br></code></pre></td></tr></table></figure><h3 id="参数-3">参数</h3><ul><li>c -- 字符。</li></ul><h3 id="返回值-3">返回值</h3><p>返回值是对应的十进制整数。</p><hr /><h2 id="实例-5">实例</h2><p>以下展示了使用 ord() 方法的实例：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt;<span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&#x27;a&#x27;</span>) </span><br><span class="hljs-function"><span class="hljs-number">97</span> </span><br><span class="hljs-function">&gt;&gt;&gt; <span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&#x27;b&#x27;</span>)</span><br><span class="hljs-number">98</span> <br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&#x27;c&#x27;</span>) </span><br><span class="hljs-function"><span class="hljs-number">99</span></span><br></code></pre></td></tr></table></figure><hr /><h1 id="python-any-函数">Python any() 函数</h1><hr /><h2 id="描述-4">描述</h2><p>any() 函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回False，<u>如果有一个为 True，则返回 True</u>。</p><p>元素除了是 0、空、FALSE 外都算 TRUE。</p><p>函数等价于：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> <span class="hljs-keyword">any</span>(iterable):<br>    <span class="hljs-keyword">for</span> element in iterable:<br>        <span class="hljs-keyword">if</span> element:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span><br></code></pre></td></tr></table></figure><p>Python 2.5 以上版本可用。</p><h3 id="语法-4">语法</h3><p>以下是 any() 方法的语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">any</span><span class="hljs-params">(iterable)</span></span><br></code></pre></td></tr></table></figure><h3 id="参数-4">参数</h3><ul><li>iterable -- 元组或列表。</li></ul><h3 id="返回值-4">返回值</h3><p>如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true。</p><hr /><h2 id="实例-6">实例</h2><p>以下展示了使用 any() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-built_in">any</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>])  <span class="hljs-comment"># 列表list，元素都不为空或0 </span><br><span class="hljs-literal">True</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>])   <span class="hljs-comment"># 列表list，存在一个为空的元素 </span><br><span class="hljs-literal">True</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>([<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-literal">False</span>])        <span class="hljs-comment"># 列表list,元素全为0,&#x27;&#x27;,false </span><br><span class="hljs-literal">False</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>((<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>))  <span class="hljs-comment"># 元组tuple，元素都不为空或0 </span><br><span class="hljs-literal">True</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>((<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>))   <span class="hljs-comment"># 元组tuple，存在一个为空的元素 </span><br><span class="hljs-literal">True</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>((<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-literal">False</span>))        <span class="hljs-comment"># 元组tuple，元素全为0,&#x27;&#x27;,false </span><br><span class="hljs-literal">False</span>   <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>([]) <span class="hljs-comment"># 空列表 </span><br><span class="hljs-literal">False</span>  <br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">any</span>(()) <span class="hljs-comment"># 空元组 </span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>学习</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理-学习笔记-图像压缩</title>
    <link href="/2024/04/12/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/"/>
    <url>/2024/04/12/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h1id="数字图像处理-学习笔记-图像压缩">数字图像处理-学习笔记-图像压缩</h1><span id="more"></span><h1 id="图像压缩">6.11 图像压缩</h1><h2 id="图像压缩基础知识">图像压缩基础知识</h2><p><strong>首先</strong></p><p>数据 <span class="math inline">\(\neq\)</span> 信息</p><p>数据是信息的载体。</p><blockquote><p>当我们打电话时，电话对面的人和你交流，我们通过电话传输的是电波，是数据，而对面听到的是你说的话，属于信息。</p></blockquote><p>图像压缩就是对数据进行压缩。</p><p>图像压缩很有必要</p><h3 id="可行性">可行性</h3><p>改变图像的描述方式可以变更存储空间。</p><blockquote><p>比如我们可以对原来8个红色的像素表示成<code>8 * R</code>，也就是说，原来我们要用八个格子装红色像素的数据，现在只要两个格子。</p></blockquote><p>上面的例子也就是我们所说的：</p><p><em>图像像素存在着大量冗余</em>。</p><p>当然图像视觉感知也存在冗余——也就是我们人眼对于微小的颜色变化是没有感知的，可以把他们用刚刚的方法缩小存储空间。</p><blockquote><p>人眼会忽略微小差距</p></blockquote><h1 id="冗余分析">6.12 冗余分析</h1><h2 id="冗余分类">冗余分类</h2><ul><li>空间冗余</li><li>时间冗余</li><li>统计冗余</li><li>视觉心理冗余</li></ul><h3 id="对于空间冗余">对于空间冗余</h3><ul><li><p>相邻像素之间存在相关性</p></li><li><p>相应帧之间相关性也很大</p><ul><li>去除冗余的方法：预测、变换</li></ul></li></ul><h3 id="对于统计冗余">对于统计冗余</h3><ul><li>信息熵</li><li>信息量</li><li>熵是平均信息量</li><li>信息量公式：<spanclass="math inline">\(I(x_n)=-log_i(P_n)\)</span></li><li>如果以2为底，单位是：比特</li><li>如果以<span class="math inline">\(e\)</span>为底，单位是：奈特</li><li>如果以<span class="math inline">\(10\)</span>为底，单位是哈特</li><li>信息量怎么解释：<ul><li>你出现的概率越小，你越不寻常，信息量也就更大；</li><li>你出现的概率越大，你越平凡寻常，信息量也就越小。</li></ul></li><li>等概率的熵最大<ul><li>但是我们图片的信息熵不是等概率分布的</li><li>所以可以采用一些方法来减少视觉系统的冗余<ul><li>量化（IGS）</li></ul></li></ul></li></ul><ol type="1"><li>编码方式</li></ol><p>原始图像-&gt;去相关–&gt;量化–&gt;熵编码</p><p>解码–&gt;&gt;熵解码–&gt;&gt;解相关</p><ol start="2" type="1"><li>去相关技术</li></ol><ul><li>基于预测</li><li>基于矢量量化</li><li>基于变换</li><li>基于子带变换</li></ul><ol start="3" type="1"><li>信息熵编码/统计编码：</li></ol><p>利用图像灰度分布统计特性</p><p>均匀的特点，采用不等字长进行编码。</p><h3 id="图像压缩的分类">图像压缩的分类</h3><ul><li>无损压缩-可逆</li><li>有损压缩-不可逆</li></ul><blockquote><p>常见的图片格式：</p><ul><li>\1. JPEG (或JPG)：广泛用于照片和网页图像，支持<strong>有损压缩</strong>，可以减小文件大小。</li><li>\2.PNG：支持透明背景，<strong>无损压缩</strong>，常用于网页设计和图标。</li><li>\3. GIF：支持动画和透明背景，但颜色限制较多（最多256色），常用于简单动画和图标。</li><li>\4.BMP：位图格式，<strong>通常不进行压缩</strong>，因此文件较大，常用于Windows操作系统。</li><li>\5.TIFF：主要用于专业图像存储，支持<strong>无损压缩</strong>和多种颜色深度，常用于印刷行业。</li><li>\6.RAW：相机原始数据格式，未经处理的图像文件，保留了拍摄时的全部信息，适合后期编辑。</li><li>\7. SVG ：矢量图像格式，适合图形设计，可以无限放大而不失真。</li><li>\8.WebP：由Google开发，旨在提供比JPEG更好的压缩，支持<strong>有损和无损压缩</strong>，以及动画和透明度。</li></ul></blockquote><h1 id="实验">实验</h1><p>用python进行实验</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入库</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 读取图像</span><br>image = cv2.imread(<span class="hljs-string">&#x27;1.1.jpg&#x27;</span>)<br>scale_factor = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># 缩小比例，根据需要调整</span><br>image = cv2.resize(image, <span class="hljs-literal">None</span>, fx=scale_factor, fy=scale_factor)<br><br><span class="hljs-comment"># 保存图片为test1.jpg有损压缩</span><br>cv2.imwrite(<span class="hljs-string">&#x27;test1.jpg&#x27;</span>,image)<br><br><span class="hljs-comment"># 读取test1.jpg文件</span><br>image1 = cv2.imread(<span class="hljs-string">&#x27;test1.jpg&#x27;</span>)<br><br><span class="hljs-comment"># 想减查看原图和读取的图片的差别</span><br>sub = image1-image<br><br><span class="hljs-comment"># 输出图片效果</span><br>cv2.imshow(<span class="hljs-string">&quot;resized_image&quot;</span>, image)<br>cv2.imshow(<span class="hljs-string">&quot;image1&quot;</span>, image1)<br>cv2.imshow(<span class="hljs-string">&quot;sub&quot;</span>, sub)<br><br>cv2.waitKey()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><h2 id="实验效果图"><strong>实验效果图</strong></h2><h3 id="原图">原图</h3><figure><img src="https://img2.imgtp.com/2024/04/10/3aCYgxgt.jpg"alt="1.1.jpg" /><figcaption aria-hidden="true">1.1.jpg</figcaption></figure><h3 id="保存后的的jpg格式图片">保存后的的jpg格式图片</h3><figure><img src="https://pic.imgdb.cn/item/6618c64368eb93571317d9bb.jpg"alt="test1.jpg" /><figcaption aria-hidden="true">test1.jpg</figcaption></figure><h3 id="和原图相减后">和原图相减后</h3><figure><img src="https://s21.ax1x.com/2024/04/11/pFXWdhj.jpg" alt="sub.jpg" /><figcaption aria-hidden="true">sub.jpg</figcaption></figure><h2 id="效果分析">效果分析</h2><ul><li><p>可以看出，保存后的结果和原图的差别不大。</p></li><li><p>当我们进行想减，在显示原图后的结果，可以明显看出差别。</p></li><li><p>图像信息丰富的地方失去了一些细节，但是我们的视觉感知不大；</p></li><li><p>而图像复杂度低的地方损失的像素不是很多。</p></li></ul><h1 id="总结">总结</h1><p>本次实验总结了图像压缩的方法、分类，还提出了一些图片保存的格式，以及通过实验来验证了会有损压缩图片的像素，对未来图片的加密、图片处理来说，可能会造成复原噪点、图像损失。</p><p>但是图像压缩对于网站来说是很有必要的，可以加快网站对图片的加载速度。</p>]]></content>
    
    
    <categories>
      
      <category>数字图像处理</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
      <tag>图像</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像加密-DNA运算的图像加密学习</title>
    <link href="/2024/04/10/%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%AF%86-DNA%E8%BF%90%E7%AE%97%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/10/%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%AF%86-DNA%E8%BF%90%E7%AE%97%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="图像加密-dna加密-学习笔记">图像加密-DNA加密-学习笔记</h1><p>本文探究如何对图像二进制编码进行图像DNA加密。</p><p><span id="more"></span></p><blockquote><p>密码学是用于保护数据安全的工具，从古老的凯撒密码到现代密码学，已经两千多年了。脱氧核糖核酸（DNA）是生物遗传物质，携带生命的遗传信息，自从Watson和Crick在1953年发现DNA之后，人们发现和发展了许多操作DNA的方法，同时也发现了DNA计算具有某些电子计算机无可比拟和替代的优越性。密码学和遗传学原本是毫不相关的两个学科。然而，随着现代科技的发展，近年来密码学和DNA开始走到了一起，并且关系越来越密切。</p><p>1994年美国南加州大学的Adleman成功地完成了用DNA计算来解决一个NP完全问题的实验，从而开创了DNA计算研究的新纪元。自此以后，越来越多的目光集中到对这门新兴学科的研究上来，其中包括了不少计算机专家和密码学界的知名人士，他们开始关注DNA计算对密码学及信息安全的影响，开始思考能否在DNA的领域里开辟密码的新天地。</p></blockquote><h2 id="dna加密">DNA加密</h2><p>目前常用的DNA加密，有多种方法，比如：先将图像转化成二进制码，在将他与另一图像，进行二进制<u>相加、相减、同或、异或</u>；</p><blockquote><p><strong>异或（xor）</strong>，是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。</p><ul><li><p>如果a、b两个值不相同，则异或结果为1。</p></li><li><p>如果a、b两个值相同，异或结果为0。</p></li></ul><p><strong>同或（XNOR）</strong>，电路表示则为同或门，双输入若相同则输出为1，不同则输出为0。</p></blockquote><p><strong>举例子：</strong></p><p>对于图像像素来说，每张图片有三种颜色，<strong>RGB</strong>三色(python的opencv在处理图像时，默认处理的顺序是<strong>BGR</strong>，要注意！！)，0~255代表它的亮度。</p><p>每个颜色不同、亮度不同，颜色就不同；</p><p>我们使用八位二进制码，也就是00000000来表示亮度为0，11111111表示亮度为255——也就是最亮，0是最暗也就是全黑。</p><h3 id="预处理">预处理</h3><p>两图像相加，我们要先能保证，他们两张图片宽高长得一样，不然会没得减、或者没能全部覆盖我们要加密的图像。</p><p><strong>预处理代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入库</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 读取彩色图像</span><br>image = cv2.imread(<span class="hljs-string">&#x27;1.1.jpg&#x27;</span>)<br><br><span class="hljs-comment"># 获取图像尺寸</span><br>height, width, _ = image.shape<br>M = height<br>N = width<br><br><span class="hljs-comment"># 将图像拆分为三个通道</span><br>I1 = image[:, :, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 蓝色通道</span><br>I2 = image[:, :, <span class="hljs-number">1</span>]  <span class="hljs-comment"># 绿色通道</span><br>I3 = image[:, :, <span class="hljs-number">2</span>]  <span class="hljs-comment"># 红色通道</span><br><br><span class="hljs-comment"># 找到最大的长宽</span><br><span class="hljs-comment"># 调整图像大小为16的倍数</span><br>max_dim = <span class="hljs-built_in">max</span>(height, width)<br>max_dim = (max_dim + <span class="hljs-number">15</span>) // <span class="hljs-number">16</span> * <span class="hljs-number">16</span>  <span class="hljs-comment"># 向上取整到最近的16的倍数</span><br><br><span class="hljs-comment"># 创建一个新的空白图像</span><br>padded_I1 = np.zeros((max_dim, max_dim), dtype=np.uint8)<br>padded_I2 = np.zeros((max_dim, max_dim), dtype=np.uint8)<br>padded_I3 = np.zeros((max_dim, max_dim), dtype=np.uint8)<br><br><span class="hljs-comment"># 将原始图像放入新的空白图像中</span><br>padded_I1[:M, :N] = I1<br>padded_I2[:M, :N] = I2<br>padded_I3[:M, :N] = I3<br><br>scale_factor = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># 缩小比例，根据需要调整</span><br>padded_I1 = cv2.resize(padded_I1, <span class="hljs-literal">None</span>, fx=scale_factor, fy=scale_factor)<br>padded_I2 = cv2.resize(padded_I2, <span class="hljs-literal">None</span>, fx=scale_factor, fy=scale_factor)<br>padded_I3 = cv2.resize(padded_I3, <span class="hljs-literal">None</span>, fx=scale_factor, fy=scale_factor)<br><br><span class="hljs-comment"># # 分别展示三张通道图片</span><br>cv2.imshow(<span class="hljs-string">&#x27;Bed Channel&#x27;</span>, padded_I1)<br>cv2.imshow(<span class="hljs-string">&#x27;Green Channel&#x27;</span>, padded_I2)<br>cv2.imshow(<span class="hljs-string">&#x27;Rlue Channel&#x27;</span>, padded_I3)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br><br><span class="hljs-comment"># 输出高、宽、补零后的宽</span><br><span class="hljs-built_in">print</span>(height,width,max_dim)<br><span class="hljs-comment"># 保存不同通道的图片(选)</span><br><span class="hljs-comment"># cv2.imwrite(&#x27;lena_blue_channel.bmp&#x27;, padded_I1)</span><br><span class="hljs-comment"># cv2.imwrite(&#x27;lena_green_channel.bmp&#x27;, padded_I2)</span><br><span class="hljs-comment"># cv2.imwrite(&#x27;lena_red_channel.bmp&#x27;, padded_I3)</span><br></code></pre></td></tr></table></figure><figure><img src="https://img2.imgtp.com/2024/04/10/3aCYgxgt.jpg" alt="1.1" /><figcaption aria-hidden="true">1.1</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/o9Zzz4Ec.bmp"alt="l_red_channel" /><figcaption aria-hidden="true">l_red_channel</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/W1EXeJlc.bmp"alt="l_blue_channel" /><figcaption aria-hidden="true">l_blue_channel</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/bwHm8CQA.bmp"alt="l_green_channel" /><figcaption aria-hidden="true">l_green_channel</figcaption></figure><h3 id="相加">相加</h3><p>当两张图像，各自对应的像素相加，就有可能超过八位，所以在python中，我们使用</p><p><code>result = result &amp; 0xFF  # 只保留低8位，相当于取模256</code>或者使用numpy库中的<code>clip</code>方法：</p><p><code>result = np.clip(image1 - image2, 0, 255)</code>来对图像进行处理，防止溢出，说人话，担心出现255+1=256，超出我们定义的范围了，所以我们取模，让他重新回到我们定义的范围里。即：<spanclass="math inline">\((255+1)//256 = 0\)</span>，其中，<spanclass="math inline">\(//\)</span>是取模。</p><h4 id="取模256">取模256</h4><p><strong>代码演示如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入numpy库，重命名为np</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义变量</span><br>result1 = <span class="hljs-number">231</span><br>result2 = <span class="hljs-number">25</span><br><br><span class="hljs-comment"># 转化二进制</span><br>binary_num1 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>(result1), <span class="hljs-number">2</span>)<br>binary_num2 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>(result2), <span class="hljs-number">2</span>) <br><br><span class="hljs-comment"># 相加</span><br>result3 = binary_num1 + binary_num2 <br><br><span class="hljs-comment"># 处理溢出</span><br>result3 = result3 &amp; <span class="hljs-number">0xFF</span>  <span class="hljs-comment"># 只保留低8位，相当于取模256</span><br><br><span class="hljs-comment"># 输出二进制表示的结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(result1),<span class="hljs-built_in">bin</span>(result2),<span class="hljs-built_in">bin</span>(result3),result3)  <br></code></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-number">0b11100111</span> <span class="hljs-number">0b11001</span> <span class="hljs-number">0b0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="使用clip方法">使用clip方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入numpy库，重命名为np</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 假设有两个数组表示图像像素值</span><br>image1 = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">50</span>, <span class="hljs-number">220</span>, <span class="hljs-number">180</span>],[<span class="hljs-number">50</span>, <span class="hljs-number">220</span>, <span class="hljs-number">180</span>]], dtype=np.uint8)<br>image2 = np.array([[<span class="hljs-number">80</span>, <span class="hljs-number">180</span>, <span class="hljs-number">255</span>], [<span class="hljs-number">120</span>, <span class="hljs-number">190</span>, <span class="hljs-number">230</span>],[<span class="hljs-number">50</span>, <span class="hljs-number">220</span>, <span class="hljs-number">180</span>]], dtype=np.uint8)<br><br><span class="hljs-comment"># 图像加法，使用饱和运算</span><br>result = np.clip(image1 + image2, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<br><br><span class="hljs-comment"># 打印处理后的结果</span><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[180 124   0]</span><br><span class="hljs-string"> [170 154 154]</span><br><span class="hljs-string"> [100 184 104]]</span><br></code></pre></td></tr></table></figure><p>实验效果显示，两种方法都可以实现0~255的映射。</p><p>当我们把它用在图像上：</p><p><strong>原图1：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/W1EXeJlc.bmp"alt="l_blue_channel" /><figcaption aria-hidden="true">l_blue_channel</figcaption></figure><p><strong>原图2：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/7BUsYmhM.bmp"alt="2_Henon_R" /><figcaption aria-hidden="true">2_Henon_R</figcaption></figure><p><strong>得到：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/APe5HAiP.bmp"alt="Result (Addition)" /><figcaption aria-hidden="true">Result (Addition)</figcaption></figure><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_addition</span>(<span class="hljs-params">img1, img2</span>):<br>    <span class="hljs-comment"># 进行二进制相加</span><br>    result = np.clip(img1 + img2, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_subtraction</span>(<span class="hljs-params">img1, img2</span>):<br><br>    <span class="hljs-comment"># 进行二进制相减</span><br>    <span class="hljs-comment"># 由于可能存在负数，需要确保结果在 [0, 255] 范围内</span><br>    binary_result = np.clip(img1 - img2, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<br>    <span class="hljs-keyword">return</span> binary_result<br><br><span class="hljs-comment"># 读取两个灰度图像</span><br>img1 = cv2.imread(<span class="hljs-string">&#x27;l_blue_channel.bmp&#x27;</span>, cv2.IMREAD_GRAYSCALE)<br>img2 = cv2.imread(<span class="hljs-string">&#x27;2_Henon_R.bmp&#x27;</span>, cv2.IMREAD_GRAYSCALE)<br><br><span class="hljs-comment"># 进行二进制相加和相减</span><br><span class="hljs-comment"># 原图1和原图2进行相加</span><br>result_add = binary_addition(img1, img2)<br><span class="hljs-comment"># 结果图-原图2=原图1</span><br>result_sub = binary_subtraction(result_add, img2)<br><br><span class="hljs-comment"># 显示结果图像</span><br>cv2.imshow(<span class="hljs-string">&#x27;Original Image 1&#x27;</span>, img1)<br>cv2.imshow(<span class="hljs-string">&#x27;Original Image 2&#x27;</span>, img2)<br>cv2.imshow(<span class="hljs-string">&#x27;Result (Addition)&#x27;</span>, result_add)<br>cv2.imshow(<span class="hljs-string">&#x27;Result (Subtraction)&#x27;</span>, result_sub)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><h3 id="同或异或">同或、异或</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cv2.bitwise_xor(block1, block2)<br>cv2.bitwise_not(cv2.bitwise_xor(block1, block2))  <span class="hljs-comment"># 同或运算</span><br></code></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs smali">import cv2<br><span class="hljs-comment"># 同或、异或</span><br>image1 = cv2.imread(&#x27;l_blue_channel.bmp&#x27;, cv2.IMREAD_GRAYSCALE)<br>image2 = cv2.imread(&#x27;2_Henon_R.bmp&#x27;, cv2.IMREAD_GRAYSCALE)<br><br>tonghuo = cv2.bitwise_xor(image1, image2)<br>yihuo = cv2.bitwise_not(cv2.bitwise_xor(tonghuo, image2))  <span class="hljs-comment"># 同或运算</span><br>cv2.imshow(<span class="hljs-string">&quot;1&quot;</span>,tonghuo)<br>cv2.imshow(<span class="hljs-string">&quot;2&quot;</span>,yihuo)<br>cv2.waitKey(0)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p>然后有意思的是出现了：</p><p><strong>原图：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/W1EXeJlc.bmp"alt="l_blue_channel" /><figcaption aria-hidden="true">l_blue_channel</figcaption></figure><p><strong>但是我异或、同或后的结果：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/v9CvtMds.bmp" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><p>很诡异，但是其实可以看出来，得到的图像，和原图像的差别，只是黑白值互换了。</p><p>检查代码，<del>发现确实是因为自己同或的顺序放反了。</del>再次试验后发现，同或再同或，才能得到原图像，自己是对他进行异或了，所以得不到原图像。</p><p>但是其实通过异或实验，我们也能得到大致的图像信息，说明同或、异或本身之间相关性很高。</p><p>更改代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-comment"># 同或、异或</span><br>image1 = cv2.imread(<span class="hljs-string">&#x27;l_blue_channel.bmp&#x27;</span>, cv2.IMREAD_GRAYSCALE)<br>image2 = cv2.imread(<span class="hljs-string">&#x27;2_Henon_R.bmp&#x27;</span>, cv2.IMREAD_GRAYSCALE)<br><br>tonghuo = cv2.bitwise_xor(image1, image2)<br>tonghuo1 = cv2.bitwise_xor(tonghuo, image2) <br>cv2.imshow(<span class="hljs-string">&quot;1&quot;</span>,tonghuo)<br>cv2.imshow(<span class="hljs-string">&quot;2&quot;</span>,tonghuo1)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p>实验成功：</p><figure><img src="https://img2.imgtp.com/2024/04/10/APe5HAiP.bmp"alt="tonghuo" /><figcaption aria-hidden="true">tonghuo</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/W1EXeJlc.bmp"alt="tonghuo1" /><figcaption aria-hidden="true">tonghuo1</figcaption></figure><h3 id="互换">0-1互换</h3><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 读取灰度图像</span><br>image_gray = cv2.imread(<span class="hljs-string">&#x27;l_blue_channel.bmp&#x27;</span>, cv2.IMREAD_GRAYSCALE)<br><br><br><span class="hljs-comment"># 获取图像尺寸</span><br>height, width = image_gray.shape<br><br><span class="hljs-comment"># 将像素转换为二进制序列并进行反转</span><br>binary_image = np.zeros_like(image_gray)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(height):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(width):<br>        pixel_binary = <span class="hljs-built_in">bin</span>(image_gray[i, j])[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>)  <span class="hljs-comment"># 转换为8位二进制序列</span><br>        inverted_binary = <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">if</span> bit == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">for</span> bit <span class="hljs-keyword">in</span> pixel_binary])  <span class="hljs-comment"># 反转序列</span><br>        binary_image[i, j] = <span class="hljs-built_in">int</span>(inverted_binary, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 转换为十进制并赋值给新图像</span><br><br><span class="hljs-comment"># 显示图像</span><br>cv2.imshow(<span class="hljs-string">&#x27;Inverted Binary Image&#x27;</span>, binary_image)<br>cv2.imshow(<span class="hljs-string">&#x27;image_gray Image&#x27;</span>, image_gray)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p><strong>原图：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/W1EXeJlc.bmp"alt="image_gray" /><figcaption aria-hidden="true">image_gray</figcaption></figure><p><strong>结果图：</strong></p><figure><img src="https://img2.imgtp.com/2024/04/10/v9CvtMds.bmp"alt="binary_image" /><figcaption aria-hidden="true">binary_image</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>图像加密</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像</tag>
      
      <tag>学习</tag>
      
      <tag>笔记</tag>
      
      <tag>加密</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机视觉-图像视觉作业-作业5</title>
    <link href="/2024/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%9B%BE%E5%83%8F%E8%A7%86%E8%A7%89%E4%BD%9C%E4%B8%9A-%E4%BD%9C%E4%B8%9A5/"/>
    <url>/2024/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%9B%BE%E5%83%8F%E8%A7%86%E8%A7%89%E4%BD%9C%E4%B8%9A-%E4%BD%9C%E4%B8%9A5/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机视觉作业-作业5">计算机视觉作业-作业5</h1><p>参考教材相应章节内容，完成以下实践内容：</p><p>1、缩放操作</p><p>2、翻转操作</p><p>3、平移操作</p><p>4、旋转操作</p><p>5、倾斜操作</p><p>6、透视操作</p><p><span id="more"></span></p><hr /><ol type="1"><li>缩放操作</li></ol><p>1.1 将图像按照指定宽高进行缩放；</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>dst1 = cv2.resize(img, (<span class="hljs-number">100</span>, <span class="hljs-number">100</span>))  <span class="hljs-comment"># 按照宽100像素、高100像素的大小进行缩放</span><br>dst2 = cv2.resize(img, (<span class="hljs-number">400</span>, <span class="hljs-number">400</span>))  <span class="hljs-comment"># 按照宽400像素、高400像素的大小进行缩放</span><br>cv2.imwrite(<span class="hljs-string">&quot;1.1.1.jpg&quot;</span>,img) <span class="hljs-comment"># 保存原图图像</span><br>cv2.imwrite(<span class="hljs-string">&quot;1.1.2.jpg&quot;</span>,dst1)<br>cv2.imwrite(<span class="hljs-string">&quot;1.1.3.jpg&quot;</span>,dst2)<br></code></pre></td></tr></table></figure><p><strong>效果图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOa8Jg.jpg"alt="1.1.1.jpg" /><figcaption aria-hidden="true">1.1.1.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/09/pFOaQdf.jpg"alt="1.1.2.jpg" /><figcaption aria-hidden="true">1.1.2.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/09/pFOa3FS.jpg"alt="1.1.3.jpg" /><figcaption aria-hidden="true">1.1.3.jpg</figcaption></figure><p>1.2 指定比例进行缩放;</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>dst3 = cv2.resize(img, <span class="hljs-literal">None</span>, fx=<span class="hljs-number">1</span> / <span class="hljs-number">3</span>, fy=<span class="hljs-number">1</span> / <span class="hljs-number">2</span>)  <span class="hljs-comment"># 将宽缩小到原来的1/3、高缩小到原来的1/2</span><br>dst4 = cv2.resize(img, <span class="hljs-literal">None</span>, fx=<span class="hljs-number">1.5</span>, fy=<span class="hljs-number">1.5</span>)  <span class="hljs-comment"># 将宽高扩大1.5倍</span><br>cv2.imwrite(<span class="hljs-string">&quot;1.2.1.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;1.2.2.jpg&quot;</span>,dst3)<br>cv2.imwrite(<span class="hljs-string">&quot;1.2.3.jpg&quot;</span>,dst4)<br><br></code></pre></td></tr></table></figure><p><strong>效果图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOaGWQ.jpg"alt="1.2.1.jpg" /><figcaption aria-hidden="true">1.2.1.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/09/pFOalo8.jpg"alt="1.2.2.jpg" /><figcaption aria-hidden="true">1.2.2.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/09/pFOaNyn.jpg"alt="1.2.3.jpg" /><figcaption aria-hidden="true">1.2.3.jpg</figcaption></figure><ol start="2" type="1"><li>翻转操作</li></ol><p>实现多种不同翻转效果；</p><p>2.1 垂直翻转</p><p>2.2 水平翻转</p><p>2.3 对角线翻转</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>dst1 = cv2.flip(img, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 沿X轴翻转</span><br>dst2 = cv2.flip(img, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 沿Y轴翻转</span><br>dst3 = cv2.flip(img, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># 同时沿X轴、Y轴翻转</span><br>cv2.imwrite(<span class="hljs-string">&quot;2.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;2.1.jpg&quot;</span>,dst1)<br>cv2.imwrite(<span class="hljs-string">&quot;2.2.jpg&quot;</span>,dst2)<br>cv2.imwrite(<span class="hljs-string">&quot;2.3.jpg&quot;</span>,dst3)<br><br></code></pre></td></tr></table></figure><p>效果图：</p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="2.0.jpg" /><figcaption aria-hidden="true">2.0.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/10/pFOIqPg.jpg" alt="2.1.jpg" /><figcaption aria-hidden="true">2.1.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/10/pFOIHIS.jpg" alt="2.2.jpg" /><figcaption aria-hidden="true">2.2.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/10/pFOITVf.jpg" alt="2.3.jpg" /><figcaption aria-hidden="true">2.3.jpg</figcaption></figure><ol start="3" type="1"><li>平移操作</li></ol><p>实现图像向不同方向平移效果；</p><p>3.1 横坐标向右移动50像素 纵坐标向下移动100像素</p><p>3.2 横坐标不变 纵坐标向上移动50像素</p><p>3.3 横坐标向左移动200像素 纵坐标不变</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>rows = <span class="hljs-built_in">len</span>(img)  <span class="hljs-comment"># 图像像素行数</span><br>cols = <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 图像像素列数</span><br>M1 = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>],  <span class="hljs-comment"># 横坐标向右移动50像素</span><br>                [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>]])  <span class="hljs-comment"># 纵坐标向下移动100像素</span><br>M2 = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],  <span class="hljs-comment"># 横坐标不变</span><br>                [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>]])  <span class="hljs-comment"># 纵坐标向上移动50像素</span><br>M3 = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>],  <span class="hljs-comment"># 横坐标向左移动200像素</span><br>                [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>]])  <span class="hljs-comment"># 纵坐标不变</span><br>dst1 = cv2.warpAffine(img, M1, (cols, rows))<br>dst2 = cv2.warpAffine(img, M2, (cols, rows))<br>dst3 = cv2.warpAffine(img, M3, (cols, rows))<br>cv2.imwrite(<span class="hljs-string">&quot;3.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;3.1.jpg&quot;</span>,dst1)<br>cv2.imwrite(<span class="hljs-string">&quot;3.2.jpg&quot;</span>,dst2)<br>cv2.imwrite(<span class="hljs-string">&quot;3.3.jpg&quot;</span>,dst3)<br></code></pre></td></tr></table></figure><p>效果图：</p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="3.0.jpg" /><figcaption aria-hidden="true">3.0.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/10/pFOIIqP.jpg" alt="3.1.jpg" /><figcaption aria-hidden="true">3.1.jpg</figcaption></figure><figure><img src="https://s21.ax1x.com/2024/04/10/pFOI7a8.jpg" alt="3.2.jpg" /><figcaption aria-hidden="true">3.2.jpg</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/aaTUr9yc.jpg"alt="3.3.jpg" /><figcaption aria-hidden="true">3.3.jpg</figcaption></figure><ol start="4" type="1"><li>旋转操作</li></ol><p>实现图像逆时针旋转效果；</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>rows = <span class="hljs-built_in">len</span>(img)  <span class="hljs-comment"># 图像像素行数</span><br>cols = <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 图像像素列数</span><br>center = (rows / <span class="hljs-number">2</span>, cols / <span class="hljs-number">2</span>)  <span class="hljs-comment"># 图像的中心点</span><br>M = cv2.getRotationMatrix2D(center, <span class="hljs-number">30</span>, <span class="hljs-number">0.8</span>)  <span class="hljs-comment"># 以图像为中心，逆时针旋转30度，缩放0.8倍</span><br>dst = cv2.warpAffine(img, M, (cols, rows))  <span class="hljs-comment"># 按照M进行仿射</span><br>cv2.imwrite(<span class="hljs-string">&quot;4.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;4.1.jpg&quot;</span>,dst)<br></code></pre></td></tr></table></figure><p><strong>效果图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="4.0.jpg" /><figcaption aria-hidden="true">4.0.jpg</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/1LvgNtED.jpg"alt="4.1.jpg" /><figcaption aria-hidden="true">4.1.jpg</figcaption></figure><ol start="5" type="1"><li>倾斜操作</li></ol><p>实现图像分别向左和右倾斜效果；</p><p>5.1 图像右倾斜</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>rows = <span class="hljs-built_in">len</span>(img)  <span class="hljs-comment"># 图像像素行数</span><br>cols = <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 图像像素列数</span><br>p1 = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，原图三个点</span><br>p1[<span class="hljs-number">0</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标</span><br>p1[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标</span><br>p1[<span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标</span><br>p2 = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，倾斜图三个点</span><br>p2[<span class="hljs-number">0</span>] = [<span class="hljs-number">50</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标，向右挪50像素</span><br>p2[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标，位置不变</span><br>p2[<span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标，位置不变</span><br>M = cv2.getAffineTransform(p1, p2)  <span class="hljs-comment"># 根据三个点的变化轨迹计算出M矩阵</span><br>dst = cv2.warpAffine(img, M, (cols, rows))  <span class="hljs-comment"># 按照M进行仿射</span><br>cv2.imwrite(<span class="hljs-string">&quot;5.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;5.1.jpg&quot;</span>,dst)<br></code></pre></td></tr></table></figure><p><strong>效果图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="5.0.jpg" /><figcaption aria-hidden="true">5.0.jpg</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/Ncury2ba.jpg"alt="5.1.jpg" /><figcaption aria-hidden="true">5.1.jpg</figcaption></figure><p>5.2 图像左倾斜</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>rows = <span class="hljs-built_in">len</span>(img)  <span class="hljs-comment"># 图像像素行数</span><br>cols = <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 图像像素列数</span><br>p1 = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，原图三个点</span><br>p1[<span class="hljs-number">0</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标</span><br>p1[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标</span><br>p1[<span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标</span><br>p2 = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，倾斜图三个点</span><br>p2[<span class="hljs-number">0</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标，向右挪50像素</span><br>p2[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">51</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标，位置不变</span><br>p2[<span class="hljs-number">2</span>] = [<span class="hljs-number">50</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标，位置不变</span><br>M = cv2.getAffineTransform(p1, p2)  <span class="hljs-comment"># 根据三个点的变化轨迹计算出M矩阵</span><br>dst = cv2.warpAffine(img, M, (cols, rows))  <span class="hljs-comment"># 按照M进行仿射</span><br>cv2.imwrite(<span class="hljs-string">&quot;5.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;5.2.jpg&quot;</span>,dst)<br></code></pre></td></tr></table></figure><p><strong>图像图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="5.0.jpg" /><figcaption aria-hidden="true">5.0.jpg</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/R6c02Daj.jpg"alt="5.2.jpg" /><figcaption aria-hidden="true">5.2.jpg</figcaption></figure><ol start="6" type="1"><li>透视操作</li></ol><p>模拟从底部观察图像得到的透视效果；</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&quot;lena.bmp&quot;</span>)  <span class="hljs-comment"># 读取图像</span><br>rows = <span class="hljs-built_in">len</span>(img)  <span class="hljs-comment"># 图像像素行数</span><br>cols = <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 图像像素列数</span><br>p1 = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，保存原图四个点</span><br>p1[<span class="hljs-number">0</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标</span><br>p1[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标</span><br>p1[<span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标</span><br>p1[<span class="hljs-number">3</span>] = [cols - <span class="hljs-number">1</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 右下角点坐标</span><br>p2 = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">2</span>), np.float32)  <span class="hljs-comment"># 32位浮点型空列表，保存透视图四个点</span><br>p2[<span class="hljs-number">0</span>] = [<span class="hljs-number">90</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 左上角点坐标，向右移动90像素</span><br>p2[<span class="hljs-number">1</span>] = [cols - <span class="hljs-number">90</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 右上角点坐标，向左移动90像素</span><br>p2[<span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 左下角点坐标，位置不变</span><br>p2[<span class="hljs-number">3</span>] = [cols - <span class="hljs-number">1</span>, rows - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 右下角点坐标，位置不变</span><br>M = cv2.getPerspectiveTransform(p1, p2)  <span class="hljs-comment"># 根据四个点的变化轨迹计算出M矩阵</span><br>dst = cv2.warpPerspective(img, M, (cols, rows))  <span class="hljs-comment"># 按照M进行仿射</span><br>cv2.imwrite(<span class="hljs-string">&quot;6.0.jpg&quot;</span>,img)<br>cv2.imwrite(<span class="hljs-string">&quot;6.1.jpg&quot;</span>,dst)<br></code></pre></td></tr></table></figure><p><strong>效果图：</strong></p><figure><img src="https://s21.ax1x.com/2024/04/09/pFOatQs.jpg" alt="6.0.jpg" /><figcaption aria-hidden="true">6.0.jpg</figcaption></figure><figure><img src="https://img2.imgtp.com/2024/04/10/f1yRErS0.jpg"alt="6.1.jpg" /><figcaption aria-hidden="true">6.1.jpg</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像</tag>
      
      <tag>计算机视觉</tag>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>混沌的验证方法</title>
    <link href="/2024/04/08/%E6%B7%B7%E6%B2%8C%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/"/>
    <url>/2024/04/08/%E6%B7%B7%E6%B2%8C%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>所有混沌系统一定是非线性系统，但非线性系统不一定是混沌系统。确定一个系统是否存在混沌需要从多方面加以分析，结合定性分析系统机理和其他方法，一下简介一些常用的判别系统或时间序列是否具有混沌特性的方法。</p><p><span id="more"></span></p><ol type="1"><li><p>Poincare截面法：在相空间中选取一截面，在截面上某一对共轭变量构成的截面称为Poincare截面。当Poincare截面上是一些成片的具有分形结构的密集点时，说明系统是混沌的。</p></li><li><p>Lyapunov指数法：李雅普诺夫指数是指在相空间中相互靠近的两条轨线随着时间的推移，按指数分离或聚合的平均变化速率，正的李雅普诺夫指数意味着混沌。</p></li><li><p>时域及相轨迹的直接观察方法：在时域分析里，可通过观察各个状态变量的时域波形，发现分岔和阵发性混沌。</p></li><li><p>分维数：混沌运动具有某种潜在的秩序，并能以相对较少的自由度来描述。分维数给出了有关混沌的自由度的信息，分维数的具体形式有很多种。</p></li><li><p>Kolmogorov熵：关联维数和Kolmogorov熵的计算可以在相空间中进行，包括最小二乘法等。</p></li><li><p>（1）功率谱法。</p><p>时间序列的图像看上去不规则,但其功率谱却可能呈现出规律。若功率谱图无明显的峰值或峰值连成一片,则对应于混沌序列,系统作混沌运动若功率谱图具有单峰或几个峰,则对应于周期序列或拟周期序列,系统作周期运动。</p><p>（2）准相图法。</p><p>如果准相图是简单的闭环曲线,那么系统作周期运动如果准相图为自身相交的闭环曲线,那么系统作准周期运动如果准相图具有无限精细的分形结构,则系统作混沌运动。</p><p>（3）分频采样法。</p><p>对周期外力作用下的非线性振子,研究其倍周期分岔和混沌现象,可采用频闪采样法,是目前辨认长周期混沌带的最有效的方法。对于受迫振动,采样周期常取为外控力周期,如果采样点只是在一定区域内密集的点而且具有层次结构,则此伪随机运动便是混沌。</p></li></ol><p>ps:test，看看能不能调用评论系统了！</p>]]></content>
    
    
    <categories>
      
      <category>图像加密算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像</tag>
      
      <tag>加密</tag>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的基础用法以及写作技巧汇总</title>
    <link href="/2024/04/07/hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"/>
    <url>/2024/04/07/hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p>本文对于hexo的一些语法进行简单讲解，主要记录了hexo特定的一些写作方法以及常见的一些参数如何设置。</p><p><span id="more"></span></p><h1 id="hexo特定语法">hexo特定语法</h1><h2 id="新建博客文章">新建博客文章</h2><p>对于新搭建好的博客，你的文章该如何创建？在你的博客根目录下，打开<code>git bash here</code> ，然后输入 <code>hexo new 你的文章标题</code>就在你博客根目录下的 <code>source/_posts</code>里生成<code>你的文章标题.md</code>文件。然后你打开该文件就可以进行编辑和书写了。</p><h2 id="显示摘要">显示摘要</h2><p>所以不需要设置，只要我们在文章中插入<code>&lt;!-- more --&gt;</code>，该标签之上的是摘要，之后的内容不可见，需点击全文阅读按钮；</p><h2 id="文章内容设置">文章内容设置</h2><h3 id="显示标题图">显示标题图</h3><p>如何显示标题头图。以fluid主题为例，在你生成新的博客里，应该只有</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">title: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">title</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">date: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">date</span> &#125;&#125;</span><br></code></pre></td></tr></table></figure><p><code>title</code> ：你的标题名字；</p><p><code>data</code> ：你的创建的时间。</p><p>添加如下代码：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">index_img:</span> <span class="hljs-keyword">/img/</span>banner.jpg<br><span class="hljs-symbol">banner_img:</span> <span class="hljs-keyword">/img/</span>banner.jpg<br></code></pre></td></tr></table></figure><p>其中：<code>index_img</code> 指的是你主页上看到的图片，比如</p><p><img src="https://s21.ax1x.com/2024/04/07/pFqWzWt.png" /></p><p>这里你看到的图片，就是<code>index_img</code>定义的图片，图片可以是链接形式，也可以是存放在你的根目录下的<code>/img</code>文件夹里，必须使用相对路径，绝对路径不能部署到服务器！后面会说，相对路径也不是哪里都能放的。</p><p>打开文章后，文章里面的顶部图片由<code>banner_img</code>确定；</p><p><img src="https://s21.ax1x.com/2024/04/07/pFqfCy8.png" /></p><p>一样的，对于图片也是可以取链接或者相对路径图片。</p><h3 id="标签和分类">标签和分类</h3><p><code>categories:</code>和<code>tags:</code>；默认不添加，要自己添加；</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span> [标签1,标签2,标签3]<br><span class="hljs-keyword">tags:</span> [tag1, tag2]注意1.属性和内容之间要有空格2.[tag1+逗号+空格+tag2]<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span><br><br>- 生活<br><br>- 年度总结<br><br>-和后面的标签之间有空格<br><br></code></pre></td></tr></table></figure><h2 id="启动公式渲染">启动公式渲染</h2><p>还是在原来的地方，输入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">math</span>: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>就可以打开公式渲染；markdown公式真的很方便！真的很方便！</p><h3 id="行内公式">行内公式</h3><p>输入<code>$$</code>就可以在两个$中间填写你要的行内公式：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">$x = y_</span><span class="hljs-template-variable">&#123;n+1&#125;</span><span class="language-xml"> + z^</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="language-xml">$</span><br></code></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><span class="math inline">\(x = y_{n+1} + z^{x}\)</span></p><h3 id="块间公式">块间公式</h3><p>你可以通过<code>ctrl+shift+M</code>来获得块间公式 <spanclass="math display">\[x = y_{n+1} + z^{x}\]</span> 自动编号，自动居中，自动渲染，看着还不算难看吧~</p><h2 id="选择部署时候要上传的文件">选择部署时候要上传的文件</h2><p>我使用的是GitHub作为我的服务器部署，事先要先安装部署上传插件</p><p><strong>部署上传插件</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>当我们<code>hexo clean</code> <code>hexo g</code><code>hexo d</code>三步走后，他就可以自动给你部署到GitHub上，然后我们就可以访问到了，但是部署服务器并不是什么文件都会上传到GitHub上的，比如：</p><p><img src="https://s21.ax1x.com/2024/04/07/pFqfpSP.png" /></p><p>这是我<code>hexo d</code>后GitHub上的文件，再看我本地端的文件</p><p><img src="https://s21.ax1x.com/2024/04/07/pFqWxJI.png" /></p><p>你会发现，少了一些文件，多了一些文件，当我们打开<code>.gitignore</code>文件后查看</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.DS_Store</span><br>Thumbs<span class="hljs-number">.</span><span class="hljs-built_in">db</span><br><span class="hljs-built_in">db</span><span class="hljs-number">.</span>json<br>*.log<br>node_modules/<br><span class="hljs-meta">public</span>/<br><span class="hljs-meta">.deploy</span>*/<br>_multiconfig<span class="hljs-number">.</span>yml<br></code></pre></td></tr></table></figure><p>里面出现的文件和文件夹，都没有出现在GitHub上，这就是<code>hexo</code>插件（你安装hexo后安装的插件，后续看看要不要也写一篇hexo的教程和我走过的坑），在读取这个文件后，自动忽略部署了。</p><p>当然<code>_config.yml</code>也自带了忽略编译的文件选项：</p><p><img src="https://s21.ax1x.com/2024/04/07/pFqf9Qf.png" /></p><p><code>skip_render</code>就是你要忽略的文件，你可以自己决定要跳过哪些来减少你服务器的空间。</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ldif">跳过编译文件：<br><span class="hljs-attribute">skip_render</span>:   <span class="hljs-comment">#部署时不包含的文件</span><br><br><span class="hljs-comment">#单个文件</span><br><span class="hljs-attribute">skip_render</span>: hello.html<br><br><span class="hljs-comment">#单个文件夹下全部文件</span><br><span class="hljs-attribute">skip_render</span>: test/* <br><br><span class="hljs-comment">#单个文件夹下指定类型文件</span><br><span class="hljs-attribute">skip_render</span>: test/*.md  <br><br><span class="hljs-comment">#单个文件夹下全部文件以及子目录</span><br><span class="hljs-attribute">skip_render</span>: test/**  <br><br><span class="hljs-comment">#跳过多个目录，或者多个文件</span><br><span class="hljs-attribute">skip_render</span>: [&#x27;*.html&#x27;, demo/**, test/*]<br></code></pre></td></tr></table></figure><h1 id="typora-写作技巧及常见快捷键">typora 写作技巧及常见快捷键</h1><ul><li><p><code>ctrl+u</code>:选中的文本会出现<u>下划线</u>；</p></li><li><p><code>ctrl+b</code>:选中的文本会<strong>加粗</strong>；</p></li><li><p><code>ctrl+shift+m</code>:生成一个公式块；</p></li><li><p><code>shift+~</code>:选中的文本会<sub>变身</sub>；</p></li><li><p><code>shift+$</code>:选中的文本会变成<spanclass="math inline">\(行内公式\)</span>；</p></li><li><p><code>shift+*</code>:选中的文本会变成<em>斜体</em>；再来一次就<strong>加粗</strong>；再来一次就是<strong><em>加粗+斜体</em></strong>；</p></li><li><p><code>==</code>:高亮；但是博客好像不支持渲染，只有typora支持，可惜；</p><hr /></li><li><p><code>tab</code>:可以对列表缩进，比如</p><ul><li>这个就是被缩进了；</li><li>也可以回去<code>tab+shift</code>;</li></ul></li><li><p>就回去了。</p><hr /></li><li><p><code>---</code>:分隔符；</p></li><li><p><code>shift+方向键</code>:选中文本；</p></li></ul><h1 id="总结">总结</h1><p>对于常见的用法和比较重要的东西已经放在这里，对于未来会继续补充完善，这就是博客的魅力！！</p>]]></content>
    
    
    <categories>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的工具箱</title>
    <link href="/2024/04/07/%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    <url>/2024/04/07/%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="常使用的没用小玩样">常使用的没用小玩样</h1><h2 id="摘要">摘要</h2><p>对我常用的网站和工具进行归纳总结，方便大家的同时，让我以后也能更快速的查找相应🔗进行学习</p><p><span id="more"></span></p><h2 id="一些七七八八的工具">一些七七八八的工具</h2><ul><li>markdown编辑器：typora、我来(wolai) <ahref="(https://www.wolai.com/wolai/4N5o3xKuVqi9UrMKo1kD9k)">🔗</a>；<ul><li>typora：简洁，就像这篇博客就是用typora打的，就很适合自己安静码字，没有一丝杂念，关键是它很方便，对于一些我觉得要搞很久的比如插入链接，我们就只要复制网站，选你要插入的地方，粘贴就好了，及其舒服！！上手极快。能导出各种格式，我就喜欢在typora打公式，然后导出word，省的我word公式一个一个的画:sob:。</li><li>我来(wolai)：类notion软件，notion也是一款很出名的笔记软件，不知道有没有人用笔记软件，应该都会有听过它，他算是最出名的，但是没有官方汉化，对英文不友好的小伙伴就是拒之门外了。我来可以说是中文版的notion，高度自定义！什么叫自定义？你爱怎么做就怎么做，跟我的世界开创造一样，同理，创造模式你要创造很好看的界面，你需要学习它的使用，还是要有点时间学习他的，可能就止步于开始了。</li></ul></li><li>使用hexo搭建博客框架🔗(<ahref="https://hexo.io/zh-cn/">Hexo</a>)，使用 <ahref="https://hexo.fluid-dev.com/docs/">Fluid</a>主题；</li><li>图床工具：<a href="https://imgse.com/">路过图床</a>免费使用，不限流量，不限张数！不过不能上传黄色！赌博！违反法律法规的图片！你要想也刑。:sweat_smile:</li><li>图片压缩工具： <a href="https://tinypng.com/">Tinjimages</a>github链接<ahref="%5Bfocusbe/tinyImage:%20一款图片压缩工具%20(github.com)%5D(https://github.com/focusbe/tinyImage?tab=readme-ov-file)">🔗</a>；好用的压缩工具，在缩小图片大小的同时很大程度的保留了原来图片的细节；关键是图片小了网站加载速度也就上来了；</li><li>pdf工具大全： <ahref="https://tools.pdf24.org/zh/pdf-to-word#s=1695923633252">PDF24Tools</a>；好用，功能多，免费，几乎任何和pdf相关的问题都可以在里面找到小工具并解决。比如：</li></ul><p><img src="https://s21.ax1x.com/2024/04/07/pFqyYKH.png" /></p><ul><li><p>博客流量分析工具：<a href="https://www.51.la/">51LA</a>；个人免费，简单高效，数据可视化；包括趋势分析、访问量、在线人数、访客数、访问频次、类别占比、甚至还有地区来源；</p><p>部分截图：</p></li></ul><p><img src="https://s21.ax1x.com/2024/04/07/pFqyNqA.png" /></p><ul><li>图书看书工具：<ahref="https://zh.singlelogin.re/login.php">Z-Library项目(singlelogin.re)</a>；应该不会有人不知道免费图书白嫖网站吧~应该不会吧，那我还是写一下吧，可以搜索到几乎我大学生涯的全部教科书，当然还有期待参考书、课外书它都有，当然除极个别情况外，他还hi是没有…..那就是只能看看tb有没有卖咯；</li><li>PPT神器：<a href="https://www.mindshow.fun/#/home">MindShow</a>导入文件，生成ppt！可以导入markdown、word、xmid等文件，支持网站上编辑；免费！模板还算丰富，关键是快啊！用来应急啥的还行（小声……）</li><li>知云文献：<a href="https://www.zhiyunwenxian.cn/">知云文献</a>；划词翻译，支持各类翻译引擎：百度、谷歌、Deeply（最强机翻）等等，看文献方便，pdf编辑器该有的也都有！</li></ul><h2 id="一些奇奇怪怪的网站">一些奇奇怪怪的网站</h2><h3 id="壁纸网站">壁纸网站</h3><p><a href="https://wallhaven.cc/?utm_source=ld246.com">AwesomeWallpapers - wallhaven.cc</a></p><p><ahref="https://desk.3gbizhi.com/">电脑桌面壁纸大全-高清电脑桌面壁纸图片-超高清壁纸桌面免费下载-3g壁纸(3gbizhi.com)</a></p><h3 id="设计网站">设计网站</h3><p><ahref="https://www.zcool.com.cn/">站酷ZCOOL-设计师互动平台-打开站酷，发现更好的设计！</a></p><p><a href="https://www.ui.cn/">UICN用户体验设计平台</a></p><p><a href="https://fontawesome.com.cn/v5">图标库v5 - FontAwesome字体图标中文Icon</a></p><h3 id="python">python</h3><p><ahref="https://zhuanlan.zhihu.com/p/343256430">python简单进阶之GUI：PySimpleGUI使用教程- 知乎 (zhihu.com)</a></p><p><ahref="https://www.runoob.com/python3/python3-tutorial.html">Python3 教程| 菜鸟教程 (runoob.com)</a></p><h3 id="码字网站">码字网站</h3><p><a href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法 |Markdown 官方教程</a></p><p><ahref="https://zhuanlan.zhihu.com/p/481032338">Typora(meimaid)绘制流程图- 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown教程</title>
    <link href="/2024/04/06/makedown%E6%95%99%E7%A8%8B/"/>
    <url>/2024/04/06/makedown%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="markdown基础">MarkDown基础</h1><h2 id="标题">标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 标题名字（井号的个数代表标题的级数）</span><br></code></pre></td></tr></table></figure><h1 id="一级标题使用1个">一级标题使用1个</h1><h2 id="二级标题使用2个">二级标题使用2个</h2><h3 id="三级标题使用3个">三级标题使用3个</h3><h4 id="四级标题使4用个">四级标题使4用个</h4><h5 id="五级标题使用5个">五级标题使用5个</h5><h6 id="六级标题使用6个">六级标题使用6个</h6><p class="heading" id="最多支持六级标题">最多支持六级标题</p><h2 id="文字">文字</h2><h3 id="删除线">删除线</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这就是 ~~删除线~~ (使用波浪号)<br></code></pre></td></tr></table></figure><p>这就是 <del>删除线</del> (使用波浪号)</p><h3 id="斜体">斜体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-emphasis">*斜体*</span> 的 <span class="hljs-emphasis">_文本_</span><br></code></pre></td></tr></table></figure><p>这是用来 <em>斜体</em> 的 <em>文本</em></p><h3 id="加粗">加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-strong">**加粗**</span> 的 <span class="hljs-strong">__文本__</span><br></code></pre></td></tr></table></figure><p>这是用来 <strong>加粗</strong> 的 <strong>文本</strong></p><h3 id="斜体加粗">斜体+加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-strong">**<span class="hljs-emphasis">*斜体+加粗*</span>**</span> 的 <span class="hljs-strong">__<span class="hljs-emphasis">_文本_</span>__</span><br></code></pre></td></tr></table></figure><p>这是用来 <strong><em>斜体+加粗</em></strong> 的<strong><em>文本</em></strong></p><h3 id="下划线">下划线</h3><p>下划线是HTML语法</p><p><code>下划线</code><u>下划线(快捷键<code>command</code>+<code>u</code>，视频中所有的快捷键都是针对Mac系统，其他系统可自行查找)</u></p><h3 id="高亮需勾选扩展语法"><u>高亮</u>（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 ==斜体+加粗== 的文本<br></code></pre></td></tr></table></figure><p>这是用来 ==斜体+加粗== 的文本</p><h3 id="下标需勾选扩展语法">下标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">水 H~2~O <br>双氧水 H~2~O~2~ <br></code></pre></td></tr></table></figure><p>水 H<sub>2</sub>O</p><p>双氧水 H<sub>2</sub>O<sub>2</sub></p><h3 id="上标需勾选扩展语法">上标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">面积 m^2^ <br>体积 m^3^<br></code></pre></td></tr></table></figure><p>面积 m<sup>2</sup> 体积 m<sup>3</sup></p><h3 id="表情符号">表情符号</h3><p>Emoji 支持表情符号，你可以用系统默认的 Emoji 符号（ Windows用户不一定支持，自己试下~）。 也可以用图片的表情，输入 <code>:</code>将会出现智能提示。</p><h4 id="一些表情例子">一些表情例子</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">:smile: :laughing: :dizzy<span class="hljs-emphasis">_face: :sob: :cold_</span>sweat: :sweat<span class="hljs-emphasis">_smile:  :cry: :triumph: :heart_</span>eyes: :relaxed: :sunglasses: :weary:<br><br>:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat<span class="hljs-emphasis">_drops: :hankey: :exclamation: :anger:</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure><p>:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile::cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1::100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone::bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</p><p>( Mac:<code>control</code>+<code>command</code>+<code>space</code>点选)</p><h3 id="表格">表格</h3><p>使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code>来分隔表头和其他行：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">name | price<br>--- | ---<br>fried chicken | 19<br>cola|5<br></code></pre></td></tr></table></figure><blockquote><p>为了使 Markdown 更清晰，<code>|</code> 和 <code>-</code>两侧需要至少有一个空格（最左侧和最右侧的 <code>|</code>外就不需要了）。</p></blockquote><table><thead><tr class="header"><th>name</th><th>price</th></tr></thead><tbody><tr class="odd"><td>fried chicken</td><td>19</td></tr><tr class="even"><td>cola</td><td>5</td></tr></tbody></table><p>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用<code>|</code> 来标记单元格边界，在表头下方的分隔线标记中加入<code>:</code>，即可标记下方单元格内容的对齐方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|    name       | price |<br>| :------------ | :---: |<br>| fried chicken | 19    |<br>| cola          |  32   |<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: left;">name</th><th style="text-align: center;">price</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">fried chicken</td><td style="text-align: center;">19</td></tr><tr class="even"><td style="text-align: left;">cola</td><td style="text-align: center;">32</td></tr></tbody></table><p>使用快捷键<code>command</code>+<code>opt</code>+<code>T</code>更方便(段落→表格→插入表格，即可查看快捷键)</p><table><thead><tr class="header"><th>name</th><th>price</th></tr></thead><tbody><tr class="odd"><td></td><td></td></tr></tbody></table><h2 id="引用">引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;“后悔创业”<br></code></pre></td></tr></table></figure><blockquote><p>“后悔创业”</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;也可以在引用中<br>&gt;&gt;使用嵌套的引用<br></code></pre></td></tr></table></figure><blockquote><p>也可以在引用中</p><blockquote><p>使用嵌套的引用</p></blockquote></blockquote><h2 id="列表">列表</h2><h3 id="无序列表--符号-空格">无序列表--符号 空格</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 可以使用 <span class="hljs-code">`*`</span> 作为标记<br><span class="hljs-bullet">+</span> 也可以使用 <span class="hljs-code">`+`</span><br><span class="hljs-bullet">-</span> 或者 <span class="hljs-code">`-`</span><br></code></pre></td></tr></table></figure><ul><li><p>可以使用 <code>*</code> 作为标记</p></li><li><p>也可以使用 <code>+</code></p></li><li><p>或者 <code>-</code></p></li></ul><h3 id="有序列表--数字-.-空格一定要空格">有序列表--数字 <code>.</code>空格（==一定要空格==）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有序列表以数字和 <span class="hljs-code">`.`</span> 开始；<br><span class="hljs-bullet">3.</span> 数字的序列并不会影响生成的列表序列；<br><span class="hljs-bullet">4.</span> 但仍然推荐按照自然顺序（1.2.3...）编写。<br></code></pre></td></tr></table></figure><ol type="1"><li><p>有序列表以数字和 <code>.</code> 开始；</p></li><li><p>数字的序列并不会影响生成的列表序列；</p></li><li><p>但仍然推荐按照自然顺序（1.2.3...）编写。</p><p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">可以使用：数字\. 来取消显示为列表（用反斜杠进行转义）<br></code></pre></td></tr></table></figure></p></li></ol><h4 id="合并单元格">合并单元格</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">escape</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>项目1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>项目2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>项目3<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>a1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>a2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>b1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>b2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>b3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>c2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>c3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">escape</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="代码">代码</h2><h3 id="代码块">代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a)<br><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">```语言名称(就会转换成对应的代码块)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="行内代码">行内代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">也可以通过 <span class="hljs-code">``，插入行内代码（`</span> 是 <span class="hljs-code">`Tab`</span> 键上边、数字 <span class="hljs-code">`1`</span> 键左侧的那个按键）：<br><br>例如 <span class="hljs-code">`Markdown`</span><br></code></pre></td></tr></table></figure><p><code>python</code></p><h3 id="转换规则">转换规则</h3><p>代码块中的文本（包括 Markdown 语法）都会显示为原始内容</p><h2 id="分隔线">分隔线</h2><p>可以在一行中使用三个或更多的 <code>*</code>、<code>-</code> 或<code>_</code> 来添加分隔线（``）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"><span class="hljs-strong">***</span></span><br><span class="hljs-strong"><span class="hljs-section">------</span></span><br><span class="hljs-strong"><span class="hljs-section">__<span class="hljs-emphasis">_</span></span></span><br></code></pre></td></tr></table></figure><hr /><hr /><hr /><h2 id="跳转">跳转</h2><h3 id="外部跳转--超链接">外部跳转--超链接</h3><p>格式为 <code>[提示的文字](link)</code>。(按住ctrl + 点击)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">帮助文档</span>](<span class="hljs-link">https://support.typora.io/Links/#faq</span>)<br></code></pre></td></tr></table></figure><p><a href="https://support.typora.io/Links/#faq">帮助文档</a></p><h3id="内部跳转--本文件内跳typora支持">内部跳转--本文件内跳（Typora支持）</h3><p>格式为 <code>[link text](#要去的目的地--标题）</code>。</p><p><ahref="https://www.bilibili.com/video/BV1d741147k2?spm_id_from=333.337.search-card.all.click">我想跳转</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">我想跳转</span>](<span class="hljs-link">#饼图（Pie）</span>)<br></code></pre></td></tr></table></figure><blockquote><p>Open Links in Typora</p><p>You can use <code>command+click</code> (macOS), or<code>ctrl+click</code> (Linux/Windows) on links in Typora to jump totarget headings, or open them in Typora, or open in related apps.</p></blockquote><p><a href="#饼图（Pie）">我想跳转</a></p><h3 id="自动链接">自动链接</h3><p>使用 <code>&lt;&gt;</code> 包括的 URL或邮箱地址会被自动转换为超链接：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml">&lt;https://www.baidu.com&gt;</span><br><br>&lt;123@email.com&gt;<br></code></pre></td></tr></table></figure><p><a href="https://www.baidu.com"class="uri">https://www.baidu.com</a></p><p><a href="mailto:123@email.com">123@email.com</a></p><h2 id="图片">图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">自己起的图片名字</span>](<span class="hljs-link">图片地址或者图片本地存储的路径</span>)<br></code></pre></td></tr></table></figure><h3 id="网上的图片">网上的图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">friedChicken</span>](<span class="hljs-link">https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg"alt="炸鸡" /><figcaption aria-hidden="true">炸鸡</figcaption></figure><h3 id="本地图片">本地图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">friedChicken</span>](<span class="hljs-link">friedChicken.jpg</span>)<br>在同一个文件夹里（用相对路径）<br>或者直接拷贝<br></code></pre></td></tr></table></figure><figure><img src="../../../桌面/Typora笔记/friedChicken.jpg"alt="friedChicken" /><figcaption aria-hidden="true">friedChicken</figcaption></figure><figure><img src="../../../桌面/cola.jpg" alt="cola" /><figcaption aria-hidden="true">cola</figcaption></figure><h2id="利用markdown画图需勾选扩展语法">利用Markdown画图（需勾选扩展语法）</h2><figure><img src="../../../桌面/Typora笔记/image-20200211211500416.png"alt="image-20200211211500416" /><figcaption aria-hidden="true">image-20200211211500416</figcaption></figure><p>markdown画图也是轻量级的，功能并不全。</p><p>Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。</p><p>（不同的编辑器渲染的可能不一样）</p><h3 id="流程图graph">流程图(graph)</h3><h4 id="概述">概述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph 方向描述<br><span class="hljs-code">    图表中的其他语句...</span><br></code></pre></td></tr></table></figure><p>关键字graph表示一个流程图的开始，同时需要指定该图的方向。</p><p>其中“方向描述”为：</p><table><thead><tr class="header"><th style="text-align: left;">用词</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">TB</td><td style="text-align: left;">从上到下</td></tr><tr class="even"><td style="text-align: left;">BT</td><td style="text-align: left;">从下到上</td></tr><tr class="odd"><td style="text-align: left;">RL</td><td style="text-align: left;">从右到左</td></tr><tr class="even"><td style="text-align: left;">LR</td><td style="text-align: left;">从左到右</td></tr></tbody></table><blockquote><p>T = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN</p></blockquote><p>最常用的布局方向是TB、LR。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB;<br>  A--&gt;B<br>  B--&gt;C<br>  C--&gt;A<br> <br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><pre><code class=" mermaid">graph LR;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><pre><code class=" mermaid">graph LR;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><h4 id="流程图常用符号及含义">流程图常用符号及含义</h4><h5 id="节点形状">节点形状</h5><table><thead><tr class="header"><th style="text-align: left;">表述</th><th style="text-align: left;">说明</th><th>含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">id<a href="#文字">文字</a></td><td style="text-align: left;">矩形节点</td><td>表示过程，也就是整个流程中的一个环节</td></tr><tr class="even"><td style="text-align: left;">id(文字)</td><td style="text-align: left;">圆角矩形节点</td><td>表示开始和结束</td></tr><tr class="odd"><td style="text-align: left;">id((文字))</td><td style="text-align: left;">圆形节点</td><td>表示连接。为避免流程过长或有交叉，可将流程切开。成对</td></tr><tr class="even"><td style="text-align: left;">id{文字}</td><td style="text-align: left;">菱形节点</td><td>表示判断、决策</td></tr><tr class="odd"><td style="text-align: left;">id&gt;文字]</td><td style="text-align: left;">右向旗帜状节点</td><td></td></tr></tbody></table><p><strong>单向箭头线段</strong>：表示流程进行方向</p><blockquote><p>id即为节点的唯一标识，A~F是当前节点名字，类似于变量名，画图时便于引用</p><p>括号内是节点中要显示的文字，默认节点的名字和显示的文字都为A</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br>  A<br>  B(圆角矩形节点)<br>  C[矩形节点]<br>  D((圆形节点))<br>  E&#123;菱形节点&#125;<br>  F&gt;右向旗帜状节点] <br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  A  B(圆角矩形节点)  C[矩形节点]  D((圆形节点))  E&#123;菱形节点&#125;  F&gt;右向旗帜状节点]</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br><span class="hljs-code">    begin(出门)--&gt; buy[买炸鸡]</span><br><span class="hljs-code">    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;</span><br><span class="hljs-code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)</span><br><span class="hljs-code">    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack</span><br><span class="hljs-code">    </span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB    begin(出门)--&gt; buy[买炸鸡]    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack    </code></pre><h5 id="连线">连线</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br>  A1--&gt;B1<br>  A2---B2<br>  A3--text---B3<br>  A4--text--&gt;B4<br>  A5-.-B5<br>  A6-.-&gt;B6<br>  A7-.text.-B7<br>  A8-.text.-&gt;B8<br>  A9===B9<br>  A10==&gt;B10<br>  A11==text===B11<br>  A12==text==&gt;B12<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  A1--&gt;B1  A2---B2  A3--text---B3  A4--text--&gt;B4  A5-.-B5  A6-.-&gt;B6  A7-.text.-B7  A8-.text.-&gt;B8  A9===B9  A10==&gt;B10  A11==text===B11  A12==text==&gt;B12</code></pre><pre><code class=" mermaid">graph TB A ---B</code></pre><h5 id="子图表">子图表</h5><p>使用以下语法添加子图表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">subgraph 子图表名称<br><span class="hljs-code">    子图表中的描述语句...</span><br><span class="hljs-code">end</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br><span class="hljs-code">  subgraph 买炸鸡前</span><br><span class="hljs-code">    begin(出门)--&gt; buy[出门买炸鸡]</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;</span><br><span class="hljs-code">    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)</span><br><span class="hljs-code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  subgraph 买炸鸡前    begin(出门)--&gt; buy[出门买炸鸡]    end    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</code></pre><h3 id="序列图sequence-diagram">序列图(sequence diagram)</h3><h4 id="概述-1">概述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram <br><span class="hljs-code">[参与者1][消息线][参与者2]:消息体</span><br><span class="hljs-code">    ...</span><br></code></pre></td></tr></table></figure><blockquote><p><code>sequenceDiagram</code> 为每幅时序图的固定开头</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">Title: 买炸鸡</span><br><span class="hljs-code">    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？</span><br><span class="hljs-code">    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagramTitle: 买炸鸡    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</code></pre><h4 id="参与者participant">参与者（participant）</h4><p>传统时序图概念中参与者有角色和类对象之分，但这里我们不做此区分，用参与者表示一切参与交互的事物，可以是人、类对象、系统等形式。中间竖直的线段从上至下表示时间的流逝。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 参与者 1</span><br><span class="hljs-code">    participant 参与者 2</span><br><span class="hljs-code">    ...</span><br><span class="hljs-code">    participant 简称 as 参与者 3 #该语法可以在接下来的描述中使用简称来代替参与者 3</span><br></code></pre></td></tr></table></figure><blockquote><p><code>participant &lt;参与者名称&gt;</code>声明参与者，语句次序即为参与者横向排列次序。</p></blockquote><h4 id="消息线">消息线</h4><table><thead><tr class="header"><th style="text-align: left;">类型</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">-&gt;</td><td style="text-align: left;">无箭头的实线</td></tr><tr class="even"><td style="text-align: left;">--&gt;</td><td style="text-align: left;">无箭头的虚线</td></tr><tr class="odd"><td style="text-align: left;">-&gt;&gt;</td><td style="text-align: left;">有箭头的实线（主动发出消息）</td></tr><tr class="even"><td style="text-align: left;">–-&gt;&gt;</td><td style="text-align: left;">有箭头的虚线（响应）</td></tr><tr class="odd"><td style="text-align: left;">-x</td><td style="text-align: left;">末端为叉的实线（表示异步）</td></tr><tr class="even"><td style="text-align: left;">--x</td><td style="text-align: left;">末端为叉的虚线（表示异步）</td></tr></tbody></table><h4 id="处理中-激活框">处理中-激活框</h4><p>从消息接收方的时间线上标记一小段时间，表示对消息进行处理的时间间隔。</p><p>在消息线末尾增加 <code>+</code>，则消息接收者进入当前消息的“处理中”状态； 在消息线末尾增加<code>-</code> ，则消息接收者离开当前消息的“处理中”状态。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -x +seller:给我炸！</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller:给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！    </code></pre><h4 id="注解note">注解（note）</h4><p>语法如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Note 位置表述 参与者: 标注文字<br></code></pre></td></tr></table></figure><p>其中位置表述可以为</p><table><thead><tr class="header"><th style="text-align: left;">表述</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">right of</td><td style="text-align: left;">右侧</td></tr><tr class="even"><td style="text-align: left;">left of</td><td style="text-align: left;">左侧</td></tr><tr class="odd"><td style="text-align: left;">over</td><td style="text-align: left;">在当中，可以横跨多个参与者</td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    Note over 99,seller : 热爱炸鸡</span><br><span class="hljs-code">    Note left of 99 : 女</span><br><span class="hljs-code">    Note right of seller : 男</span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -x +seller : 给我炸！</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    Note over 99,seller : 热爱炸鸡    Note left of 99 : 女    Note right of seller : 男    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller : 给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！</code></pre><h4 id="循环loop">循环（loop）</h4><p>在条件满足时，重复发出消息序列。（相当于编程语言中的 while语句。）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">   </span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -&gt;&gt; +seller:给我炸！</span><br><span class="hljs-code">    loop 三分钟一次</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 我的炸鸡好了吗？</span><br><span class="hljs-code">        seller --&gt;&gt; 99 : 正在炸</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥       99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -&gt;&gt; +seller:给我炸！    loop 三分钟一次        99 -&gt;&gt; seller : 我的炸鸡好了吗？        seller --&gt;&gt; 99 : 正在炸    end    seller --&gt;&gt; -99: 您的炸鸡好了！</code></pre><h4 id="选择alt">选择（alt）</h4><p>在多个条件中作出判断，每个条件将对应不同的消息序列。（相当于 if 及else if 语句。）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram    <br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？</span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 可卖的炸鸡数</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    alt 可卖的炸鸡数 &gt; 3</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 买三只！</span><br><span class="hljs-code">    else 1 &lt; 可卖的炸鸡数 &lt; 3</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 有多少买多少</span><br><span class="hljs-code">    else 可卖的炸鸡数 &lt; 1</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 那我明天再来</span><br><span class="hljs-code">    end</span><br><span class="hljs-code"></span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 欢迎下次光临</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram        participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？    seller --&gt;&gt; 99 : 可卖的炸鸡数        alt 可卖的炸鸡数 &gt; 3        99 -&gt;&gt; seller : 买三只！    else 1 &lt; 可卖的炸鸡数 &lt; 3        99 -&gt;&gt; seller : 有多少买多少    else 可卖的炸鸡数 &lt; 1        99 -&gt;&gt; seller : 那我明天再来    end    seller --&gt;&gt; 99 : 欢迎下次光临</code></pre><h4 id="可选opt">可选（opt）</h4><p>在某条件满足时执行消息序列，否则不执行。相当于单个分支的 if语句。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller : 买炸鸡</span><br><span class="hljs-code">    opt 全都卖完了</span><br><span class="hljs-code">        seller --&gt;&gt; 99 : 下次再来</span><br><span class="hljs-code">    end</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 买炸鸡    opt 全都卖完了        seller --&gt;&gt; 99 : 下次再来    end</code></pre><h4 id="并行par">并行（Par）</h4><p>将消息序列分成多个片段，这些片段并行执行。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br>   participant 99 as 救救<br>   participant seller as 炸鸡店小哥<br>   <br><span class="hljs-code">    99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！</span><br><span class="hljs-code"></span><br><span class="hljs-code">    par 并行执行</span><br><span class="hljs-code">        seller -&gt;&gt; seller : 装可乐</span><br><span class="hljs-code">    and</span><br><span class="hljs-code">        seller -&gt;&gt; seller : 炸炸鸡</span><br><span class="hljs-code">    end</span><br><span class="hljs-code"></span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram   participant 99 as 救救   participant seller as 炸鸡店小哥       99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！    par 并行执行        seller -&gt;&gt; seller : 装可乐    and        seller -&gt;&gt; seller : 炸炸鸡    end    seller --&gt;&gt; 99 : 您的炸鸡好了！</code></pre><h3 id="饼图pie">饼图（Pie）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">pie    title Pie Chart    &quot;Dogs&quot; : 386    &quot;Cats&quot; : 85    &quot;Rats&quot; : 150     &quot;panda&quot; : 200</code></pre><blockquote><p><ahref="http://support.typora.io/Draw-Diagrams-With-Markdown/">Typora支持mermaid的官方链接</a></p></blockquote><h3 id="甘特图gantt">甘特图（gantt）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"> title 标题<br>dateFormat 日期格式<br>section 部分名<br>任务名:参数一, 参数二, 参数三, 参数四，参数五<br><br> //参数一：crit（是否重要，红框框） 或者 不填<br> //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态)<br> //参数三：取小名 或者 不填<br> //参数四：任务开始时间<br> //参数五：任务结束时间<br></code></pre></td></tr></table></figure><blockquote><p><ahref="https://mermaid-js.github.io/mermaid/#/gantt">官方教程</a></p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gantt</span><br>       <span class="hljs-attribute">dateFormat</span>  YYYY-MM-DD<br>       <span class="hljs-attribute">title</span> Adding GANTT diagram functionality to mermaid<br><br>       <span class="hljs-attribute">section</span> A section<br>       <span class="hljs-attribute">Completed</span> task            :done,    des1, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span><br>       <span class="hljs-attribute">Active</span> task               :active,  des2, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">09</span>, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Future</span> task               :         des3, after des2, <span class="hljs-number">5</span>d<br>       <span class="hljs-attribute">Future</span> task2              :         des4, after des3, <span class="hljs-number">5</span>d<br><br>       <span class="hljs-attribute">section</span> Critical tasks<br>       <span class="hljs-attribute">Completed</span> task in the critical line :crit, done, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">24</span>h<br>       <span class="hljs-attribute">Implement</span> parser and jison          :crit, done, after des1, <span class="hljs-number">2</span>d<br>       <span class="hljs-attribute">Create</span> tests for parser             :crit, active, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Future</span> task in critical line        :crit, <span class="hljs-number">5</span>d<br>       <span class="hljs-attribute">Create</span> tests for renderer           :<span class="hljs-number">2</span>d<br>       <span class="hljs-attribute">Add</span> to mermaid                      :<span class="hljs-number">1</span>d<br><br>       <span class="hljs-attribute">section</span> Documentation<br>       <span class="hljs-attribute">Describe</span> gantt syntax               :active, a1, after des1, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Add</span> gantt diagram to demo page      :after a1  , <span class="hljs-number">20</span>h<br>       <span class="hljs-attribute">Add</span> another diagram to demo page    :doc1, after a1  , <span class="hljs-number">48</span>h<br><br>       <span class="hljs-attribute">section</span> Last section<br>       <span class="hljs-attribute">Describe</span> gantt syntax               :after doc1, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Add</span> gantt diagram to demo page      :<span class="hljs-number">20</span>h<br>       <span class="hljs-attribute">Add</span> another diagram to demo page    :<span class="hljs-number">48</span>h<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">gantt       dateFormat  YYYY-MM-DD       title Adding GANTT diagram functionality to mermaid       section A section       Completed task            :done,    des1, 2014-01-06,2014-01-08       Active task               :active,  des2, 2014-01-09, 3d       Future task               :         des3, after des2, 5d       Future task2              :         des4, after des3, 5d       section Critical tasks       Completed task in the critical line :crit, done, 2014-01-06,24h       Implement parser and jison          :crit, done, after des1, 2d       Create tests for parser             :crit, active, 3d       Future task in critical line        :crit, 5d       Create tests for renderer           :2d       Add to mermaid                      :1d       section Documentation       Describe gantt syntax               :active, a1, after des1, 3d       Add gantt diagram to demo page      :after a1  , 20h       Add another diagram to demo page    :doc1, after a1  , 48h       section Last section       Describe gantt syntax               :after doc1, 3d       Add gantt diagram to demo page      :20h       Add another diagram to demo page    :48h</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/05/hello-world/"/>
    <url>/2024/04/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
