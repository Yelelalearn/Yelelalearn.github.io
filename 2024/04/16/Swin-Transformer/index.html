

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.jpg">
  <link rel="icon" href="/img/fluid.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yelearn">
  <meta name="keywords" content="">
  
    <meta name="description" content="Swin Transformer: Hierarchical Vision Transformer using Shifted Windows 摘要 本论文提出了一种名为Swin Transformer的新型视觉Transformer模型，它能够作为通用的计算机视觉骨干网络。">
<meta property="og:type" content="article">
<meta property="og:title" content="Swin Transformer：使用偏移窗口的分层视觉变换器">
<meta property="og:url" content="https://yelelalearn.github.io/2024/04/16/Swin-Transformer/index.html">
<meta property="og:site_name" content="叶鹏翔的博客">
<meta property="og:description" content="Swin Transformer: Hierarchical Vision Transformer using Shifted Windows 摘要 本论文提出了一种名为Swin Transformer的新型视觉Transformer模型，它能够作为通用的计算机视觉骨干网络。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/661b82f968eb935713d6b9c4.png">
<meta property="article:published_time" content="2024-04-16T05:14:18.000Z">
<meta property="article:modified_time" content="2024-04-27T07:18:34.657Z">
<meta property="article:author" content="Yelearn">
<meta property="article:tag" content="翻译">
<meta property="article:tag" content="论文阅读">
<meta property="article:tag" content="Swin Transformer">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/661b82f968eb935713d6b9c4.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Swin Transformer：使用偏移窗口的分层视觉变换器 - 叶鹏翔的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yelelalearn.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":21863687,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  
    <!-- 51.la Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript('//js.users.51.la/21863687.js');
      }
    </script>
  

  

  



  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>In The Study</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://pic.imgdb.cn/item/661b82f968eb935713d6b9c4.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Swin Transformer：使用偏移窗口的分层视觉变换器"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-16 13:14" pubdate>
          2024年4月16日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          76 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Swin Transformer：使用偏移窗口的分层视觉变换器</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2024-04-27T15:18:34+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <p>Swin Transformer: Hierarchical Vision Transformer using Shifted
Windows</p>
<h2 id="摘要">摘要</h2>
<p>本论文提出了一种名为Swin
Transformer的新型视觉Transformer模型，它能够作为通用的计算机视觉骨干网络。</p>
<span id="more"></span>
<p>从语言到视觉的Transformer模型的适应性挑战源于两个领域之间的差异，如视觉实体的尺度变化较大以及图像中像素的高分辨率相对于文本中的单词。为了解决这些差异，我们提出了一种分层Transformer，其表示是通过<em>偏移窗口</em>计算的。偏移窗口方案通过将自注意力计算限制<strong>在非重叠的本地窗口内</strong>，同时也允许跨窗口连接，从而带来了更高的效率。这种分层架构具有在不同尺度上建模的灵活性，并且在图像大小方面具有<em>线性的计算复杂度</em>。Swin
Transformer的这些特性使其与广泛范围的视觉任务兼容，包括图像分类（在ImageNet-1K上的87.3的top-1准确度）以及密集预测任务，如目标检测（在COCO测试集上的58.7的box
AP和51.1的mask
AP）和语义分割（在ADE20K验证集上的53.5的mIoU）。其性能大大超越了先前的最先进技术，分别在COCO上提升了+2.7的box
AP和+2.6的mask
AP，并在ADE20K上提升了+3.2的mIoU，显示了基于Transformer的模型作为视觉骨干的潜力。分层设计和偏移窗口方法也对所有MLP架构具有益处。代码和模型可以在<a
target="_blank" rel="noopener" href="https://github.com/microsoft/Swin-Transformer">https://github.com/microsoft/Swin-Transformer</a>
上公开获取。</p>
<h2 id="引言">1、引言</h2>
<p>计算机视觉中的建模长期以来一直由卷积神经网络（CNNs）主导。从AlexNet的问世以及它在ImageNet图像分类挑战中的革命性表现开始，CNN架构通过规模的扩大、连接的加强以及更复杂形式的卷积等方式变得越来越强大。由于CNNs在各种视觉任务中作为骨干网络，这些架构的进步导致了性能的提升，从而广泛推动了整个领域的发展。</p>
<p>另一方面，在自然语言处理（NLP）中，网络架构的演变走上了一条不同的道路，如今普遍的架构是Transformer。Transformer设计用于序列建模和转录任务，其以使用注意力机制来建模数据中的长距离依赖关系而引人注目。它在语言领域取得了巨大的成功，这导致研究人员研究如何将其应用于计算机视觉，最近在特定任务上取得了有希望的结果，特别是在图像分类和联合视觉-语言建模方面。</p>
<p>在本论文中，我们试图扩展Transformer的适用性，使其能够像在NLP中一样成为计算机视觉的通用骨干网络，就像CNN在视觉中一样。我们观察到，在将其在语言领域的高性能转移到视觉领域时，存在着显著的挑战，这可以通过两种模态之间的差异来解释。其中之一涉及到尺度。与在语言Transformer中作为处理基本单元的单词标记不同，视觉元素的尺度可以有很大的变化，这在诸如目标检测等任务中受到关注。在现有的基于Transformer的模型中，标记都是固定尺度的，这在视觉应用中不合适。另一个差异是图像中像素的分辨率要比文本段落中的单词高得多。存在许多像语义分割这样的视觉任务需要在像素级别进行密集预测，对于高分辨率图像来说，这将变得棘手，因为其自注意力的计算复杂度与图像尺寸的平方成正比。</p>
<p><strong>为了克服这些问题</strong> ，我们提出了一个名为Swin
Transformer的通用Transformer骨干网络，它构建了分层特征图，并具有线性的图像大小计算复杂度。如<a
href="#图1">图1(a)</a>所示，Swin
Transformer通过从小尺寸的图块开始（用灰色轮廓标出）并逐渐合并深层Transformer层中的相邻图块来构建分层表示。借助这些分层特征图，Swin
Transformer模型可以方便地利用高级技术进行像素级别的密集预测，如特征金字塔网络（FPN）或U-Net。通过在划分图像的非重叠窗口内局部计算自注意力来实现线性的计算复杂度（用红色轮廓标出）。每个窗口中的图块数量是固定的，因此复杂度变为与图像大小成线性关系。这些优点使得Swin
Transformer能够成为各种视觉任务的通用骨干网络，与之前的基于Transformer的架构形成对比，后者只能生成单一分辨率的特征图，并具有二次复杂度。</p>
<p><img src="https://pic.imgdb.cn/item/661e0a7c0ea9cb1403e039f2.png" srcset="/img/loading.gif" lazyload alt="tu_1" style="zoom:67%;" /></p>
<div data-align="center">
<strong><a name="图1">图1. (a) 提出的Swin
Transformer通过在更深的层次中合并图像块（灰色显示）来构建分层特征图，并且由于仅在每个本地窗口内计算自注意力（红色显示），它对输入图像大小具有线性的计算复杂度。因此，它可以作为图像分类和密集识别任务的通用骨干网络。
(b) 相比之下，先前的视觉Transformer [20]
生成单一低分辨率的特征图，并且由于在全局范围内计算自注意力，对输入图像大小具有二次计算复杂度。</a></strong>
</div>
<p>Swin
Transformer的一个关键设计元素是在连续的自注意层之间移动窗口划分，如<a
href="#图2">图2</a>所示。</p>
<p><img src="https://pic.imgdb.cn/item/661e0a7d0ea9cb1403e03aa9.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 33%;" /></p>
<div data-align="center">
<strong><a name="图2">图2. 展示了在提议的Swin
Transformer架构中计算自注意力的移位窗口方法。在第l层（左侧），采用了常规的窗口分区方案，并在每个窗口内计算自注意力。在下一层l
+
1（右侧），窗口分区被移位，产生了新的窗口。在新窗口中的自注意力计算穿越了第l层中先前窗口的边界，从而在它们之间建立了连接。</a></strong>
</div>
<p>移动的窗口连接了前一层的窗口，提供了它们之间的连接，显著增强了建模能力（参见<a
href="#表4">表4</a>）。这种策略在实际应用的延迟方面也很高效：<u>窗口内的所有查询块共享相同的键集</u>，这有利于硬件中的内存访问。相比之下，早期基于滑动窗口的自注意方法在一般硬件上存在延迟较低的问题，因为不同的查询像素有不同的键集。我们的实验证明，所提出的移动窗口方法比滑动窗口方法具有更低的延迟，但在建模能力上类似（见<a
href="#表5">表5</a>和<a
href="#表6">表6</a>）。<em>移动窗口方法也对所有MLP架构具有益处</em>。</p>
<p>所提出的Swin
Transformer在图像分类、目标检测和语义分割等识别任务上取得了强劲的性能。它在这三个任务上的性能显著优于ViT
/ DeiT [20, 63] 和ResNe(X)t模型 [30,
70]，并且具有类似的延迟。其在COCO测试集的58.7的box AP和51.1的mask
AP超过了先前最先进的结果，分别提高了+2.7的box AP（无外部数据的Copy-paste
[26]）和+2.6的mask AP（DetectoRS
[46]）。在ADE20K语义分割任务中，它在验证集上获得了53.5的mIoU，比先前最先进的SETR
[81]提高了+3.2的mIoU。在ImageNet-1K图像分类任务中，它实现了87.3%的top-1准确度。</p>
<p>我们相信，在计算机视觉和自然语言处理之间采用统一的架构可以使两个领域受益，因为它将便于对视觉和文本信号进行联合建模，并且可以更深入地共享两个领域的建模知识。我们希望Swin
Transformer在各种视觉问题上的优异性能可以在社区中深化这种信念，并鼓励对视觉和语言信号进行统一建模。</p>
<h2 id="相关工作">2、 相关工作</h2>
<p><strong>CNN及其变体</strong>
CNN（卷积神经网络）在整个计算机视觉领域作为标准网络模型。虽然CNN已经存在了几十年[40]，但直到AlexNet的引入[39]，CNN才起飞并成为主流。自那时以来，人们提出了更深层次、更有效的卷积神经网络架构，进一步推动了计算机视觉中的深度学习浪潮，例如VGG
[52]、GoogleNet [57]、ResNet [30]、DenseNet [34]、HRNet
[65]和EfficientNet [58]等。</p>
<p>除了这些架构的进步，还有许多关于改进单个卷积层的工作，如深度卷积[70]和可变形卷积[18,
84]。虽然CNN及其变体仍然是计算机视觉应用的主要骨干架构，但我们强调了类似Transformer的架构在视觉和语言之间进行统一建模的巨大潜力。我们的工作在几个基本的视觉识别任务上取得了强劲的性能，我们希望它能对模型的发展方向做出一定的贡献。</p>
<p><strong>基于自注意力的骨干网络架构</strong>
受到自注意力层和Transformer在自然语言处理领域的成功启发，一些研究利用自注意力层来替代流行的ResNet中的一些或全部空间卷积层[33,
50,
80]。在这些研究中，自注意力是在每个像素的局部窗口内计算的，以加速优化过程[33]，并且它们在准确性和计算量之间取得了稍微更好的平衡，相比于ResNet架构。然而，它们昂贵的内存访问导致了实际延迟明显大于卷积网络[33]。我们提出了在连续层之间移动窗口的方法，而不是使用滑动窗口，这使得在通用硬件上能够更高效地实现。</p>
<p><strong>自注意力/Transformer以补充CNN</strong>
另一方面，一些工作尝试将标准的CNN架构与自注意力层或Transformer相结合。自注意力层可以通过提供编码远程依赖关系或异质交互的能力来增强骨干网络[67,
7, 3, 71, 23, 74, 55]或头部网络[32,
27]。最近，Transformer中的编码-解码设计已经应用于目标检测和实例分割任务[8,
13, 85,
56]。我们的工作探索了将Transformer用于基本视觉特征提取的适应性，与这些工作相辅相成。</p>
<p><strong>基于Transformer的视觉骨干网络</strong>
与我们的工作最相关的是Vision Transformer（ViT）[20]及其后续研究[63, 72,
15, 28,
66]。ViT的开创性工作直接将Transformer架构应用于非重叠的中等大小图像块，用于图像分类。与卷积网络相比，它在图像分类方面取得了令人印象深刻的速度-准确性平衡。虽然ViT需要大规模训练数据集（如JFT-300M）才能表现良好，但DeiT
[63]引入了一些训练策略，使得ViT在使用较小的ImageNet-1K数据集时也能有效。ViT在图像分类任务上的结果令人鼓舞，但其架构不适用于作为密集视觉任务的通用骨干网络，或者当输入图像分辨率较高时，由于其低分辨率的特征图以及与图像大小成二次方增加的复杂度。</p>
<p>有一些研究将ViT模型应用于目标检测和语义分割等密集视觉任务，通过直接上采样或反卷积的方式，但性能相对较低[2,
81]。与我们同时进行的工作是一些修改ViT架构以获得更好图像分类性能的研究[72,
15, 28]。经验上，我们发现我们的Swin
Transformer架构在图像分类方面在这些方法中实现了最佳的速度-准确性平衡，尽管我们的工作侧重于通用性能而不是专门分类。</p>
<p>另一项同时进行的工作[66]探索了一条类似的思路，以在Transformers中构建多分辨率特征图。它的复杂度仍然与图像大小成二次方，而我们的复杂度是线性的，同时也是在本地操作的，这在建模视觉信号中的高相关性方面已被证明是有效的。我们的方法既高效又有效，实现了在COCO目标检测和ADE20K语义分割上的最先进准确性。</p>
<h2 id="模型">3、 模型</h2>
<h3 id="总体架构">3.1 总体架构</h3>
<p><a href="#图3">图3</a>展示了Swin
Transformer架构的概览，图中展示了迷你版本（Swin-T）。</p>
<figure>
<img src="https://pic.imgdb.cn/item/661e0a7d0ea9cb1403e03b13.png" srcset="/img/loading.gif" lazyload
alt="tu_3" />
<figcaption aria-hidden="true">tu_3</figcaption>
</figure>
<div data-align="center">
<strong><a name="图3">图3. (a) Swin Transformer（Swin-T）的架构；(b)
两个连续的Swin
Transformer块（使用方程（3）的符号表示）。W-MSA和SW-MSA分别是具有常规和移位窗口配置的多头自注意力模块。</a></strong>
</div>
<p>首先，它通过一个补丁分割模块将输入的RGB图像分割成非重叠的补丁，类似于ViT。每个补丁被视为一个“标记”，其特征被设置为原始像素RGB值的连接。在我们的实现中，我们使用了一个4×4的补丁大小，因此每个补丁的特征维度为
<span class="math inline">\(4×4×3=48\)</span>
。然后，在这个原始值特征上应用一个线性嵌入层，将其投影到一个任意维度（记作
<span class="math inline">\(C\)</span> ）。</p>
<p>对这些补丁标记应用了多个带有修改的自注意力计算的Transformer块（称为Swin
Transformer块）。这些Transformer块保持了标记的数量（<span
class="math inline">\({H\over4} ×
{W\over4}\)</span>），与线性嵌入一起被称为“<strong>阶段</strong>1”。</p>
<p>为了产生一个分层表示，随着网络变得更深，标记的数量通过补丁合并层进行减少。第一个补丁合并层将每组
<span class="math inline">\(2×2\)</span>
相邻补丁的特征连接起来，并在4C维度的连接特征上应用一个线性层。这将标记的数量减少了
<span class="math inline">\(2×2=4\)</span> 倍（分辨率降低了 <span
class="math inline">\(2\)</span> 倍），输出维度设置为 <span
class="math inline">\(2C\)</span> 。随后，应用Swin
Transformer块进行特征变换，分辨率保持在 <span
class="math inline">\({H\over8} × {W\over8}\)</span>
。这个第一个补丁合并和特征变换的阶段被标记为<strong>“阶段2”</strong>。这个过程重复两次，分别作为<strong>“阶段3”</strong>和<strong>“阶段4”</strong>，输出分辨率分别为
<span class="math inline">\({H\over16} × {W\over16}\)</span> 和 <span
class="math inline">\({H\over32}× {W\over32}\)</span>
。这些阶段共同产生了一个分层表示，其特征图分辨率与典型的卷积网络（如VGG
[52] 和 ResNet [30]）相同。</p>
<p>因此，所提出的架构可以方便地替代现有方法中的骨干网络，用于各种视觉任务。</p>
<p><strong>Swin Transformer块</strong> Swin
Transformer通过将Transformer块中的标准多头自注意力（MSA）模块替换为基于移动窗口的模块（在第3.2节中描述），同时保持其他层不变而构建。如<a
href="#图3">图3(b)</a>所示，一个Swin
Transformer块包括一个基于移动窗口的MSA模块，后跟一个包含GELU非线性的2层MLP。在每个MSA模块和每个MLP之前都应用了一个LayerNorm（LN）层，并在每个模块后应用了一个残差连接。</p>
<h3 id="基于移动窗口的自注意力">3.2. 基于移动窗口的自注意力</h3>
<p>标准的Transformer架构[64]以及其用于图像分类的调整版本[20]都进行全局自注意力计算，其中计算了一个标记与所有其他标记之间的关系。全局计算导致了相对于标记数量的二次复杂度，这使得它在许多需要大量标记进行密集预测或表示高分辨率图像的视觉问题中不适用。</p>
<p><strong>非重叠窗口内的自注意力</strong></p>
<p>为了实现高效建模，我们提议在本地窗口内计算自注意力。这些窗口以非重叠的方式均匀划分图像。假设每个窗口包含
<span class="math inline">\(M × M\)</span>
个补丁，全局MSA模块和基于图像的窗口的计算复杂度分别如下：</p>
<p><span class="math display">\[
Ω(MSA) = 4hwC² + 2(hw)²C，
\]</span></p>
<p><span class="math display">\[
Ω(W-MSA) = 4hwC² + 2M²hwC,
\]</span></p>
<p>其中前者相对于补丁数量 <span class="math inline">\(hw\)</span>
是二次复杂度，而后者在固定 <span class="math inline">\(M\)</span>
（默认为 <span class="math inline">\(7\)</span> ）时是线性的。对于大的
<span class="math inline">\(hw\)</span>
值，全局自注意力计算通常是无法承受的，而基于窗口的自注意力是可扩展的。</p>
<p><strong>连续模块中的移动窗口划分</strong>
基于窗口的自注意力模块缺乏窗口之间的连接，这限制了其建模能力。为了在保持非重叠窗口的高效计算的同时引入跨窗口连接，我们提出了一种移动窗口划分方法，在连续的Swin
Transformer块中交替使用两种划分配置。</p>
<p>如<a
href="#图2">图2</a>表示，第一个模块使用常规的窗口划分策略，从左上角像素开始，
<span class="math inline">\(8×8\)</span> 的特征图被均匀划分成 <span
class="math inline">\(4×4\)</span> 大小的 <span
class="math inline">\(2×2\)</span> 窗口（ <span class="math inline">\(M
= 4\)</span>
）。然后，下一个模块采用了一个窗口配置，它从前一层的配置中移位，通过将窗口从常规划分的窗口中移动（
<span class="math inline">\(\lfloor M/2，M/2\rfloor\)</span>
）个像素。</p>
<p><span class="math inline">\(\hat{z}^{l}=W-MSA(LN(z^{l-1}))+z^{l-1},
\\\)</span></p>
<p><span class="math inline">\(z^l=MLP(LN(\hat{z}^l))+\hat{z}^l,
\\\)</span></p>
<p><span
class="math inline">\(\hat{z}^{l+1}=SW-MSA(LN(z^l))+z^l,\)</span></p>
<p><span
class="math inline">\(z^{l+1}=MLP(LN(\hat{z}^{l+1}))+\hat{z}^{l+1},
\\\)</span></p>
<p>这里 <span class="math inline">\(\hat{z}^{l}\)</span> 和 <span
class="math inline">\({z}^{l}\)</span> 分别表示块 <span
class="math inline">\(l\)</span> 的 (S)W-MSA 模块和 MLP
模块的输出特征；W-MSA 和 SW-MSA
分别表示基于常规和移动窗口划分配置的窗口式多头自注意力。</p>
<p>移动窗口划分方法在前一层中引入了相邻非重叠窗口之间的连接，并在图像分类、目标检测和语义分割等任务中被发现是有效的，如<a
href="#表4">表4</a>所示。</p>
<p><strong>对于移动配置的高效批处理计算</strong>
移动窗口划分的一个问题是它会导致更多的窗口，从 <span
class="math inline">\(\lceil {h\over M}\rceil \times \lceil {w\over
M}\rceil\)</span> 到 <span class="math inline">\((\lceil {h\over
M}\rceil+1 )\times (\lceil {w\over M}\rceil+1)\)</span>
在移动配置中，其中一些窗口将小于 <span class="math inline">\(M ×
M\)</span> 。一个简单的解决方案是将较小的窗口填充到 <span
class="math inline">\(M × M\)</span>
的大小，并在计算注意力时将填充的值屏蔽掉。当常规划分中窗口的数量较小时，例如
<span class="math inline">\(2 × 2\)</span>
，采用这种简单解决方案会导致显著的增加计算量（<span
class="math inline">\(2 × 2\rightarrow 3 ×
3\)</span>，增加了2.25倍）。</p>
<p>在这里，我们提出了一种更高效的批处理计算方法，通过向左上方向循环移位，如<a
href="#图4"><strong>图4</strong></a>所示。</p>
<figure>
<img src="https://pic.imgdb.cn/item/661e0a7d0ea9cb1403e03b81.png" srcset="/img/loading.gif" lazyload
alt="tu_4" />
<figcaption aria-hidden="true">tu_4</figcaption>
</figure>
<div data-align="center">
<strong>图4.
对于在移位窗口分区中的自注意力的高效批处理计算方法的示意图。</strong>
</div>
<p>在这种移位后，一个批处理窗口可能由几个在特征图中不相邻的子窗口组成，因此采用了一个掩码机制来限制自注意力计算在每个子窗口内进行。通过循环移位，批处理窗口的数量保持与常规窗口划分相同，因此也是高效的。这种方法的低延迟在<a
href="#表5">表5</a>中显示。</p>
<p><strong>相对位置偏置</strong> 在计算自注意力时，我们遵循[49, 1, 32,
33]的做法，通过在计算相似性时为每个头部添加一个相对位置偏置 <span
class="math inline">\(B ∈ \R ^{M^2×M^2}\)</span> ：</p>
<p><span class="math display">\[
\text{Attention(Q, K, V)} = \text {SoftMax}(QKᵀ /\sqrt  {d} + B)V,
\]</span></p>
<p>其中 $Q, K, V ∈ <sup>{M</sup>2×d} $ 是查询、键和值矩阵；<span
class="math inline">\(d\)</span> 是查询/键的维度，<span
class="math inline">\(M^2\)</span>
是窗口中的补丁数量。由于每个轴上的相对位置在范围<span
class="math inline">\([-M + 1, M -
1]\)</span>内，我们将一个尺寸较小的偏置矩阵 <span
class="math inline">\(\hat{B}∈ \R^{(2M-1)×(2M-1)}\)</span>
参数化，并且从 <span class="math inline">\(\hat{B}\)</span> 中取出 <span
class="math inline">\(B\)</span> 中的值。</p>
<p>我们观察到相对位置偏置项明显改善了与没有该偏置项或使用绝对位置嵌入的对应模型相比的性能，如<a
href="#表4">表4</a>所示。进一步将绝对位置嵌入添加到输入中（如[20]中所示）会略微降低性能，因此在我们的实现中没有采用这种方法。</p>
<p>在预训练过程中学到的相对位置偏置也可以用于通过双三次插值[20,
63]初始化具有不同窗口大小的模型，以进行微调。</p>
<h3 id="架构变体">3.3. 架构变体</h3>
<p>我们构建了我们的基础模型，称为Swin-B，其模型大小和计算复杂度与ViT-B/DeiT-B类似。我们还介绍了Swin-T、Swin-S和Swin-L，它们的模型大小和计算复杂度分别为基础模型的0.25×、0.5×和2×。请注意，Swin-T和Swin-S的复杂度与ResNet-50（DeiT-S）和ResNet-101相似，窗口大小默认设置为<span
class="math inline">\(M = 7\)</span>。每个头的查询维度为<span
class="math inline">\(d = 32\)</span>，每个MLP的扩展层为<span
class="math inline">\(α =
4\)</span>，对于所有实验，这些模型变体的架构超参数如下：</p>
<ul>
<li>Swin-T: C = 96, 层级数量 = {2, 2, 6, 2}</li>
<li>Swin-S: C = 96, 层级数量 = {2, 2, 18, 2}</li>
<li>Swin-B: C = 128, 层级数量 = {2, 2, 18, 2}</li>
<li>Swin-L: C = 192, 层级数量 = {2, 2, 18, 2}</li>
</ul>
<p>这里的 <span class="math inline">\(C\)</span>
是第一个阶段隐藏层的通道数。模型大小、理论计算复杂度（FLOPs）以及用于ImageNet图像分类的模型变体的吞吐量详见<a
href="#表1">表1</a>。</p>
<h2 id="实验">4、 实验</h2>
<p>我们在ImageNet-1K图像分类[19]、COCO目标检测[43]和ADE20K语义分割[83]上进行了实验。接下来，我们首先将提出的Swin
Transformer架构与先前的技术水平进行比较，然后对Swin
Transformer的重要设计元素进行了实验验证。</p>
<h3 id="imagenet-1k上的图像分类">4.1. ImageNet-1K上的图像分类</h3>
<p><strong>设置：</strong>对于图像分类，我们在ImageNet-1K
[19]上评估了提出的Swin
Transformer，该数据集包含来自1,000个类别的1.28M训练图像和50K验证图像。我们报告了单个裁剪的top-1准确度。我们考虑了两种训练设置：</p>
<ul>
<li><p>常规的ImageNet-1K训练：此设置主要遵循[63]。我们使用AdamW
[37]优化器进行300个epoch的训练，使用余弦衰减学习率调度器和20个epoch的线性热身。我们使用批大小为1024，初始学习率为0.001，权重衰减为0.05。在训练中，我们包括了[63]中的大多数增强和正则化策略，但不包括重复的增强[31]和EMA
[45]，因为它们并不能提升性能。值得注意的是，这与[63]相反，在ViT的训练中，重复的增强对于稳定训练是至关重要的。</p></li>
<li><p>在ImageNet-22K上进行预训练，然后在ImageNet-1K上进行微调：我们还在更大的ImageNet-22K数据集上进行预训练，该数据集包含了1420万张图像和22,000个类别。我们使用AdamW优化器进行90个epoch的训练，使用线性衰减学习率调度器和5个epoch的线性热身。我们使用批大小为4096，初始学习率为0.001，权重衰减为0.01。在ImageNet-1K的微调中，我们使用批大小为1024，学习率保持为<span
class="math inline">\(10^{-5}\)</span>，权重衰减为<span
class="math inline">\(10^{-8}\)</span>，训练模型30个epoch。</p></li>
</ul>
<p><strong>常规ImageNet-1K训练的结果。</strong> 如<a
href="#表1(a)"><strong>表1(a)</strong></a>所示，其中与其他主干网络进行了比较，包括基于Transformer和ConvNet的网络。</p>
<div data-align="center">
<strong><a name="表1">表1.
在ImageNet-1K分类任务上不同骨干网络的比较。吞吐量使用[68]的GitHub存储库和V100
GPU进行测量，遵循[63]的方法。</a></strong>
</div>
<div data-align="center">
<strong><a name="表1(a)">(a)
使用常规的ImageNet-1K训练的模型</a></strong>
</div>
<table>

<thead>
<tr class="header">
<th>方法</th>
<th>图像尺寸</th>
<th>参数数量</th>
<th>计算量 (FLOPs)</th>
<th>吞吐量 (图像/秒)</th>
<th>ImageNet Top-1 准确率</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RegNetY-4G [48]</td>
<td>224x224</td>
<td>21M</td>
<td>4.0G</td>
<td>1156.7</td>
<td>80.0</td>
</tr>
<tr class="even">
<td>RegNetY-8G [48]</td>
<td>224x224</td>
<td>39M</td>
<td>8.0G</td>
<td>591.6</td>
<td>81.7</td>
</tr>
<tr class="odd">
<td>RegNetY-16G [48]</td>
<td>224x224</td>
<td>84M</td>
<td>16.0G</td>
<td>334.7</td>
<td>82.9</td>
</tr>
<tr class="even">
<td>EffNet-B3 [58]</td>
<td>300x300</td>
<td>12M</td>
<td>1.8G</td>
<td>732.1</td>
<td>81.6</td>
</tr>
<tr class="odd">
<td>EffNet-B4 [58]</td>
<td>380x380</td>
<td>19M</td>
<td>4.2G</td>
<td>349.4</td>
<td>82.9</td>
</tr>
<tr class="even">
<td>EffNet-B5 [58]</td>
<td>456x456</td>
<td>30M</td>
<td>9.9G</td>
<td>169.1</td>
<td>83.6</td>
</tr>
<tr class="odd">
<td>EffNet-B6 [58]</td>
<td>528x528</td>
<td>43M</td>
<td>19.0G</td>
<td>96.9</td>
<td>84.0</td>
</tr>
<tr class="even">
<td>EffNet-B7 [58]</td>
<td>600x600</td>
<td>66M</td>
<td>37.0G</td>
<td>55.1</td>
<td>84.3</td>
</tr>
<tr class="odd">
<td>ViT-B/16 [20]</td>
<td>384x384</td>
<td>86M</td>
<td>55.4G</td>
<td>85.9</td>
<td>77.9</td>
</tr>
<tr class="even">
<td>ViT-L/16 [20]</td>
<td>384x384</td>
<td>307M</td>
<td>190.7G</td>
<td>27.3</td>
<td>76.5</td>
</tr>
<tr class="odd">
<td>DeiT-S [63]</td>
<td>224x224</td>
<td>22M</td>
<td>4.6G</td>
<td>940.4</td>
<td>79.8</td>
</tr>
<tr class="even">
<td>DeiT-B [63]</td>
<td>224x224</td>
<td>86M</td>
<td>17.5G</td>
<td>292.3</td>
<td>81.8</td>
</tr>
<tr class="odd">
<td>DeiT-B [63]</td>
<td>384x384</td>
<td>86M</td>
<td>55.4G</td>
<td>85.9</td>
<td>83.1</td>
</tr>
<tr class="even">
<td>Swin-T</td>
<td>224x224</td>
<td>29M</td>
<td>4.5G</td>
<td>755.2</td>
<td>81.3</td>
</tr>
<tr class="odd">
<td>Swin-S</td>
<td>224x224</td>
<td>50M</td>
<td>8.7G</td>
<td>436.9</td>
<td>83.0</td>
</tr>
<tr class="even">
<td>Swin-B</td>
<td>224x224</td>
<td>88M</td>
<td>15.4G</td>
<td>278.1</td>
<td>83.5</td>
</tr>
<tr class="odd">
<td>Swin-B</td>
<td>384x384</td>
<td>88M</td>
<td>47.0G</td>
<td>84.7</td>
<td>84.5</td>
</tr>
</tbody>
</table>
<div data-align="center">
<strong><a name="表1(b)">(b) 使用ImageNet-22K预训练的模型</a></strong>
</div>
<table>

<thead>
<tr class="header">
<th>方法</th>
<th>图像尺寸</th>
<th>参数数量</th>
<th>计算量 (FLOPs)</th>
<th>吞吐量 (图像/秒)</th>
<th>ImageNet Top-1 准确率</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>R-101x3 [38]</td>
<td>384x384</td>
<td>388M</td>
<td>204.6G</td>
<td>-</td>
<td>84.4</td>
</tr>
<tr class="even">
<td>R-152x4 [38]</td>
<td>480x480</td>
<td>937M</td>
<td>840.5G</td>
<td>-</td>
<td>85.4</td>
</tr>
<tr class="odd">
<td>ViT-B/16 [20]</td>
<td>384x384</td>
<td>86M</td>
<td>55.4G</td>
<td>85.9</td>
<td>84.0</td>
</tr>
<tr class="even">
<td>ViT-L/16 [20]</td>
<td>384x384</td>
<td>307M</td>
<td>190.7G</td>
<td>27.3</td>
<td>85.2</td>
</tr>
<tr class="odd">
<td>Swin-B</td>
<td>224x224</td>
<td>88M</td>
<td>15.4G</td>
<td>278.1</td>
<td>85.2</td>
</tr>
<tr class="even">
<td>Swin-B</td>
<td>384x384</td>
<td>88M</td>
<td>47.0G</td>
<td>84.7</td>
<td>86.4</td>
</tr>
<tr class="odd">
<td>Swin-L</td>
<td>384x384</td>
<td>197M</td>
<td>103.9G</td>
<td>42.1</td>
<td>87.3</td>
</tr>
</tbody>
</table>
<hr />
<p>与先前的最先进的基于Transformer的架构DeiT [63]相比，Swin
Transformer明显超过了复杂度相似的DeiT架构：使用224x224的输入，Swin-T（81.3%）比DeiT-S（79.8%）提高了+1.5%；使用224x224/384x384的输入，Swin-B（83.3%/84.5%）比DeiT-B（81.8%/83.1%）提高了+1.5%/1.4%。</p>
<p>与最先进的ConvNets，如RegNet [48]和EfficientNet [58]相比，Swin
Transformer实现了稍微更好的速度-准确度权衡。值得注意的是，尽管RegNet
[48]和EfficientNet [58]是通过彻底的架构搜索得到的，但提出的Swin
Transformer是从标准的Transformer进行了改进，具有进一步提升的潜力。</p>
<p><strong>使用ImageNet-22K预训练的结果</strong>
我们还对容量更大的Swin-B和Swin-L进行了ImageNet-22K的预训练。在ImageNet-1K图像分类上进行微调的结果如表1(b)所示。对于Swin-B，ImageNet-22K的预训练带来了1.8%~1.9%的提升，相比于从头开始在ImageNet-1K上训练。与以前在ImageNet-22K预训练的最佳结果相比，我们的模型在速度-准确度权衡方面取得了显著的改进：Swin-B获得了86.4%的top-1准确度，比具有类似推理吞吐量（84.7比85.9图像/秒）和稍低FLOPs（47.0G比55.4G）的ViT高2.4%。更大的Swin-L模型实现了87.3%的top-1准确度，比Swin-B模型好0.9%。</p>
<h3 id="在coco上进行目标检测">4.2. 在COCO上进行目标检测</h3>
<p><strong>设置</strong>：我们在COCO
2017数据集上进行目标检测和实例分割实验，该数据集包含了118K张训练图片，5K张验证图片和20K张测试图片。我们在验证集上进行了消融研究，并在测试集上进行了系统级别的比较。</p>
<p>对于消融研究，我们考虑了四种典型的目标检测框架：级联Mask
R-CNN、ATSS、RepPoints v2和Sparse
RCNN。对于这四种框架，我们使用了相同的设置：多尺度训练（将输入调整大小，使较短的一侧在480到800之间，较长的一侧最多为1333）、AdamW优化器（初始学习率为0.0001，权重衰减为0.05，批量大小为16）和3x调度（36个epochs）。</p>
<p>对于系统级别的比较，我们采用了改进版HTC（标记为HTC++），其中包括instaboost、更强大的多尺度训练、6x调度、soft-NMS和ImageNet-22K预训练模型作为初始化。</p>
<p>我们将我们的Swin
Transformer与标准的ConvNets（如ResNe(X)t）和先前的Transformer网络（如DeiT）进行了比较。比较时，只更改了主干网络，其他设置保持不变。值得注意的是，由于Swin
Transformer和ResNe(X)t具有分层特征图，因此它们可以直接应用于上述所有框架。而DeiT只产生单一分辨率的特征图，无法直接应用。为了公平比较，我们按照[81]的方法使用反卷积层为DeiT构建分层特征图。</p>
<p><strong>与ResNe(X)t的比较：</strong> <a
href="#表2(a)"><strong>表2(a)</strong></a>列出了Swin-T和ResNet-50在四个目标检测框架上的结果。我们的Swin-T架构在模型大小、FLOPs和延迟略大的情况下，带来了稳定的+3.4∼4.2的box
AP增益。</p>
<p><strong><a href="#表2(b)">表2(b)</a></strong>比较了使用Cascade Mask
R-CNN时Swin Transformer和不同模型容量的ResNe(X)t。Swin
Transformer实现了51.9的box AP和45.0的mask
AP的高检测精度，分别比ResNeXt101-64x4d高出+3.6和+3.3，后者具有相似的模型大小、FLOPs和延迟。</p>
<p>在改进的HTC框架的更高基线上，实现了52.3的box AP和46.0的mask AP，Swin
Transformer的增益也很高，分别为+4.1的box AP和+3.1的mask AP（<strong>见<a
href="#表2(c)">表2(c)</a></strong>）。</p>
<div data-align="center">
<strong><a name="表2">表2. 在COCO目标检测和实例分割任务上的结果。†
表示使用了额外的反卷积层来产生分层特征图。*
表示使用了多尺度测试。</a></strong>
</div>
<div data-align="center">
<strong><a name="表2(a)">(a) 不同的框架</a></strong>
</div>
<table>

<thead>
<tr class="header">
<th>方法</th>
<th>骨干网络</th>
<th>APbox</th>
<th>APbox50</th>
<th>APbox75</th>
<th>参数数量</th>
<th>FLOPs</th>
<th>FPS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cascade Mask R-CNN</td>
<td>R-50</td>
<td>46.3</td>
<td>64.3</td>
<td>50.5</td>
<td>82M</td>
<td>739G</td>
<td>18.0</td>
</tr>
<tr class="even">
<td>Swin-T</td>
<td>-</td>
<td>50.5</td>
<td>69.3</td>
<td>54.9</td>
<td>86M</td>
<td>745G</td>
<td>15.3</td>
</tr>
<tr class="odd">
<td>ATSS</td>
<td>R-50</td>
<td>43.5</td>
<td>61.9</td>
<td>47.0</td>
<td>32M</td>
<td>205G</td>
<td>28.3</td>
</tr>
<tr class="even">
<td>Swin-T</td>
<td>-</td>
<td>47.2</td>
<td>66.5</td>
<td>51.3</td>
<td>36M</td>
<td>215G</td>
<td>22.3</td>
</tr>
<tr class="odd">
<td>RepPointsV2</td>
<td>R-50</td>
<td>46.5</td>
<td>64.6</td>
<td>50.3</td>
<td>42M</td>
<td>274G</td>
<td>13.6</td>
</tr>
<tr class="even">
<td>Swin-T</td>
<td>-</td>
<td>50.0</td>
<td>68.5</td>
<td>54.2</td>
<td>45M</td>
<td>283G</td>
<td>12.0</td>
</tr>
<tr class="odd">
<td>Sparse R-CNN</td>
<td>R-50</td>
<td>44.5</td>
<td>63.4</td>
<td>48.2</td>
<td>106M</td>
<td>166G</td>
<td>21.0</td>
</tr>
<tr class="even">
<td>Swin-T</td>
<td>-</td>
<td>47.9</td>
<td>67.3</td>
<td>52.3</td>
<td>110M</td>
<td>172G</td>
<td>18.4</td>
</tr>
</tbody>
</table>
<div data-align="center">
<strong><a name="表2(b)">(b) 不同的骨干网络，使用Cascade Mask
R-CNN</a></strong>
</div>
<table>

<thead>
<tr class="header">
<th>骨干网络</th>
<th>APbox</th>
<th>APbox50</th>
<th>APbox75</th>
<th>APmask</th>
<th>APmask50</th>
<th>APmask75</th>
<th>参数数量</th>
<th>FLOPs</th>
<th>FPS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DeiT-S</td>
<td>48.0</td>
<td>67.2</td>
<td>51.7</td>
<td>41.4</td>
<td>64.2</td>
<td>44.3</td>
<td>80M</td>
<td>889G</td>
<td>10.4</td>
</tr>
<tr class="even">
<td>R50</td>
<td>46.3</td>
<td>64.3</td>
<td>50.5</td>
<td>40.1</td>
<td>61.7</td>
<td>43.4</td>
<td>82M</td>
<td>739G</td>
<td>18.0</td>
</tr>
<tr class="odd">
<td>Swin-T</td>
<td>50.5</td>
<td>69.3</td>
<td>54.9</td>
<td>43.7</td>
<td>66.6</td>
<td>47.1</td>
<td>86M</td>
<td>745G</td>
<td>15.3</td>
</tr>
<tr class="even">
<td>X101-32</td>
<td>48.1</td>
<td>66.5</td>
<td>52.4</td>
<td>41.6</td>
<td>63.9</td>
<td>45.2</td>
<td>101M</td>
<td>819G</td>
<td>12.8</td>
</tr>
<tr class="odd">
<td>Swin-S</td>
<td>51.8</td>
<td>70.4</td>
<td>56.3</td>
<td>44.7</td>
<td>67.9</td>
<td>48.5</td>
<td>107M</td>
<td>838G</td>
<td>12.0</td>
</tr>
<tr class="even">
<td>X101-64</td>
<td>48.3</td>
<td>66.4</td>
<td>52.3</td>
<td>41.7</td>
<td>64.0</td>
<td>45.1</td>
<td>140M</td>
<td>972G</td>
<td>10.4</td>
</tr>
<tr class="odd">
<td>Swin-B</td>
<td>51.9</td>
<td>70.9</td>
<td>56.5</td>
<td>45.0</td>
<td>68.4</td>
<td>48.7</td>
<td>145M</td>
<td>982G</td>
<td>11.6</td>
</tr>
</tbody>
</table>
<div data-align="center">
<strong><a name="表2(c)">(c) 系统级别的比较</a></strong>
</div>
<table style="width:100%;">

<thead>
<tr class="header">
<th>方法</th>
<th>mini-val</th>
<th>test-dev</th>
<th>参数数量</th>
<th>FLOPs</th>
<th>APbox</th>
<th>APmask</th>
<th>APbox</th>
<th>APmask</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RepPointsV2</td>
<td>*</td>
<td>*</td>
<td>185M</td>
<td>1440G</td>
<td>55.9</td>
<td>47.2</td>
<td>56.0</td>
<td>47.4</td>
</tr>
<tr class="even">
<td>Copy-paste</td>
<td>55.9</td>
<td>47.2</td>
<td>185M</td>
<td>1440G</td>
<td>56.0</td>
<td>47.4</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="odd">
<td>Swin-B (HTC++)</td>
<td>56.4</td>
<td>49.1</td>
<td>160M</td>
<td>1043G</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="even">
<td>Swin-L (HTC++)</td>
<td>57.1</td>
<td>49.5</td>
<td>284M</td>
<td>1470G</td>
<td>57.7</td>
<td>50.2</td>
<td>58.7</td>
<td>51.1</td>
</tr>
<tr class="odd">
<td>Swin-L (HTC++)*</td>
<td>58.0</td>
<td>50.4</td>
<td>284M</td>
<td>-</td>
<td>58.7</td>
<td>51.1</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>关于推理速度，虽然ResNe(X)t是通过高度优化的Cudnn函数构建的，但我们的架构是使用内置的PyTorch函数实现的，并非所有函数都经过了良好的优化。深度优化超出了本文的范围。</p>
<p><strong>与DeiT的比较：</strong> 使用Cascade Mask
R-CNN框架，DeiT-S的性能如<a
href="#表2(b)"><strong>表2(b)</strong></a>所示。Swin-T的结果比DeiT-S高出+2.5的box
AP和+2.3的mask AP，模型大小相似（86M对比80M），推理速度显著更高（15.3
FPS对比10.4
FPS）。DeiT的推理速度较低主要是因为其对输入图像大小的复杂度为二次方。</p>
<p><strong>与之前的最先进模型的比较：</strong><a
href="#表2(c)"><strong>表2(c)</strong></a>将我们的最佳结果与之前的最先进模型进行了比较。我们的最佳模型在COCO测试集（test-dev）上实现了58.7的box
AP和51.1的mask AP，比先前的最佳结果分别高出+2.7的box AP（Copy-paste
[26]，不使用外部数据）和+2.6的mask AP（DetectoRS [46]）。</p>
<p><strong>语义分割在ADE20K数据集上的实验设置：</strong> ADE20K [83]
是一个广泛使用的语义分割数据集，涵盖了150个语义类别。总共有2.5万张图像，其中2万张用于训练，2千张用于验证，另外3千张用于测试。我们在mmseg
[16]
中使用UperNet作为基本框架，因为它具有较高的效率。更多细节将在附录中提供。</p>
<p><strong>结果：</strong><a
href="#表3"><strong>表格3</strong></a>列出了不同方法/骨干网络组合的mIoU、模型大小（#参数）、FLOPs和FPS。</p>
<div data-align="center">
<strong><a name="表3">表3. ADE20K
语义分割的结果（在验证集和测试集上）。†
表示使用了额外的反卷积层来产生分层特征图。 ‡ 表示该模型在 ImageNet-22K
上进行了预训练。</a></strong>
</div>
<table>

<thead>
<tr class="header">
<th>方法</th>
<th>主干网络</th>
<th>mIoU (val)</th>
<th>mIoU (test)</th>
<th>参数数量</th>
<th>FLOPs</th>
<th>FPS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DANet [23]</td>
<td>ResNet-101</td>
<td>45.2</td>
<td>-</td>
<td>69M</td>
<td>1119G</td>
<td>15.2</td>
</tr>
<tr class="even">
<td>DLab.v3+ [11]</td>
<td>ResNet-101</td>
<td>44.1</td>
<td>-</td>
<td>63M</td>
<td>1021G</td>
<td>16.0</td>
</tr>
<tr class="odd">
<td>ACNet [24]</td>
<td>ResNet-101</td>
<td>45.9</td>
<td>38.5</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="even">
<td>DNL [71]</td>
<td>ResNet-101</td>
<td>46.0</td>
<td>56.2</td>
<td>69M</td>
<td>1249G</td>
<td>14.8</td>
</tr>
<tr class="odd">
<td>OCRNet [73]</td>
<td>ResNet-101</td>
<td>45.3</td>
<td>56.0</td>
<td>56M</td>
<td>923G</td>
<td>19.3</td>
</tr>
<tr class="even">
<td>UperNet [69]</td>
<td>ResNet-101</td>
<td>44.9</td>
<td>-</td>
<td>86M</td>
<td>1029G</td>
<td>20.1</td>
</tr>
<tr class="odd">
<td>OCRNet [73]</td>
<td>HRNet-w48</td>
<td>45.7</td>
<td>-</td>
<td>71M</td>
<td>664G</td>
<td>12.5</td>
</tr>
<tr class="even">
<td>DLab.v3+ [11]</td>
<td>ResNeSt-101</td>
<td>46.9</td>
<td>55.1</td>
<td>66M</td>
<td>1051G</td>
<td>11.9</td>
</tr>
<tr class="odd">
<td>DLab.v3+ [11]</td>
<td>ResNeSt-200</td>
<td>48.4</td>
<td>-</td>
<td>88M</td>
<td>1381G</td>
<td>8.1</td>
</tr>
<tr class="even">
<td>SETR [81]</td>
<td>T-Large‡</td>
<td>50.3</td>
<td>61.7</td>
<td>308M</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="odd">
<td>UperNet</td>
<td>DeiT-S†</td>
<td>44.0</td>
<td>-</td>
<td>52M</td>
<td>1099G</td>
<td>16.2</td>
</tr>
<tr class="even">
<td>UperNet</td>
<td>Swin-T</td>
<td>46.1</td>
<td>-</td>
<td>60M</td>
<td>945G</td>
<td>18.5</td>
</tr>
<tr class="odd">
<td>UperNet</td>
<td>Swin-S</td>
<td>49.3</td>
<td>-</td>
<td>81M</td>
<td>1038G</td>
<td>15.2</td>
</tr>
<tr class="even">
<td>UperNet</td>
<td>Swin-B‡</td>
<td>51.6</td>
<td>-</td>
<td>121M</td>
<td>1841G</td>
<td>8.7</td>
</tr>
<tr class="odd">
<td>UperNet</td>
<td>Swin-L‡</td>
<td><strong>53.5</strong></td>
<td><strong>62.8</strong></td>
<td>234M</td>
<td>3230G</td>
<td>6.2</td>
</tr>
</tbody>
</table>
<p>从这些结果可以看出，与计算成本相似的DeiT-S相比，Swin-S的mIoU要高出5.3（49.3比44.0）。它也比ResNet-101高出4.4
mIoU，比ResNeSt-101 [78] 高出2.4
mIoU。我们的经过ImageNet-22K预训练的Swin-L模型在验证集上达到了53.5
mIoU，超过了之前最好的模型，其mIoU高出3.2（SETR [81]
的mIoU为50.3，但其模型规模更大）。</p>
<h3 id="ablation-study">4.4. Ablation Study</h3>
<p>在这一部分中，我们对所提出的Swin
Transformer中的重要设计元素进行了剖析，使用了ImageNet-1K图像分类、COCO目标检测的级联掩蔽R-CNN，以及ADE20K语义分割的UperNet。</p>
<p><strong>Shifted Windows</strong> <a
href="#表4"><strong>表4</strong></a>
报告了在三个任务上对移位窗口方法进行的剖析。</p>
<div data-align="center">
<strong><a name="表4">表格 4.
偏移窗口方法和不同位置嵌入方法的消融研究，使用 Swin-T
架构在三个基准上进行，不做偏移：所有自注意力模块采用常规窗口划分，不做偏移；abs.
pos.: ViT 的绝对位置嵌入项；rel. pos.:
默认设置下的相对位置偏置项（参见公式（4））；app.:
公式（4）中的第一个缩放的点积项。</a></strong>
</div>
<table>

<thead>
<tr class="header">
<th></th>
<th>ImageNet</th>
<th>ImageNet</th>
<th>COCO</th>
<th>COCO</th>
<th>ADE20K</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>top-1</td>
<td>top-5</td>
<td><span class="math inline">\(AP^{box}\)</span></td>
<td><span class="math inline">\(AP^{mask}\)</span></td>
<td>mIoU</td>
</tr>
<tr class="even">
<td>无偏移窗口</td>
<td>80.2</td>
<td>95.1</td>
<td>47.7</td>
<td>41.5</td>
<td>43.3</td>
</tr>
<tr class="odd">
<td>偏移窗口</td>
<td>81.3</td>
<td>95.6</td>
<td>50.5</td>
<td>43.7</td>
<td>46.1</td>
</tr>
<tr class="even">
<td>无位置编码</td>
<td>80.1</td>
<td>94.9</td>
<td>49.2</td>
<td>42.6</td>
<td>43.8</td>
</tr>
<tr class="odd">
<td>绝对位置编码</td>
<td>80.5</td>
<td>95.2</td>
<td>49.0</td>
<td>42.4</td>
<td>43.2</td>
</tr>
<tr class="even">
<td>绝对+相对位置编码</td>
<td>81.3</td>
<td>95.6</td>
<td>50.2</td>
<td>43.4</td>
<td>44.0</td>
</tr>
<tr class="odd">
<td>相对位置编码（无应用）</td>
<td>79.3</td>
<td>94.7</td>
<td>48.2</td>
<td>41.9</td>
<td>44.1</td>
</tr>
<tr class="even">
<td>相对位置编码</td>
<td>81.3</td>
<td>95.6</td>
<td>50.5</td>
<td>43.7</td>
<td>46.1</td>
</tr>
</tbody>
</table>
<p>使用移位窗口划分的Swin-T优于在每个阶段都建立在单窗口划分的对应模型，对于ImageNet-1K，top-1准确度提高了+1.1%，对于COCO，box
AP/mask AP提高了+2.8/+2.2，对于ADE20K，mIoU提高了+2.8。</p>
<p><strong>相对位置偏置</strong> <a href="#表4"><strong>表4</strong></a>
还报告了相对位置偏置的剖析。相对位置偏置对于所有三个任务都是有效的，相对于没有位置编码和具有绝对位置嵌入的模型，它们分别提高了+3.3/+3.2
box AP，+2.3/+2.9 mask AP和+2.3/+2.9
mIoU。这表明了相对位置偏置的有效性。同时值得注意的是，虽然包含绝对位置嵌入可以提高图像分类的准确度（+0.4%），但会降低目标检测和语义分割的准确度（COCO的-0.2
box/mask AP，ADE20K的-0.6 mIoU）。</p>
<p><strong>不同自注意方法</strong> <a
href="#表5"><strong>表5</strong></a>
比较了不同自注意计算方法的实际速度以及实现。</p>
<div data-align="center">
<strong><a name="表5">表格5. 在V100
GPU上不同自注意力计算方法和实现的实际速度。</a></strong>
</div>
<table>

<thead>
<tr class="header">
<th>方法</th>
<th>MSA in a stage (ms)S1</th>
<th>S2</th>
<th>S3</th>
<th>S4</th>
<th>Arch. (FPS)T</th>
<th>S</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>滑动窗口 (朴素)</td>
<td>122.5</td>
<td>38.3</td>
<td>12.1</td>
<td>7.6</td>
<td>183</td>
<td>109</td>
<td>77</td>
</tr>
<tr class="even">
<td>滑动窗口 (内核)</td>
<td>7.6</td>
<td>4.7</td>
<td>2.7</td>
<td>1.8</td>
<td>488</td>
<td>283</td>
<td>187</td>
</tr>
<tr class="odd">
<td>Performer [14]</td>
<td>4.8</td>
<td>2.8</td>
<td>1.8</td>
<td>1.5</td>
<td>638</td>
<td>370</td>
<td>241</td>
</tr>
<tr class="even">
<td>窗口 (无偏移)</td>
<td>2.8</td>
<td>1.7</td>
<td>1.2</td>
<td>0.9</td>
<td>770</td>
<td>444</td>
<td>280</td>
</tr>
<tr class="odd">
<td>偏移窗口 (填充)</td>
<td>3.3</td>
<td>2.3</td>
<td>1.9</td>
<td>2.2</td>
<td>670</td>
<td>371</td>
<td>236</td>
</tr>
<tr class="even">
<td>偏移窗口 (循环)</td>
<td>3.0</td>
<td>1.9</td>
<td>1.3</td>
<td>1.0</td>
<td>755</td>
<td>437</td>
<td>278</td>
</tr>
</tbody>
</table>
<p>我们的循环实现比朴素的填充更具硬件效率，特别是对于更深的阶段。总体而言，它使Swin-T、Swin-S和Swin-B分别提速了13%、18%和18%。</p>
<p>在四个网络阶段上，基于提议的移位窗口方法构建的自注意模块，在朴素/内核实现上比基于滑动窗口的模块更高效，分别为40.8×/2.5×，20.2×/2.5×，9.3×/2.1×和7.6×/1.8×。总的来说，基于移位窗口的Swin
Transformer架构在Swin-T、Swin-S和Swin-B上比基于滑动窗口的变体分别快4.1/1.5、4.0/1.5和3.6/1.5倍。表6比较了它们在三个任务上的准确性，表明它们在视觉建模方面具有相似的准确性。</p>
<p>与Performer
[14]相比，后者是最快的Transformer架构之一（参见[60]），所提出的基于移位窗口的自注意计算和整体的Swin
Transformer架构略快（见<a
href="#表5">表5</a>），同时使用Swin-T在ImageNet-1K上比Performer提高了+2.3%的top-1准确度（见<a
href="#表6">表6</a>）。</p>
<div data-align="center">
<strong><a name="表6">表格6.
在三个基准测试中，使用不同自注意力计算方法的Swin
Transformer的准确度。</a></strong>
</div>
<table style="width:100%;">

<thead>
<tr class="header">
<th></th>
<th></th>
<th>ImageNet</th>
<th>ImageNet</th>
<th>COCO</th>
<th>COCO</th>
<th>ADE20K</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>Backbone</td>
<td>top-1</td>
<td>top-5</td>
<td><span class="math inline">\(AP^{box}\)</span></td>
<td><span class="math inline">\(AP^{mask}\)</span></td>
<td>mIoU</td>
</tr>
<tr class="even">
<td>滑动窗口</td>
<td>Swin-T</td>
<td>81.4</td>
<td>95.6</td>
<td>50.2</td>
<td>43.5</td>
<td>45.8</td>
</tr>
<tr class="odd">
<td>表演家 [14]</td>
<td>Swin-T</td>
<td>79.0</td>
<td>94.2</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="even">
<td>移动窗口</td>
<td>Swin-T</td>
<td>81.3</td>
<td>95.6</td>
<td>50.5</td>
<td>43.7</td>
<td>46.1</td>
</tr>
</tbody>
</table>
<h2 id="结论">5、 结论</h2>
<p>本文介绍了Swin
Transformer，这是一种新的视觉Transformer模型，它生成了一个分层的特征表示，并且相对于输入图像大小具有线性的计算复杂度。Swin
Transformer在COCO目标检测和ADE20K语义分割任务上取得了最先进的性能，明显超越了先前的最佳方法。我们希望Swin
Transformer在各种视觉问题上的强大性能能够鼓励对视觉和语言信号进行统一建模。</p>
<p>作为Swin
Transformer的关键组成部分，基于移位窗口的自注意力机制在视觉问题上表现出色且高效，我们期待着在自然语言处理领域中进一步研究其应用。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/" class="category-chain-item">论文翻译</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%BF%BB%E8%AF%91/" class="print-no-link">#翻译</a>
      
        <a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" class="print-no-link">#论文阅读</a>
      
        <a href="/tags/Swin-Transformer/" class="print-no-link">#Swin Transformer</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Swin Transformer：使用偏移窗口的分层视觉变换器</div>
      <div>https://yelelalearn.github.io/2024/04/16/Swin-Transformer/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yelearn</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月16日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年4月27日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/04/17/4-17%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="《Learn More, Study Less!》-读书笔记-1">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">《Learn More, Study Less!》-读书笔记-1</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/04/14/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%88%86%E6%9E%90/" title="数字图像处理-直方图分析">
                        <span class="hidden-mobile">数字图像处理-直方图分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"x7A49f5gA5IVWB4Xp0FgxcXv-gzGzoHsz","appKey":"9tgxMZE38q9kf8iwHtUVUp8s","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
